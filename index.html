<!DOCTYPE html>
<html lang="ru">
<<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Glass App v35.0</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script> 
    <style>
        :root { 
            --bg-color: #f2f2f7; 
            --text-color: #000000; 
            --glass-bg: rgba(255, 255, 255, 0.75); 
            --glass-border: rgba(255, 255, 255, 0.5); 
            --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.07); 
            --accent: #007aff; 
            --danger: #ff3b30; 
            --success: #34c759; 
            --tab-bg: rgba(255,255,255,0.95); 
            --toggle-bg: #e9e9ea; 
            --toggle-circle: #ffffff; 
            --icon-color: #3a3a3c; 
            --bb-grid: rgba(0,0,0,0.05); 
            --bb-cell: rgba(255,255,255,0.5); 
            --rank-gold: #ffd700; 
            --rank-silver: #c0c0c0; 
            --rank-bronze: #cd7f32; 
            --sudoku-border: rgba(0,0,0,0.1); 
            --sudoku-thick: #000000; 
            --sudoku-sel: rgba(0,122,255,0.25); 
            --sudoku-same: rgba(0,122,255,0.2); 
            --sudoku-err: rgba(255, 59, 48, 0.2);
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
        }
        [data-theme="dark"] { 
            --bg-color: #000000; 
            --text-color: #ffffff; 
            --glass-bg: rgba(30, 30, 30, 0.75); 
            --glass-border: rgba(255, 255, 255, 0.15); 
            --shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5); 
            --tab-bg: rgba(30,30,30, 0.95); 
            --toggle-bg: #2c2c2e; 
            --toggle-circle: #636366; 
            --icon-color: #aeaeb2; 
            --accent: #0a84ff; 
            --bb-grid: rgba(255,255,255,0.05); 
            --bb-cell: rgba(255,255,255,0.1); 
            --sudoku-border: rgba(255,255,255,0.15); 
            --sudoku-thick: #ffffff; 
            --sudoku-sel: rgba(10, 132, 255, 0.4); 
            --sudoku-same: rgba(10, 132, 255, 0.25); 
            --sudoku-err: rgba(255, 69, 58, 0.3); 
        }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        img { pointer-events: none; } canvas:not(#towerCanvas) { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2147483647 !important; pointer-events: none; }
        
        body { 
            background-color: var(--bg-color); 
            color: var(--text-color); 
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            margin: 0; 
            padding: 0; 
            width: 100%;
            height: 100dvh; 
            overflow: hidden; 
            overscroll-behavior: none; 
            touch-action: none; 
            transition: background-color 0.4s ease; 
        }
        
        .icon { width: 24px; height: 24px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; } .icon-sm { width: 18px; height: 18px; }
        
        .screen { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            padding: 20px; 
            padding-top: calc(90px + var(--safe-top)); 
            padding-bottom: calc(110px + var(--safe-bottom)); 
            overflow-y: auto; 
            -webkit-overflow-scrolling: touch; 
            opacity: 0; 
            pointer-events: none; 
            transform: scale(0.98); 
            transition: opacity 0.3s ease, transform 0.3s ease; 
            touch-action: pan-y; 
        } 
        .screen.active { opacity: 1; pointer-events: auto; transform: scale(1); z-index: 1; }
        
        .game-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: var(--bg-color); z-index: 9999; 
            display: flex; flex-direction: column; 
            transform: translateY(100%); 
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            overflow: hidden;
            touch-action: none; 
        } 
        .game-overlay.visible { transform: translateY(0); }

        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; margin-top: 10px; } .app-title { font-size: 28px; font-weight: 800; letter-spacing: -0.5px; }
        
        .card { background: var(--glass-bg); backdrop-filter: blur(20px); border-radius: 20px; border: 1px solid var(--glass-border); padding: 20px; margin-bottom: 15px; box-shadow: var(--shadow); display: flex; align-items: center; gap: 15px; transition: transform 0.2s; cursor: pointer; } .card:active { transform: scale(0.97); }
        .card.disabled { cursor: default; opacity: 0.7; } .card.disabled:active { transform: none; }
        .game-icon-box { width: 48px; height: 48px; border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; }
        
        .game-top-bar { 
            padding: 15px 20px; 
            padding-top: calc(110px + var(--safe-top)); 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        } 
        
        .back-btn { color: var(--accent); font-size: 17px; font-weight: 500; display: flex; align-items: center; gap: 4px; cursor: pointer; } 
        .game-area { flex: 1; display: flex; justify-content: center; align-items: center; overflow: hidden; padding-bottom: 20px; position: relative; width: 100%; flex-direction: column; }

        .tab-bar { 
            position: fixed; 
            bottom: 0; 
            left: 0; 
            width: 100%; 
            height: calc(75px + var(--safe-bottom)); 
            background: var(--tab-bg); 
            backdrop-filter: blur(30px); 
            border-top: 0.5px solid var(--glass-border); 
            display: flex; 
            justify-content: space-around; 
            padding-top: 10px; 
            padding-bottom: var(--safe-bottom); 
            z-index: 50; 
        } 
        .tab-item { display: flex; flex-direction: column; align-items: center; font-size: 11px; color: #8e8e93; font-weight: 500; cursor: pointer; flex: 1; background: transparent !important; } 
        .tab-item.active { color: var(--accent); background: transparent !important; } 
        .tab-item svg { width: 26px; height: 26px; margin-bottom: 4px; }

        .lb-title-lg { font-size: 32px; font-weight: 800; margin-bottom: 20px; }
        .lb-selector { background: var(--glass-bg); padding: 10px 15px; border-radius: 12px; font-weight: 600; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border: 1px solid var(--glass-border); margin-bottom: 15px; position: relative; z-index: 205; }
        .lb-selector:active { background: rgba(0,0,0,0.05); }
        .lb-list { padding-bottom: 100px; }
        
        .dropdown-menu { 
            position: absolute; 
            top: 230px; 
            left: 20px; 
            right: 20px; 
            background: var(--glass-bg); 
            backdrop-filter: blur(40px);
            border-radius: 16px; 
            padding: 10px; 
            z-index: 23000; 
            border: 1px solid var(--glass-border);
            box-shadow: 0 15px 50px rgba(0,0,0,0.25);
            transform-origin: top center;
            transform: scaleY(0);
            opacity: 0;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.2s;
            pointer-events: none;
        }
        .dropdown-menu.active { transform: scaleY(1); opacity: 1; pointer-events: auto; }
        .dropdown-catcher { position: fixed; top:0; left:0; width:100%; height:100%; z-index: 22999; display: none; }
        .dropdown-catcher.active { display: block; }

        .dd-item { padding: 12px 15px; font-size: 16px; border-radius: 10px; cursor: pointer; margin-bottom: 2px; transition: background 0.2s; }
        .dd-item:last-child { margin-bottom: 0; }
        .dd-item:active { background: rgba(0,0,0,0.05); }
        .dd-item.selected { color: var(--accent); font-weight: 700; background: rgba(0,122,255,0.1); }

        .lb-item { display: flex; align-items: center; padding: 12px; background: var(--glass-bg); margin-bottom: 8px; border-radius: 14px; border: 1px solid var(--glass-border); transition: transform 0.1s; }
        .lb-item:active { transform: scale(0.98); }
        .lb-rank { font-size: 16px; font-weight: 700; width: 30px; text-align: center; margin-right: 5px; color: #8e8e93; }
        .lb-avatar { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; margin-right: 12px; background: #ddd; }
        .lb-info { flex: 1; }
        .lb-name { font-weight: 600; font-size: 15px; margin-bottom: 2px; }
        .lb-val { font-size: 13px; color: #8e8e93; font-weight: 500; }
        .lb-medal { width: 24px; height: 24px; margin-left: -5px; margin-right: 10px; }
        .rank-1 .lb-rank, .rank-2 .lb-rank, .rank-3 .lb-rank { display: none; }

        .lb-sticky-user { position: fixed; bottom: calc(30px + var(--safe-bottom)); left: 20px; right: 20px; background: var(--accent); color: white; padding: 12px; border-radius: 20px; display: flex; align-items: center; box-shadow: 0 10px 40px rgba(0,122,255,0.4); z-index: 22000; transform: translateY(200%); transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); pointer-events: none; }
        .lb-sticky-user.visible { transform: translateY(0); pointer-events: auto; }
        .lb-sticky-user .lb-rank { color: rgba(255,255,255,0.8); }
        .lb-sticky-user .lb-val { color: rgba(255,255,255,0.9); }
        .lb-sticky-user .lb-name { color: white; }

        .settings-group { background: var(--glass-bg); border-radius: 16px; padding: 0 16px; margin-bottom: 20px; border: 1px solid var(--glass-border); width: 100%; }
        .settings-row { display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 0.5px solid rgba(128,128,128,0.2); }
        .settings-row:last-child { border-bottom: none; }
        .settings-label { font-size: 17px; font-weight: 500; display: flex; align-items: center; gap: 12px; }
        .theme-switch { position: relative; width: 64px; height: 34px; background: var(--toggle-bg); border-radius: 20px; cursor: pointer; padding: 2px; } 
        .theme-icons { position: absolute; top:0; left:0; width:100%; height:100%; display: flex; justify-content: space-between; align-items: center; padding: 0 7px; color: var(--icon-color); pointer-events: none; } 
        .switch-circle { position: absolute; top: 2px; left: 2px; width: 30px; height: 30px; background: var(--toggle-circle); border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.15); transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1); z-index: 2; } 
        [data-theme="dark"] #themeToggle .switch-circle { transform: translateX(30px); }
        #liteToggle.active .switch-circle { transform: translateX(30px); }

        .toggle-labels { position: absolute; width: 100%; height: 100%; top:0; left:0; display: flex; justify-content: space-between; align-items: center; padding: 0 8px; font-size: 10px; font-weight: 800; color: #8e8e93; pointer-events: none; }
        
        .modal-overlay { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.4); backdrop-filter: blur(5px); display: flex; align-items: center; justify-content: center; z-index: 22500; opacity: 0; pointer-events: none; transition: opacity 0.3s; touch-action: none; } 
        .modal-overlay.visible { opacity: 1; pointer-events: auto; } 
        
        .modal { 
            background: var(--bg-color); 
            width: 90%; 
            max-width: 320px; 
            max-height: 85vh; 
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 20px; 
            border-radius: 24px; 
            text-align: center; 
            box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
            border: 1px solid var(--glass-border); 
            transition: transform 0.4s ease; 
        }
        .modal.rotate-180 { transform: rotate(180deg); }
        
        .segment-control { position: relative; background: var(--toggle-bg); border-radius: 30px; padding: 0; display: flex; width: 100%; margin-top: 15px; overflow: hidden; height: 46px; border: none; }
        .segment-control.vertical { flex-direction: column; height: 100%; }
        
        .segment-glider { 
            position: absolute; 
            top: 0; left: 0; 
            width: 50%; height: 100%; 
            background: var(--accent); 
            border-radius: 30px; 
            z-index: 1; 
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 2px 10px rgba(0,0,0,0.2); 
        }
        .vertical .segment-glider { width: 100%; height: 33.33%; border-radius: 30px; }
        
        .segment-item { position: relative; flex: 1; text-align: center; font-size: 15px; font-weight: 600; color: var(--text-color); cursor: pointer; z-index: 2; transition: color 0.2s; display: flex; align-items: center; justify-content: center; opacity: 0.6; }
        .segment-item.active { color: white; opacity: 1; }

        .panel-hidden { display: none; opacity: 0; transform: translateX(20px); transition: opacity 0.3s, transform 0.3s; }
        .panel-visible { display: block; opacity: 1; transform: translateX(0); animation: fadeInSlide 0.3s ease forwards; }
        @keyframes fadeInSlide { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }

        .input-group { display: flex; gap: 8px; margin-top: 8px; width: 100%; box-sizing: border-box; }
        .input-glass { flex: 1; background: var(--toggle-bg); border: none; padding: 12px; border-radius: 12px; font-size: 16px; color: var(--text-color); outline: none; text-align: center; font-weight: 600; min-width: 0; }
        .btn-secondary { background: var(--toggle-bg); color: var(--text-color); font-weight: 600; padding: 12px; border-radius: 12px; border: none; cursor: pointer; white-space: nowrap; flex-shrink: 0; }
        .btn-secondary:active { opacity: 0.7; }

        .diff-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; } 
        .diff-btn { background: var(--toggle-bg); padding: 12px; border-radius: 12px; font-size: 15px; font-weight: 500; cursor: pointer; border: 2px solid transparent; color: var(--text-color); } 
        .diff-btn.selected { border-color: var(--accent); color: var(--accent); background: rgba(0,122,255,0.1); } 
        .btn-main { background: var(--accent); color: white; border: none; padding: 12px; width: 100%; border-radius: 14px; font-size: 17px; font-weight: 600; margin-top: 15px; cursor: pointer; transition: transform 0.1s; } 
        .btn-main:active { transform: scale(0.98); }
        
        .saper-icon { width: 22px; height: 22px; stroke-width: 2; }
        .saper-mine { width: 24px; height: 24px; fill: var(--danger); animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .saper-flag { width: 20px; height: 20px; fill: #ff3b30; stroke: none; animation: popIn 0.2s ease; }
        .crown-icon { width: 60px; height: 60px; margin-bottom: 10px; fill: #000; [data-theme="dark"] & { fill: #fff; } }
        
        .bottom-controls { 
            position: fixed; 
            bottom: calc(40px + var(--safe-bottom)); 
            left: 50%; 
            transform: translateX(-50%); 
            display: flex; 
            z-index: 10001; 
            min-width: 220px;
        } 

        .grid { display: grid; gap: 5px; padding: 10px; background: var(--glass-bg); border-radius: 16px; transition: transform 0.3s; } 
        .cell { width: 38px; height: 38px; background: rgba(255,255,255,0.6); [data-theme="dark"] & { background: rgba(255,255,255,0.12); } border: 1px solid rgba(0,0,0,0.05); border-radius: 8px; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 700; cursor: pointer; } 
        .cell.revealed { background: rgba(220,220,220,0.5); [data-theme="dark"] & { background: rgba(0,0,0,0.3); } } 
        .c-1 { color: #007aff; } .c-2 { color: #34c759; } .c-3 { color: #ff3b30; }
        
        .checkers-board { display: flex; flex-wrap: wrap; width: 90vw; height: 90vw; max-width: 350px; max-height: 350px; background: #fff; border: 4px solid #000; border-radius: 4px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); padding:0; margin:0; } .ch-cell { width: 12.5%; height: 12.5%; display: flex; justify-content: center; align-items: center; position: relative; } .ch-cell.light { background: #fff !important; } .ch-cell.dark { background: #222 !important; } .ch-cell.highlight::after { content:''; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,122,255,0.5); pointer-events:none; } .checker { width: 80%; height: 80%; border-radius: 50%; position: relative; transition: transform 0.2s; z-index: 2; box-shadow: 0 3px 6px rgba(0,0,0,0.5); } .checker.white { background: #f0f0f0; border: 3px solid #ccc; } .checker.black { background: #444; border: 3px solid #777; } .checker.king::before { content:''; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:40%; height:40%; border-radius:50%; border:3px solid #ff3b30; } .checker.selected { transform: scale(1.15); border-color: var(--accent); z-index: 10; box-shadow: 0 0 15px rgba(0,122,255,0.8); }

        .checkers-wrapper { width:100%; height:100%; display:flex; justify-content:center; align-items:center; padding-bottom: 25vh; }

        .bb-game-container { display: flex; flex-direction: column; align-items: center; width: 100%; height: 100%; padding-top: 10px; position: relative; } 
        .bb-score-box { font-size: 40px; font-weight: 800; color: var(--accent); margin-bottom: 20px; transition: color 0.3s, transform 0.2s; } 
        .bb-score-box.active-combo { color: #ff9500; text-shadow: 0 0 15px rgba(255, 149, 0, 0.4); transform: scale(1.05); }
        .bb-grid { display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); gap: 4px; width: 90vw; height: 90vw; max-width: 350px; max-height: 350px; background: var(--bb-grid); padding: 4px; border-radius: 12px; position: relative; } 
        .bb-cell { background: var(--bb-cell); border-radius: 6px; transition: transform 0.2s, opacity 0.2s, background-color 0.15s; } 
        .bb-cell.filled { box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1); } 
        .bb-cell.no-transition { transition: none !important; }
        
        @keyframes popInGray {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .bb-cell.appear-gray {
            animation: popInGray 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        /* FIXED v34.1: Lite Mode - отключаем тяжёлые эффекты для Android */
        body.lite-mode .bb-cell {
            transition: none !important;
            animation: none !important;
        }
        body.lite-mode .bb-cell.appear-gray {
            animation: none !important;
        }
        body.lite-mode .card,
        body.lite-mode .modal,
        body.lite-mode .settings-group,
        body.lite-mode .dropdown-menu {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        body.lite-mode .tab-bar {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        body.lite-mode .modal-overlay {
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        
        .shake-screen { animation: shakeGame 0.3s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shakeGame { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-2px, 0, 0); } 40%, 60% { transform: translate3d(2px, 0, 0); } }

        .bb-cell.pre-clear { opacity: 1; transform: scale(0.95); transition: background-color 0.1s, transform 0.1s; box-shadow: 0 0 5px rgba(0,0,0,0.1); }
        .bb-footer { position: absolute; bottom: calc(30px + var(--safe-bottom)); width: 100%; height: 120px; display: flex; justify-content: space-between; align-items: center; padding: 0 10px; } 
        .bb-shape-container { flex: 1; height: 100%; display: flex; justify-content: center; align-items: center; position: relative; cursor: pointer; } 
        .bb-shape-preview { display: grid; gap: 2px; pointer-events: none; touch-action: none; transition: opacity 0.2s; } 
        .bb-block { width: 18px; height: 18px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); }
        .drag-ghost { position: fixed; pointer-events: none; z-index: 10000; opacity: 0.95; width: max-content; height: max-content; } 
        .drag-ghost .bb-block { width: 100%; height: 100%; border-radius: 6px; box-shadow: 0 8px 20px rgba(0,0,0,0.35); } 
        
        .bb-c-1 { background: #ff3b30; color: #ff3b30; } .bb-c-2 { background: #ff9500; color: #ff9500; } .bb-c-3 { background: #ffcc00; color: #ffcc00; } .bb-c-4 { background: #34c759; color: #34c759; } .bb-c-5 { background: #007aff; color: #007aff; } .bb-c-6 { background: #5856d6; color: #5856d6; } .bb-c-7 { background: #af52de; color: #af52de; } .bb-shadow { background: rgba(0,0,0,0.15) !important; box-shadow: none !important; }
        
        .combo-popup { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 32px; font-weight: 900; color: #ffcc00; text-shadow: 0 2px 10px rgba(0,0,0,0.3); pointer-events: none; z-index: 1000; animation: comboPop 1s ease-out forwards; white-space: nowrap; }
        .all-clear-popup { position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%); display:flex; flex-direction:column; align-items:center; z-index: 1002; pointer-events: none; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .ac-text { font-size: 42px; font-weight: 900; background: linear-gradient(135deg, #FFD700, #FFA500); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 10px 30px rgba(255, 165, 0, 0.5); letter-spacing: -1px; }
        .ac-score { font-size: 24px; font-weight: 700; color: var(--text-color); margin-top: 10px; background: var(--glass-bg); padding: 5px 15px; border-radius: 12px; }
        @keyframes comboPop { 0% { opacity: 0; transform: translate(-50%, -30%) scale(0.5); } 20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 100% { opacity: 0; transform: translate(-50%, -100%) scale(1); } }
        
        .avatar { width: 100px; height: 100px; border-radius: 50%; background: #e1e1e1; margin-bottom: 15px; object-fit: cover; }

        .sudo-board { 
            display: grid; 
            grid-template-columns: repeat(9, 1fr); 
            width: 90vw; 
            height: 90vw; 
            max-width: 350px; 
            max-height: 350px; 
            background: var(--bg-color); 
            border: 2px solid var(--sudoku-thick); 
            margin: 10px auto; 
            border-radius: 4px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.1); 
            position: relative;
        }
        
        .sudo-board::before {
            content: ''; position: absolute; top: 0; left: 33.33%; width: 33.33%; height: 100%;
            border-left: 2px solid var(--sudoku-thick); border-right: 2px solid var(--sudoku-thick);
            pointer-events: none; z-index: 5;
        }
        .sudo-board::after {
            content: ''; position: absolute; left: 0; top: 33.33%; width: 100%; height: 33.33%;
            border-top: 2px solid var(--sudoku-thick); border-bottom: 2px solid var(--sudoku-thick);
            pointer-events: none; z-index: 5;
        }

        .sudo-cell { 
            border: 0.5px solid var(--sudoku-border); 
            display: flex; justify-content: center; align-items: center; 
            font-size: 20px; font-weight: 500; 
            position: relative; cursor: pointer; 
            transition: background 0.1s; 
        }
        
        .sudo-cell.same-num { background: var(--sudoku-same); font-weight: 800; color: var(--accent); }
        .sudo-cell.error { background: var(--sudoku-err); color: var(--danger); animation: shake 0.3s; }
        .sudo-cell.given { font-weight: 800; color: var(--text-color); }
        .sudo-cell.user-val { color: var(--accent); font-weight: 600; }
        
        .numpad { display: flex; justify-content: space-between; gap: 4px; width: 90vw; max-width: 350px; margin: 40px auto 0; }
        .num-btn { flex: 1; height: 48px; background: var(--glass-bg); border-radius: 10px; border: 1px solid var(--glass-border); font-size: 20px; font-weight: 600; color: var(--accent); display: flex; justify-content: center; align-items: center; cursor: pointer; transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .num-btn.active-digit { background: var(--accent); color: white; border-color: transparent; transform: scale(1.1); box-shadow: 0 4px 12px rgba(0,122,255,0.4); z-index: 10; }
        .num-btn.disabled { opacity: 0.3; background: #ccc; color: #666; pointer-events: none; border-color: transparent; transform: scale(0.95); }

        .lives-box { display: flex; align-items: center; gap: 4px; font-size: 16px; font-weight: 600; color: var(--danger); }
        @keyframes shake { 0% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } 100% { transform: translateX(0); } }
        
        .loader { border: 4px solid rgba(255,255,255,0.3); border-radius: 50%; border-top: 4px solid var(--accent); width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .checkers-board.rotated { transform: rotate(180deg); }
        .checkers-board.rotated .checker { transform: rotate(-180deg); }

        /* Стили для Башни */
        #towerCanvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
            pointer-events: auto;
            touch-action: manipulation;
            z-index: 1;
        }
        #towerTopBar {
            position: relative;
            z-index: 10;
        }
        #towerScore {
            font-feature-settings: "tnum";
        }
        #towerScore.bump { transform: scale(1.2) translateX(-50%); }
        #tower-game-background {
            background: linear-gradient(180deg, var(--bg-color) 0%, rgba(0,0,0,0.05) 100%);
        }
        [data-theme="dark"] #tower-game-background {
            background: linear-gradient(180deg, #1c1c1e 0%, rgba(255,255,255,0.05) 100%) !important;
        }
        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.5; transform: scale(0.98); }
        }


    </style>
</head>
<body>
    
    <div id="view-leaderboard" class="screen">
        <div class="header"><div class="app-title">Топы</div></div>
        
        <div class="card" onclick="openLeaderboardDetail('saper')">
            <div class="game-icon-box" style="background: linear-gradient(135deg, #007aff, #5ac8fa);"> <svg viewBox="0 0 24 24" fill="currentColor" style="width:26px;height:26px;"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M12 7a5 5 0 1 0 5 5 5 5 0 0 0-5-5z"/></svg> </div>
            <div style="flex:1;"><h3 style="margin:0; font-size:17px;">Топы Сапёра</h3></div>
            <div style="color:#8e8e93;"><svg class="icon" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></div>
        </div>
        
        <div class="card" onclick="openLeaderboardDetail('checkers')">
            <div class="game-icon-box" style="background: linear-gradient(135deg, #ff3b30, #ff9500);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle></svg> </div>
            <div style="flex:1;"><h3 style="margin:0; font-size:17px;">Топы Шашек</h3></div>
            <div style="color:#8e8e93;"><svg class="icon" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></div>
        </div>
        
        <div class="card" onclick="openLeaderboardDetail('bb')">
            <div class="game-icon-box" style="background: linear-gradient(135deg, #34c759, #30b0c7);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="9" height="9" rx="2"></rect><rect x="13" y="2" width="9" height="9" rx="2"></rect><rect x="2" y="13" width="9" height="9" rx="2"></rect></svg> </div>
            <div style="flex:1;"><h3 style="margin:0; font-size:17px;">Топы Block Blast</h3></div>
            <div style="color:#8e8e93;"><svg class="icon" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></div>
        </div>

        <div class="card" onclick="openLeaderboardDetail('sudoku')">
            <div class="game-icon-box" style="background: linear-gradient(135deg, #5856d6, #af52de);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></svg> </div>
            <div style="flex:1;"><h3 style="margin:0; font-size:17px;">Топы Судоку</h3></div>
            <div style="color:#8e8e93;"><svg class="icon" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></div>
        </div>

        <div class="card" onclick="openLeaderboardDetail('tower')">
            <div class="game-icon-box" style="background: linear-gradient(135deg, #FF2D55, #FF375F);">
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="4" y="14" width="16" height="6" rx="1"></rect>
                    <rect x="6" y="9" width="12" height="5" rx="1"></rect>
                    <rect x="8" y="4" width="8" height="5" rx="1"></rect>
                </svg>
            </div>
            <div style="flex:1;"><h3 style="margin:0; font-size:17px;">Топы Башни</h3></div>
            <div style="color:#8e8e93;"><svg class="icon" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></div>
        </div>
    </div>

    <div id="view-leaderboard-detail" class="screen" style="z-index: 200; background: var(--bg-color);">
        <div class="header">
            <div class="back-btn" onclick="closeLeaderboardDetail()" style="font-size: 17px;"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>Назад</div>
        </div>
        
        <div class="lb-title-lg" id="lbGameTitle">Title</div>
        <div class="lb-selector" id="lbSelector" onclick="toggleDropdown()">
            <span id="lbCurrentCat">Category</span>
            <svg class="icon" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"></polyline></svg>
        </div>
        <div class="dropdown-menu" id="dropdownMenu"></div>
        <div class="dropdown-catcher" id="dropdownCatcher" onclick="toggleDropdown()"></div>
        
        <div class="lb-list" id="lbList"></div>
    </div>
    
    <div class="lb-sticky-user" id="lbStickyUser">
        <div class="lb-rank" id="stickyRank">#</div>
        <img src="" class="lb-avatar" id="stickyAvatar">
        <div class="lb-info"><div class="lb-name" id="stickyName">Name</div></div>
        <div class="lb-val" id="stickyVal">0</div>
    </div>

    <div id="view-games" class="screen active"> 
        <div class="header"> <div class="app-title">Игры</div> </div> 
        
        <div class="card" onclick="openGameModal('saper')"> <div class="game-icon-box" style="background: linear-gradient(135deg, #007aff, #5ac8fa);"> <svg viewBox="0 0 24 24" fill="currentColor" style="width:26px;height:26px;"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M12 7a5 5 0 1 0 5 5 5 5 0 0 0-5-5z"/></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Сапёр</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
        <div class="card" onclick="openGameModal('checkers')"> <div class="game-icon-box" style="background: linear-gradient(135deg, #ff3b30, #ff9500);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Шашки</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
        <div class="card" onclick="startBlockBlastCheck()"> <div class="game-icon-box" style="background: linear-gradient(135deg, #34c759, #30b0c7);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="9" height="9" rx="2"></rect><rect x="13" y="2" width="9" height="9" rx="2"></rect><rect x="2" y="13" width="9" height="9" rx="2"></rect></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Block Blast</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
        <div class="card" onclick="startSudokuCheck()"> <div class="game-icon-box" style="background: linear-gradient(135deg, #5856d6, #af52de);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Судоку</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
        <div class="card" onclick="openGameModal('tower')">
            <div class="game-icon-box" style="background: linear-gradient(135deg, #FF2D55, #FF375F);">
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="4" y="14" width="16" height="6" rx="1"></rect>
                    <rect x="6" y="9" width="12" height="5" rx="1"></rect>
                    <rect x="8" y="4" width="8" height="5" rx="1"></rect>
                </svg>
            </div>
            <div style="flex:1;">
                <h3 style="margin:0; font-size:17px;">Башня</h3>
            </div>
            <div style="color:var(--accent); font-weight:600;">Play</div>
        </div>
    </div>

    <div id="view-profile" class="screen"> 
        <div class="header"><div class="app-title">Профиль</div></div> 
        <div style="display:flex; flex-direction:column; align-items:center;"> 
            <img id="user-avatar" src="" alt="" class="avatar"> 
            <h2 id="user-name" style="margin:0;">Loading...</h2> 
            <p id="user-id" style="color:#8e8e93; margin:5px 0 20px;">@username</p> 
            
            <div class="settings-group">
                <div class="settings-row">
                    <div class="settings-label">
                        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                        Тема
                    </div>
                    <div class="theme-switch" id="themeToggle" onclick="toggleTheme()"> 
                        <div class="theme-icons"> 
                            <svg class="icon icon-sm" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"></circle><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"></path></svg> 
                            <svg class="icon icon-sm" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg> 
                        </div> 
                        <div class="switch-circle"></div> 
                    </div>
                </div>
                
                <div class="settings-row">
                    <div class="settings-label">
                        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>
                        Упрощенная графика
                    </div>
                    <div class="theme-switch" id="liteToggle" onclick="toggleLiteMode()"> 
                        <div class="toggle-labels"><div>OFF</div><div>ON</div></div>
                        <div class="switch-circle"></div> 
                    </div>
                </div>
            </div>

            <div style="width:100%; display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:10px; margin-top: 10px;"> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-saper-games" style="font-size:20px; font-weight:800; color:var(--accent);">0</div> <div style="font-size:12px; color:#8e8e93;">Сапёр Игр</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-saper-best" style="font-size:20px; font-weight:800; color:var(--success);">--</div> <div style="font-size:12px; color:#8e8e93;">Сапёр Рекорд</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-checkers-games" style="font-size:20px; font-weight:800; color:#ff3b30;">0</div> <div style="font-size:12px; color:#8e8e93;">Шашки Игр</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-checkers-wins" style="font-size:20px; font-weight:800; color:#ff9500;">0</div> <div style="font-size:12px; color:#8e8e93;">Побед над Ботом</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-bb-games" style="font-size:20px; font-weight:800; color:#34c759;">0</div> <div style="font-size:12px; color:#8e8e93;">Block Игр</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-bb-best" style="font-size:20px; font-weight:800; color:#30b0c7;">0</div> <div style="font-size:12px; color:#8e8e93;">Block Рекорд</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center; grid-column: span 2;"> <div id="stat-sudoku-wins" style="font-size:20px; font-weight:800; color:#5856d6;">0</div> <div style="font-size:12px; color:#8e8e93;">Судоку Побед</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;">
                    <div id="stat-tower-best" style="font-size:20px; font-weight:800; color:#FF2D55;">0</div>
                    <div style="font-size:12px; color:#8e8e93;">Башня Рекорд</div>
                </div>
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;">
                    <div id="stat-tower-combo" style="font-size:20px; font-weight:800; color:#FF375F;">0</div>
                    <div style="font-size:12px; color:#8e8e93;">Чистая серия</div>
                </div>
            </div>
        </div> 
    </div>
    
    <div class="tab-bar"> 
        <div class="tab-item" onclick="switchTab('leaderboard', this)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h8v15H8z"/><path d="M2 13h6v8H2z"/><path d="M16 13h6v8H16z"/></svg>
            Топы
        </div>
        <div class="tab-item active" onclick="switchTab('games', this)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="6" width="20" height="12" rx="2"/><path d="M6 12h.01M18 12h.01M10 12h4"/></svg>
            Игры
        </div> 
        <div class="tab-item" onclick="switchTab('profile', this)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
            Профиль
        </div> 
    </div>

    <div class="modal-overlay" id="dropdownOverlay" onclick="toggleDropdown()"></div>
    
    <div id="saper-screen" class="game-overlay"> 
        <div class="game-top-bar"> 
            <div class="back-btn" onclick="closeGame('saper')"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>Меню</div> 
            <div style="display:flex; gap:15px; font-weight:600; font-size:18px;"> 
                <span style="display:flex; align-items:center; gap:4px;"><span id="saperFlags">0</span> <svg class="saper-icon" viewBox="0 0 24 24" style="fill:#ff3b30; stroke:none;"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/></svg></span> 
                <span style="display:flex; align-items:center; gap:4px;"><span id="saperTimer">000.00</span> <svg class="saper-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="color:var(--text-color);"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg></span> 
            </div> 
        </div> 
        <div class="game-area"><div class="grid" id="saperGrid"></div></div> 
        <div class="bottom-controls">
            <div class="segment-control" style="margin: 0; min-width: 220px;">
                <div class="segment-glider" id="saperGlider"></div>
                <div class="segment-item active" onclick="setSaperMode('dig', this, 0)">Копать</div>
                <div class="segment-item" onclick="setSaperMode('flag', this, 1)">Флаг</div>
            </div>
        </div> 
    </div>
    
    <div id="checkers-screen" class="game-overlay"> <div class="game-top-bar"> <div class="back-btn" onclick="closeGame('checkers')"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>Меню</div> <div style="font-weight:700; font-size:18px;" id="checkersStatus">Ход Белых</div> </div> <div class="game-area"> <div class="checkers-wrapper"><div id="checkersBoard" class="checkers-board"></div></div> </div> </div>
    <div id="bb-screen" class="game-overlay"> <div class="game-top-bar"> <div class="back-btn" onclick="closeGame('bb')"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>Меню</div> <div style="font-weight:700; font-size:18px;">Best: <span id="bbBestScore">0</span></div> </div> <div class="bb-game-container"> <div class="bb-score-box" id="bbScore">0</div> <div id="bbGrid" class="bb-grid"></div> <div class="bb-footer"> <div class="bb-shape-container" id="shape0"></div> <div class="bb-shape-container" id="shape1"></div> <div class="bb-shape-container" id="shape2"></div> </div> </div> </div>
    
    <div id="sudoku-screen" class="game-overlay"> 
        <div class="game-top-bar"> 
            <div class="back-btn" onclick="closeGame('sudoku')"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>Меню</div> 
            <div class="lives-box">Ошибки: <span id="sudokuLives">0/3</span></div>
        </div> 
        <div class="game-area" style="justify-content: flex-start; padding-top: 20px;">
            <div id="sudokuBoard" class="sudo-board"></div>
            <div class="numpad" id="sudokuNumpad">
                <div class="num-btn" id="nb1" onclick="activateDigit(1, this)">1</div>
                <div class="num-btn" id="nb2" onclick="activateDigit(2, this)">2</div>
                <div class="num-btn" id="nb3" onclick="activateDigit(3, this)">3</div>
                <div class="num-btn" id="nb4" onclick="activateDigit(4, this)">4</div>
                <div class="num-btn" id="nb5" onclick="activateDigit(5, this)">5</div>
                <div class="num-btn" id="nb6" onclick="activateDigit(6, this)">6</div>
                <div class="num-btn" id="nb7" onclick="activateDigit(7, this)">7</div>
                <div class="num-btn" id="nb8" onclick="activateDigit(8, this)">8</div>
                <div class="num-btn" id="nb9" onclick="activateDigit(9, this)">9</div>
            </div>
        </div> 
    </div>

    <div class="modal-overlay" id="modalSaper"><div class="modal"><h2>Сапёр</h2><div class="diff-grid"><div class="diff-btn" onclick="setSaperDiff(6,6,5,this)">6x6</div><div class="diff-btn selected" onclick="setSaperDiff(8,8,10,this)">8x8</div><div class="diff-btn" onclick="setSaperDiff(10,10,15,this)">10x10</div><div class="diff-btn" onclick="setSaperDiff(15,15,30,this)">15x15</div></div><button class="btn-main" onclick="launchSaper()">Начать</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="document.getElementById('modalSaper').classList.remove('visible')">Отмена</button></div></div>
    
    <div class="modal-overlay" id="modalCheckers">
        <div class="modal">
            <h2>Шашки</h2>
            
            <div class="segment-control" style="margin-bottom: 15px;">
                <div class="segment-glider" id="checkersMainGlider"></div>
                <div class="segment-item active" onclick="setCheckersMainMode('offline', this, 0)">Offline</div>
                <div class="segment-item" onclick="setCheckersMainMode('online', this, 1)">Online</div>
            </div>

            <div id="ch-offline-panel" class="panel-visible">
                <p style="color:#8e8e93; margin-bottom:15px; margin-top:0;">Выберите режим игры</p>
                <div class="segment-control">
                    <div class="segment-glider" id="checkersGlider"></div>
                    <div class="segment-item active" onclick="setCheckersMode(false, this, 0)">2 Игрока</div>
                    <div class="segment-item" onclick="setCheckersMode(true, this, 1)">С Роботом</div>
                </div>
                <button class="btn-main" onclick="launchCheckers()">Играть</button>
            </div>

            <div id="ch-online-panel" class="panel-hidden">
                <button class="btn-main" style="margin-top:0; margin-bottom:8px; background:linear-gradient(135deg, #007aff, #00c6ff); padding: 12px;" onclick="joinGame()">Найти соперника</button>
                <div class="input-group">
                    <input type="text" id="joinCodeInput" class="input-glass" placeholder="Код..." maxlength="5">
                    <button class="btn-secondary" onclick="joinGameByCode()">Войти</button>
                </div>
                <button class="btn-secondary" style="width:100%; margin-top:8px; color:#8e8e93; padding: 10px;" onclick="createGame()">Создать комнату</button>
            </div>

            <button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="document.getElementById('modalCheckers').classList.remove('visible')">Отмена</button>
        </div>
    </div>
    
    <div class="modal-overlay" id="modalWaitOpponent"><div class="modal"><h2>Ожидание...</h2><p style="color:#8e8e93;">Код комнаты:</p><div style="font-size:32px; font-weight:800; letter-spacing:5px; margin:10px 0; color:var(--accent);" id="displayRoomCode">-----</div><p style="font-size:14px; color:#8e8e93;">Передай этот код другу</p><button style="margin-top:10px; background:none; border:none; color:#ff3b30; font-size:16px;" onclick="cancelOnlineWait()">Отмена</button></div></div>
    
    <div class="modal-overlay" id="modalBBResume"><div class="modal"><h2>Block Blast</h2><p style="color:#8e8e93;">Найдена незаконченная игра</p><button class="btn-main" onclick="resumeBB()">Продолжить</button><button class="btn-main" style="background:var(--danger); margin-top:10px;" onclick="newGameBB()">Новая игра</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="document.getElementById('modalBBResume').classList.remove('visible')">Отмена</button></div></div>
    <div class="modal-overlay" id="modalResult"><div class="modal" id="modalResultContent"><h2 id="resTitle">Победа!</h2><p id="resText">Текст</p><button class="btn-main" id="resBtn" onclick="closeResult()">Закрыть</button></div></div>
    <div class="modal-overlay" id="modalBBGameOver"><div class="modal" id="bbGameOverContent"></div></div>
    
    <div class="modal-overlay" id="modalLoading"><div class="modal" style="display:flex; flex-direction:column; align-items:center;"><div class="loader"></div><h3>Создание комнаты...</h3></div></div>

    <div class="modal-overlay" id="modalSudoku"><div class="modal"><h2>Судоку</h2><p style="color:#8e8e93; margin-bottom:20px;">Выберите сложность</p>
        <div class="segment-control vertical" style="height: 180px;">
            <div class="segment-glider" id="sudokuGlider" style="transform: translateY(100%);"></div>
            <div class="segment-item" onclick="selectSudokuDiff(30, this, 0)">Легко (+1)</div>
            <div class="segment-item active" onclick="selectSudokuDiff(40, this, 1)">Средне (+2)</div>
            <div class="segment-item" onclick="selectSudokuDiff(50, this, 2)">Сложно (+3)</div>
        </div>
        <button class="btn-main" onclick="startSudoku()">Играть</button>
        <button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="document.getElementById('modalSudoku').classList.remove('visible')">Отмена</button>
    </div></div>
    
    <div class="modal-overlay" id="modalSudokuResume"><div class="modal"><h2>Судоку</h2><p style="color:#8e8e93;">Найдена незаконченная игра</p><button class="btn-main" onclick="resumeSudoku()">Продолжить</button><button class="btn-main" style="background:var(--danger); margin-top:10px;" onclick="document.getElementById('modalSudokuResume').classList.remove('visible'); document.getElementById('modalSudoku').classList.add('visible');">Новая игра</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="document.getElementById('modalSudokuResume').classList.remove('visible')">Отмена</button></div></div>

    <div id="tower-screen" class="game-overlay">
        <div class="game-top-bar" id="towerTopBar">
            <div class="back-btn" onclick="closeGame('tower')">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>Меню
            </div>
            <div style="font-weight:700; font-size:18px;">Best: <span id="towerBestScore">0</span></div>
        </div>
        
        <div id="tower-game-background" style="position:absolute; top:0; left:0; width:100%; height:100%; background:linear-gradient(180deg, var(--bg-color) 0%, rgba(0,0,0,0.05) 100%); pointer-events:none; z-index:0;"></div>
        
        <canvas id="towerCanvas"></canvas>
        
        <div id="tower-ui-layer" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:2;">
            <div id="towerScore" style="position:absolute; top:12%; left:0; width:100%; text-align:center; font-size:80px; font-weight:800; color:var(--accent); text-shadow:0 4px 20px rgba(0,0,0,0.1); transition:transform 0.15s cubic-bezier(0.175,0.885,0.32,1.275), color 0.5s ease; pointer-events:none;">0</div>
            <div id="towerStartMsg" style="position:absolute; bottom:15%; width:100%; text-align:center; font-size:17px; font-weight:600; color:var(--accent); opacity:0.8; animation:pulse 2s infinite; pointer-events:none;">Нажми, чтобы начать</div>
        </div>
    </div>

    <div class="modal-overlay" id="modalTowerGameOver">
        <div class="modal" id="towerGameOverContent"></div>
    </div>

        <script>
        const tg = window.Telegram.WebApp; 
        tg.expand();
        
        if (tg.isVerticalSwipesEnabled !== undefined) {
            tg.isVerticalSwipesEnabled = false;
        }
        tg.enableClosingConfirmation();

        if (tg.requestFullscreen) {
            tg.requestFullscreen();
        }

        let isDark = tg.colorScheme === 'dark';
        let isLiteMode = localStorage.getItem('lite_mode') === 'true'; 
        
        const API_BASE_URL = 'https://glass-api-kh3s.onrender.com';
        
        // --- SOCKET.IO INIT ---
        const socket = io(API_BASE_URL);
        
        let onlineRoomCode = null;
        let onlineMyColor = null; // Для шашек
        let isOnlineGame = false;
        
        // --- ASSETS ---
        const ICON_MINE = `<svg class="saper-mine" viewBox="0 0 24 24"><path d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2zm0 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm0-13a5 5 0 1 1 0 10 5 5 0 0 1 0-10z"/></svg>`;
        const ICON_FLAG = `<svg class="saper-flag" viewBox="0 0 24 24" style="fill:#ff3b30; stroke:none;"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/></svg>`;
        const ICON_CROWN = `<svg class="crown-icon" viewBox="0 0 24 24"><path d="M5 16L3 5l5.5 5L12 4l3.5 6L21 5l-2 11H5zm14 3c0 .6-.4 1-1 1H6c-.6 0-1-.4-1-1v-1h14v1z"/></svg>`;
        const COLOR_MAP = { 'bb-c-1':'#ff3b30', 'bb-c-2':'#ff9500', 'bb-c-3':'#ffcc00', 'bb-c-4':'#34c759', 'bb-c-5':'#007aff', 'bb-c-6':'#5856d6', 'bb-c-7':'#af52de' };

        function initApp() {
            applyTheme();
            applyLiteMode();
            loadProfile();
            setTimeout(syncLocalStatsToServer, 2000);
            
            // --- SOCKET LISTENERS ---

            // 1. Шашки (Старое)
            socket.on('game_created', (data) => {
                document.getElementById('modalLoading').classList.remove('visible');
                onlineRoomCode = data.roomCode;
                onlineMyColor = data.color;
                document.getElementById('displayRoomCode').innerText = onlineRoomCode;
                document.getElementById('modalWaitOpponent').classList.add('visible');
            });
            
            socket.on('start_game', (data) => {
                document.getElementById('modalWaitOpponent').classList.remove('visible');
                document.getElementById('modalCheckers').classList.remove('visible');
                if (data.color) onlineMyColor = data.color;
                isOnlineGame = true;
                isPvE = false; // FIXED v34.1: Сброс режима бота при онлайн-игре
                document.getElementById('checkers-screen').classList.add('visible');
                initCheckers(); 
                const boardEl = document.getElementById('checkersBoard');
                boardEl.classList.remove('rotated'); 
                if (onlineMyColor === 'black') boardEl.classList.add('rotated');
                tg.HapticFeedback.notificationOccurred('success');
                showResult(`Игра началась!`, `Ваш цвет: ${onlineMyColor === 'white' ? 'Белые' : 'Чёрные'}\nСоперник: ${data.opponent.name}`, "Погнали", () => { document.getElementById('modalResult').classList.remove('visible'); });
            });
            
            socket.on('opponent_move', (move) => { executeMove(move, false); });
            socket.on('opponent_disconnected', () => { showResult("Победа!", "Соперник отключился", "В меню", () => { closeResult(); closeGame('checkers'); }); });
            
            // Общие ошибки
            socket.on('error_message', (msg) => { alert(msg); document.getElementById('modalLoading').classList.remove('visible'); });
        }

        function applyTheme() { document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light'); if(tg.headerColor) tg.headerColor = isDark ? '#000000' : '#f2f2f7'; if(tg.backgroundColor) tg.backgroundColor = isDark ? '#000000' : '#f2f2f7'; }
        function toggleTheme() { isDark = !isDark; applyTheme(); tg.HapticFeedback.selectionChanged(); }
        
        function applyLiteMode() { 
            const el = document.getElementById('liteToggle');
            if(isLiteMode) {
                el.classList.add('active');
                document.body.classList.add('lite-mode');
            } else {
                el.classList.remove('active');
                document.body.classList.remove('lite-mode');
            }
        }
        function toggleLiteMode() {
            isLiteMode = !isLiteMode;
            localStorage.setItem('lite_mode', isLiteMode);
            applyLiteMode();
            tg.HapticFeedback.selectionChanged();
        }

        function switchTab(t, el) { 
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active')); 
            document.querySelectorAll('.tab-item').forEach(b => b.classList.remove('active')); 
            if(t==='games') document.getElementById('view-games').classList.add('active'); 
            else if(t==='leaderboard') document.getElementById('view-leaderboard').classList.add('active'); 
            else { document.getElementById('view-profile').classList.add('active'); loadProfile(); } 
            if(el) el.classList.add('active'); tg.HapticFeedback.selectionChanged(); 
        }

        function openGameModal(game) { 
            if(game==='saper') document.getElementById('modalSaper').classList.add('visible'); 
            if(game==='checkers') document.getElementById('modalCheckers').classList.add('visible'); 
            if(game==='tower') { document.getElementById('tower-screen').classList.add('visible'); initTower(); }
            tg.HapticFeedback.impactOccurred('light'); 
        }
        function closeGame(game) { 
            document.getElementById(game+'-screen').classList.remove('visible'); 
            if(game==='saper') clearInterval(sTimerInt); 
            if(game==='bb') saveBBState(); 
            if(game==='sudoku') saveSudokuState();
            if(game==='tower') { 
                if(twAnimationFrameId) cancelAnimationFrame(twAnimationFrameId); 
                twAnimationFrameId = null;
                twState='start'; 
            }
            // FIXED v34.1: Сброс флагов при закрытии игры
            if(game==='checkers') {
                isOnlineGame = false;
                isPvE = false;
                onlineRoomCode = null;
                onlineMyColor = null;
            }
        }
        function closeResult() { document.getElementById('modalResult').classList.remove('visible'); document.getElementById('modalBBGameOver').classList.remove('visible'); document.getElementById('modalTowerGameOver').classList.remove('visible'); document.getElementById('modalResultContent').classList.remove('rotate-180'); }
        
        function loadProfile() { 
            const user = tg.initDataUnsafe.user || { first_name: "Player", username: "user" }; 
            document.getElementById('user-name').innerText = user.first_name; 
            document.getElementById('user-id').innerText = user.username ? '@'+user.username : ''; 
            const ava = document.getElementById('user-avatar'); 
            if(user.photo_url) ava.src = user.photo_url; 
            else ava.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%23007aff'/%3E%3Ctext x='50' y='65' font-size='50' text-anchor='middle' fill='white'%3E" + (user.first_name[0]||'U') + "%3C/text%3E%3C/svg%3E"; 
            
            document.getElementById('stat-saper-games').innerText = localStorage.getItem('saper_total') || 0; 
            document.getElementById('stat-saper-best').innerText = localStorage.getItem('saper_best_8') || '--'; 
            document.getElementById('stat-checkers-games').innerText = localStorage.getItem('checkers_total') || 0; 
            document.getElementById('stat-checkers-wins').innerText = localStorage.getItem('checkers_wins_pve') || 0; 
            document.getElementById('stat-bb-games').innerText = localStorage.getItem('bb_total_games') || 0; 
            document.getElementById('stat-bb-best').innerText = localStorage.getItem('bb_best_score') || 0; 
            document.getElementById('stat-sudoku-wins').innerText = localStorage.getItem('sudoku_wins') || 0;
            document.getElementById('stat-tower-best').innerText = localStorage.getItem('tower_best') || 0;
            document.getElementById('stat-tower-combo').innerText = localStorage.getItem('tower_combo') || 0;
            if(document.getElementById('bbBestScore')) document.getElementById('bbBestScore').innerText = localStorage.getItem('bb_best_score') || 0; 
        }
        
        function saveStatToCloud(key, value) { localStorage.setItem(key, value); loadProfile(); }
        async function sendStatToBackend(game_type, score) {
            const user = tg.initDataUnsafe.user; if (!user) return;
            const url = `${API_BASE_URL}/save-stat`;
            const payload = { user_id: user.id.toString(), username: (user.first_name + ' ' + (user.last_name||'')).trim(), photo_url: user.photo_url || "", game_type: game_type, score: score };
            try { await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); } catch (error) { console.error(error); }
        }
        function syncLocalStatsToServer() {
            const bbBest = parseInt(localStorage.getItem('bb_best_score') || 0); if(bbBest > 0) sendStatToBackend('bb_best_score', bbBest);
            const bbGames = parseInt(localStorage.getItem('bb_total_games') || 0); if(bbGames > 0) sendStatToBackend('bb_total_games', bbGames);
            const sapWins = parseInt(localStorage.getItem('saper_wins') || 0); if(sapWins > 0) sendStatToBackend('saper_wins', sapWins);
            const chTotal = parseInt(localStorage.getItem('checkers_total') || 0); if(chTotal > 0) sendStatToBackend('checkers_total', chTotal);
            const chWins = parseInt(localStorage.getItem('checkers_wins_pve') || 0); if(chWins > 0) sendStatToBackend('checkers_wins_pve', chWins);
            const twBest = parseInt(localStorage.getItem('tower_best') || 0); if(twBest > 0) sendStatToBackend('tower_best', twBest);
            const twCombo = parseInt(localStorage.getItem('tower_combo') || 0); if(twCombo > 0) sendStatToBackend('tower_combo', twCombo);
        }

        // --- LEADERBOARD LOGIC ---
        let currentLbGame = 'saper';
        let currentLbCat = { id: 'saper_wins', name: 'Количество побед' };
        const SAPER_CATS = [{ id: 'saper_wins', name: 'Количество побед' },{ id: 'saper_best_6', name: 'Лучшее время 6x6', isTime: true },{ id: 'saper_best_8', name: 'Лучшее время 8x8', isTime: true },{ id: 'saper_best_10', name: 'Лучшее время 10x10', isTime: true },{ id: 'saper_best_15', name: 'Лучшее время 15x15', isTime: true }];
        const CHECKERS_CATS = [{ id: 'checkers_total', name: 'Всего игр' },{ id: 'checkers_wins_pve', name: 'Побед над роботом' }];
        const BB_CATS = [{ id: 'bb_best_score', name: 'Рекорд очков' },{ id: 'bb_total_games', name: 'Всего игр' }];
        const SUDOKU_CATS = [{ id: 'sudoku_wins', name: 'Количество побед' }];
        const TOWER_CATS = [{ id: 'tower_best', name: 'Высота башни' },{ id: 'tower_combo', name: 'Чистая серия' }];

        function openLeaderboardDetail(game) {
            currentLbGame = game;
            if(game === 'saper') { document.getElementById('lbGameTitle').innerText = 'Топы Сапёра'; loadLeaderboardData(SAPER_CATS[0]); } 
            else if (game === 'checkers') { document.getElementById('lbGameTitle').innerText = 'Топы Шашек'; loadLeaderboardData(CHECKERS_CATS[0]); } 
            else if (game === 'bb') { document.getElementById('lbGameTitle').innerText = 'Топы Block Blast'; loadLeaderboardData(BB_CATS[0]); } 
            else if (game === 'sudoku') { document.getElementById('lbGameTitle').innerText = 'Топы Судоку'; loadLeaderboardData(SUDOKU_CATS[0]); }
            else if (game === 'tower') { document.getElementById('lbGameTitle').innerText = 'Топы Башни'; loadLeaderboardData(TOWER_CATS[0]); }
            document.getElementById('view-leaderboard-detail').classList.add('active');
        }
        function closeLeaderboardDetail() { document.getElementById('view-leaderboard-detail').classList.remove('active'); document.getElementById('lbStickyUser').classList.remove('visible'); const menu = document.getElementById('dropdownMenu'); menu.classList.remove('active'); document.getElementById('dropdownCatcher').classList.remove('active'); }
        function toggleDropdown() {
            const menu = document.getElementById('dropdownMenu'); const catcher = document.getElementById('dropdownCatcher'); const selector = document.getElementById('lbSelector');
            const rect = selector.getBoundingClientRect(); menu.style.top = (rect.bottom + 5) + 'px';
            if(!menu.classList.contains('active')) {
                menu.innerHTML = ''; let cats = [];
                if(currentLbGame === 'saper') cats = SAPER_CATS; else if(currentLbGame === 'checkers') cats = CHECKERS_CATS; else if(currentLbGame === 'bb') cats = BB_CATS; else if(currentLbGame === 'sudoku') cats = SUDOKU_CATS; else if(currentLbGame === 'tower') cats = TOWER_CATS;
                cats.forEach(cat => { const el = document.createElement('div'); el.className = `dd-item ${cat.id === currentLbCat.id ? 'selected' : ''}`; el.innerText = cat.name; el.onclick = () => { loadLeaderboardData(cat); toggleDropdown(); }; menu.appendChild(el); });
                menu.classList.add('active'); catcher.classList.add('active'); tg.HapticFeedback.selectionChanged();
            } else { menu.classList.remove('active'); catcher.classList.remove('active'); }
        }
        let lbObserver = null;
        async function loadLeaderboardData(category) {
            currentLbCat = category; document.getElementById('lbCurrentCat').innerText = category.name; const listEl = document.getElementById('lbList'); const stickyEl = document.getElementById('lbStickyUser'); listEl.innerHTML = '<div style="padding:20px; text-align:center; color:#8e8e93;">Загрузка...</div>'; stickyEl.classList.remove('visible');
            try {
                const url = `${API_BASE_URL}/leaderboard?game=${currentLbGame}&category=${category.id}`;
                const response = await fetch(url); const data = await response.json();
                const user = tg.initDataUnsafe.user || { id: 0, first_name: 'Guest' };
                const userValRaw = localStorage.getItem(category.id); let userVal = parseInt(userValRaw); let hasStats = true;
                if (isNaN(userVal) || userValRaw === '--' || userValRaw === null) { userVal = category.isTime ? 999999 : 0; hasStats = false; } else { if (category.isTime && userVal === 999999) hasStats = false; if (!category.isTime && userVal === 0) hasStats = false; }
                const displayList = data.map((item) => ({ user_id: item.user_id, username: item.username, photo_url: item.photo_url, score: item.score, isMe: item.user_id.toString() === user.id.toString() }));
                let myRankRow = displayList.find(u => u.isMe);
                if (hasStats && !myRankRow) { displayList.push({ user_id: user.id.toString(), username: (user.first_name + ' ' + (user.last_name || '')).trim(), photo_url: user.photo_url, score: userVal, isMe: true }); if (category.isTime) displayList.sort((a, b) => a.score - b.score); else displayList.sort((a, b) => b.score - a.score); } 
                else if (hasStats && myRankRow) { if ((category.isTime && userVal < myRankRow.score) || (!category.isTime && userVal > myRankRow.score)) { myRankRow.score = userVal; if (category.isTime) displayList.sort((a, b) => a.score - b.score); else displayList.sort((a, b) => b.score - a.score); } }
                listEl.innerHTML = ''; const finalDisplayList = displayList.slice(0, 100); const meInList = finalDisplayList.find(u => u.isMe); const myRank = meInList ? finalDisplayList.indexOf(meInList) + 1 : 0;
                document.getElementById('stickyName').innerText = (user.first_name + ' ' + (user.last_name || '')).trim() + " (Вы)";
                if(user.photo_url) document.getElementById('stickyAvatar').src = user.photo_url; else document.getElementById('stickyAvatar').style.background = '#ddd';
                if(hasStats && myRank > 0) { document.getElementById('stickyRank').innerText = myRank; document.getElementById('stickyVal').innerText = category.isTime ? (userVal === 999999 ? '--' : userVal + 'с') : userVal; } else { document.getElementById('stickyRank').innerText = "- -"; document.getElementById('stickyVal').innerText = "Нет данных"; }
                if(hasStats && myRank > 0) { lbObserver = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) stickyEl.classList.remove('visible'); else if(document.getElementById('view-leaderboard-detail').classList.contains('active')) stickyEl.classList.add('visible'); }); }, { threshold: 0.1 }); } else { if(document.getElementById('view-leaderboard-detail').classList.contains('active')) stickyEl.classList.add('visible'); }
                finalDisplayList.forEach((u, index) => {
                    const rank = index + 1; let medal = ''; if(rank === 1) medal = `<svg class="lb-medal" viewBox="0 0 24 24" style="fill:var(--rank-gold); stroke:none;"><circle cx="12" cy="12" r="10"/></svg>`; if(rank === 2) medal = `<svg class="lb-medal" viewBox="0 0 24 24" style="fill:var(--rank-silver); stroke:none;"><circle cx="12" cy="12" r="10"/></svg>`; if(rank === 3) medal = `<svg class="lb-medal" viewBox="0 0 24 24" style="fill:var(--rank-bronze); stroke:none;"><circle cx="12" cy="12" r="10"/></svg>`;
                    let displayVal = u.score; if(category.isTime) displayVal = (u.score === 999999) ? '--' : u.score + 'с';
                    const item = document.createElement('div'); item.className = `lb-item rank-${rank}`; if(u.isMe) { item.style.border = '1px solid var(--accent)'; if(lbObserver) lbObserver.observe(item); }
                    let avatarHtml = u.photo_url && u.photo_url.startsWith('http') ? `<img src="${u.photo_url}" class="lb-avatar">` : `<div class="lb-avatar" style="background:#ddd"></div>`;
                    item.innerHTML = `<div class="lb-rank">${rank}</div>${medal}${avatarHtml}<div class="lb-info"><div class="lb-name" style="${u.isMe ? 'color:var(--accent)' : ''}">${u.username} ${u.isMe ? '(Вы)' : ''}</div></div><div class="lb-val">${displayVal}</div>`;
                    listEl.appendChild(item);
                });
            } catch (error) { listEl.innerHTML = `<div style="padding:20px; text-align:center; color:var(--danger);">Ошибка сети.</div>`; }
        }

        /* --- SAPER WITH MS TIMER --- */
        let sRows=8, sCols=8, sMines=10, sMode='dig', sGrid=[], sTimer=0, sTimerInt, sFlags=0, sFirst=true, sOver=false, sStartTime=0;
        function setSaperDiff(r,c,m,btn) { sRows=r; sCols=c; sMines=m; document.querySelectorAll('#modalSaper .diff-btn').forEach(b=>b.classList.remove('selected')); btn.classList.add('selected'); tg.HapticFeedback.selectionChanged(); }
        function launchSaper() { document.getElementById('modalSaper').classList.remove('visible'); document.getElementById('saper-screen').classList.add('visible'); setSaperMode('dig', document.querySelector('#saperGlider').nextElementSibling, 0); initSaper(); }
        function setSaperMode(m, btn, index) { sMode = m; const glider = document.getElementById('saperGlider'); if(glider) glider.style.transform = `translateX(${index * 100}%)`; const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active'); tg.HapticFeedback.selectionChanged(); }
        function initSaper() { sGrid=[]; sOver=false; sFirst=true; sFlags=sMines; sTimer=0; document.getElementById('saperFlags').innerText=sFlags; document.getElementById('saperTimer').innerText='000.00'; clearInterval(sTimerInt); const el=document.getElementById('saperGrid'); el.innerHTML=''; el.style.gridTemplateColumns=`repeat(${sCols}, 38px)`; const w=window.innerWidth-20, rw=sCols*43; el.style.transform=rw>w?`scale(${w/rw})`:`scale(1)`; for(let r=0;r<sRows;r++){const row=[];for(let c=0;c<sCols;c++){const cell=document.createElement('div');cell.className='cell';cell.onclick=()=>onSaperClick(r,c);cell.oncontextmenu=(e)=>{e.preventDefault();onSaperFlag(r,c);};let pt;cell.addEventListener('touchstart',()=>{if(!sOver)pt=setTimeout(()=>{onSaperFlag(r,c);tg.HapticFeedback.impactOccurred('medium');},500);});cell.addEventListener('touchend',()=>clearTimeout(pt));el.appendChild(cell);row.push({isMine:false,revealed:false,flagged:false,neighbor:0,el:cell});}sGrid.push(row);} }
        function onSaperClick(r,c){const cell=sGrid[r][c];if(sOver||cell.revealed)return;if(sMode==='flag'){onSaperFlag(r,c);return;}if(cell.flagged)return;if(sFirst){sFirst=false;placeMinesSafe(r,c); sStartTime = Date.now(); sTimerInt=setInterval(()=>{ let now = Date.now(); let diff = (now - sStartTime)/1000; sTimer = diff; document.getElementById('saperTimer').innerText= diff.toFixed(2);},30);}if(cell.isMine)loseSaper(cell);else{revealSaper(r,c);checkSaperWin();tg.HapticFeedback.selectionChanged();}}
        function onSaperFlag(r,c){const cell=sGrid[r][c];if(sOver||cell.revealed)return;if(!cell.flagged&&sFlags>0){cell.flagged=true;cell.el.innerHTML=ICON_FLAG;sFlags--;}else if(cell.flagged){cell.flagged=false;cell.el.innerHTML='';sFlags++;}document.getElementById('saperFlags').innerText=sFlags;}
        function placeMinesSafe(exR,exC){let placed=0;while(placed<sMines){let rr=Math.floor(Math.random()*sRows),cc=Math.floor(Math.random()*sCols);if(Math.abs(rr-exR)<=1&&Math.abs(cc-exC)<=1)continue;if(!sGrid[rr][cc].isMine){sGrid[rr][cc].isMine=true;placed++;}}for(let r=0;r<sRows;r++)for(let c=0;c<sCols;c++){if(sGrid[r][c].isMine)continue;let cnt=0;for(let i=-1;i<=1;i++)for(let j=-1;j<=1;j++)if(r+i>=0&&r+i<sRows&&c+j>=0&&c+j<sCols&&sGrid[r+i][c+j].isMine)cnt++;sGrid[r][c].neighbor=cnt;}}
        function revealSaper(r,c){const cell=sGrid[r][c];if(cell.revealed||cell.flagged)return;cell.revealed=true;cell.el.classList.add('revealed');if(cell.neighbor>0){cell.el.innerText=cell.neighbor;cell.el.classList.add('c-'+cell.neighbor);}else{for(let i=-1;i<=1;i++)for(let j=-1;j<=1;j++)if(r+i>=0&&r+i<sRows&&c+j>=0&&c+j<sCols)revealSaper(r+i,c+j);}}
        function loseSaper(cell){sOver=true;clearInterval(sTimerInt);tg.HapticFeedback.notificationOccurred('error');cell.el.style.background='var(--danger)';sGrid.forEach(r=>r.forEach(c=>{if(c.isMine)c.el.innerHTML=ICON_MINE;}));let t=parseInt(localStorage.getItem('saper_total')||0)+1;saveStatToCloud('saper_total',t);showResult('Бум!','Не повезло', 'Закрыть');}
        function checkSaperWin(){ let rev=0;sGrid.forEach(r=>r.forEach(c=>{if(c.revealed)rev++})); if(rev===sRows*sCols-sMines){ sOver=true;clearInterval(sTimerInt);tg.HapticFeedback.notificationOccurred('success'); confetti({particleCount:150,spread:70,origin:{y:0.6},zIndex:2147483647}); let t=parseInt(localStorage.getItem('saper_total')||0)+1; saveStatToCloud('saper_total',t); let w=parseInt(localStorage.getItem('saper_wins')||0)+1; saveStatToCloud('saper_wins', w); const key = `saper_best_${sRows}`; let b=parseFloat(localStorage.getItem(key)||9999); if(sTimer<b) saveStatToCloud(key, sTimer); sendStatToBackend(`saper_best_${sRows}`, sTimer); sendStatToBackend('saper_wins', w); showResult('Победа!',`Время: ${sTimer.toFixed(2)} с`, 'Круто'); } }

        /* --- CHECKERS --- */
        const BOARD_SIZE=8; let board=[], turn='white', selectedPiece=null, isPvE=false, forcedPiece=null;
        
        function setCheckersMainMode(mode, btn, index) {
            const glider = document.getElementById('checkersMainGlider'); glider.style.transform = `translateX(${index * 100}%)`;
            const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active');
            const offline = document.getElementById('ch-offline-panel'); const online = document.getElementById('ch-online-panel');
            if(mode === 'online') { offline.classList.replace('panel-visible', 'panel-hidden'); online.classList.replace('panel-hidden', 'panel-visible'); } else { online.classList.replace('panel-visible', 'panel-hidden'); offline.classList.replace('panel-hidden', 'panel-visible'); } tg.HapticFeedback.selectionChanged();
        }

        function createGame() {
            document.getElementById('modalLoading').classList.add('visible');
            const user = tg.initDataUnsafe.user || { first_name: "Player" };
            const displayName = (user.first_name + ' ' + (user.last_name || '')).trim();
            // !ВАЖНО: Добавил gameType: 'checkers'
            socket.emit('create_game', { username: displayName, photo_url: user.photo_url || '', gameType: 'checkers' });
        }

        function joinGame() { tg.HapticFeedback.notificationOccurred('warning'); alert('Скоро: Поиск случайного соперника'); }
        function joinGameByCode() { const code = document.getElementById('joinCodeInput').value; if (code.length < 5) { tg.HapticFeedback.notificationOccurred('error'); return; } onlineRoomCode = code; const user = tg.initDataUnsafe.user || { first_name: "Player" }; const displayName = (user.first_name + ' ' + (user.last_name || '')).trim(); socket.emit('join_game', { roomCode: code, userData: { username: displayName, photo_url: user.photo_url || '' } }); }
        function cancelOnlineWait() { document.getElementById('modalWaitOpponent').classList.remove('visible'); onlineRoomCode = null; }

        function setCheckersMode(pve, btn, index){ isPvE = pve; isOnlineGame = false; const glider = document.getElementById('checkersGlider'); glider.style.transform = `translateX(${index * 100}%)`; const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active'); tg.HapticFeedback.selectionChanged(); }
        function launchCheckers(){document.getElementById('modalCheckers').classList.remove('visible');document.getElementById('checkers-screen').classList.add('visible');setTimeout(initCheckers,50);}
        function initCheckers(){turn='white';selectedPiece=null;forcedPiece=null;document.getElementById('checkersStatus').innerText="Ход Белых";const el=document.getElementById('checkersBoard');el.innerHTML='';board=[];for(let r=0;r<BOARD_SIZE;r++){const row=[];for(let c=0;c<BOARD_SIZE;c++){const cell=document.createElement('div');const isDark=(r+c)%2!==0;cell.className=`ch-cell ${isDark?'dark':'light'}`;cell.onclick=()=>onBoardClick(r,c);el.appendChild(cell);let p=null;if(isDark){if(r<3)p={color:'black',isKing:false};if(r>4)p={color:'white',isKing:false};}row.push({piece:p,el:cell});if(p){const d=document.createElement('div');d.className=`checker ${p.color}`;cell.appendChild(d);}}board.push(row);}}
        
        function onBoardClick(r,c){
            if (isOnlineGame) { if (turn !== onlineMyColor) return; } else { if(isPvE&&turn==='black')return; }
            const cell=board[r][c];
            if(cell.piece&&cell.piece.color===turn){if(forcedPiece&&(forcedPiece.r!==r||forcedPiece.c!==c))return;if(selectedPiece){const p=board[selectedPiece.r][selectedPiece.c].el.querySelector('.checker');if(p)p.classList.remove('selected');board.forEach(row=>row.forEach(cl=>cl.el.classList.remove('highlight')));}selectedPiece={r,c};cell.el.querySelector('.checker').classList.add('selected');highlightMoves(r,c);tg.HapticFeedback.selectionChanged();return;}if(!cell.piece&&selectedPiece){const moves=getValidMoves(selectedPiece.r,selectedPiece.c,board);const move=moves.find(m=>m.toR===r&&m.toC===c);if(move)executeMove(move, true);}
        }
        function highlightMoves(r,c){const moves=getValidMoves(r,c,board);moves.forEach(m=>board[m.toR][m.toC].el.classList.add('highlight'));}
        function getValidMoves(r,c,b){const p=b[r][c].piece;if(!p)return[];const moves=[],dirs=[[-1,-1],[-1,1],[1,-1],[1,1]];dirs.forEach(d=>{let dist=1;while(true){let nr=r+d[0]*dist,nc=c+d[1]*dist;if(nr<0||nr>=8||nc<0||nc>=8)break;if(!b[nr][nc].piece){if(!p.isKing){const fwd=(p.color==='white'&&d[0]===-1)||(p.color==='black'&&d[0]===1);if(fwd&&dist===1&&!forcedPiece)moves.push({fromR:r,fromC:c,toR:nr,toC:nc,isCapture:false});break;}else{if(!forcedPiece)moves.push({fromR:r,fromC:c,toR:nr,toC:nc,isCapture:false});}}else{if(b[nr][nc].piece.color===p.color)break;let jr=nr+d[0],jc=nc+d[1];if(jr>=0&&jr<8&&jc>=0&&jc<8&&!b[jr][jc].piece){if(p.isKing){let fd=1;while(true){let fr=nr+d[0]*fd,fc=nc+d[1]*fd;if(fr<0||fr>=8||fc<0||fc>=8||b[fr][fc].piece)break;moves.push({fromR:r,fromC:c,toR:fr,toC:fc,isCapture:true,midR:nr,midC:nc});fd++;}}else{moves.push({fromR:r,fromC:c,toR:jr,toC:jc,isCapture:true,midR:nr,midC:nc});}}break;}dist++;if(!p.isKing)break;}});const caps=moves.filter(m=>m.isCapture);return caps.length>0?caps:moves;}
        
        function executeMove(m, isLocal = true){
            const p=board[m.fromR][m.fromC].piece;
            if(isOnlineGame && isLocal) { socket.emit('move', { roomCode: onlineRoomCode, move: m }); }
            board[m.toR][m.toC].piece=p;board[m.fromR][m.fromC].piece=null;board[m.fromR][m.fromC].el.innerHTML='';const pd=document.createElement('div');pd.className=`checker ${p.color} ${p.isKing?'king':''}`;board[m.toR][m.toC].el.appendChild(pd);if(m.isCapture){board[m.midR][m.midC].piece=null;board[m.midR][m.midC].el.innerHTML='';tg.HapticFeedback.notificationOccurred('warning');let prom=false;if(!p.isKing&&((p.color==='white'&&m.toR===0)||(p.color==='black'&&m.toR===7))){p.isKing=true;pd.classList.add('king');prom=true;}if(!prom){const next=getValidMoves(m.toR,m.toC,board);if(next.some(nm=>nm.isCapture)){forcedPiece={r:m.toR,c:m.toC};selectedPiece={r:m.toR,c:m.toC};pd.classList.add('selected');highlightMoves(m.toR,m.toC);if(isPvE && !isOnlineGame && turn==='black')setTimeout(aiMove,500);return;}}}else{tg.HapticFeedback.selectionChanged();if(!p.isKing&&((p.color==='white'&&m.toR===0)||(p.color==='black'&&m.toR===7))){p.isKing=true;pd.classList.add('king');tg.HapticFeedback.notificationOccurred('success');}}board.forEach(row=>row.forEach(cl=>cl.el.classList.remove('highlight')));selectedPiece=null;forcedPiece=null;
            checkWin(); turn=turn==='white'?'black':'white'; document.getElementById('checkersStatus').innerText=turn==='white'?"Ход Белых":"Ход Чёрных";
            if (!hasAnyMoves(turn)) { const winner = turn === 'white' ? 'black' : 'white'; endGame(winner); return; }
            if(isPvE && !isOnlineGame && turn==='black')setTimeout(aiMove,600);
        }
        function hasAnyMoves(color) { for(let r=0; r<BOARD_SIZE; r++) { for(let c=0; c<BOARD_SIZE; c++) { const cell = board[r][c]; if (cell.piece && cell.piece.color === color) { const moves = getValidMoves(r, c, board); if (moves.length > 0) return true; } } } return false; }
        function checkWin(){let wc=0,bc=0;board.forEach(r=>r.forEach(c=>{if(c.piece)c.piece.color==='white'?wc++:bc++}));if(bc===0)endGame('white');else if(wc===0)endGame('black');}
        
        function endGame(w){
            let t=parseInt(localStorage.getItem('checkers_total')||0)+1; saveStatToCloud('checkers_total',t); sendStatToBackend('checkers_total', t); 
            if(isPvE&&w==='white') { const wins = parseInt(localStorage.getItem('checkers_wins_pve')||0)+1; saveStatToCloud('checkers_wins_pve', wins); sendStatToBackend('checkers_wins_pve', wins); }
            tg.HapticFeedback.notificationOccurred('success'); const m=document.getElementById('modalResultContent'),tit=document.getElementById('resTitle'),txt=document.getElementById('resText');
            if (isOnlineGame) { if (w === onlineMyColor) { tit.innerText="Победа!";txt.innerText="Вы победили!";confetti({particleCount:150,spread:70,origin:{y:0.6},zIndex:2147483647}); } else { tit.innerText="Поражение";txt.innerText="Нет ходов или шашек."; } socket.emit('game_over', { roomCode: onlineRoomCode, winner: w }); } else if(isPvE){ if(w==='white'){ tit.innerText="Победа!";txt.innerText="Робот повержен.";confetti({particleCount:150,spread:70,origin:{y:0.6},zIndex:2147483647}); }else{ tit.innerText="Поражение";txt.innerText="Робот победил."; } } else{ tit.innerText=w==='white'?"Белые победили!":"Чёрные победили!";txt.innerText="";if(w==='white')confetti({particleCount:150,spread:70,origin:{y:1},zIndex:2147483647});else{confetti({particleCount:150,spread:70,origin:{y:0},zIndex:2147483647});m.classList.add('rotate-180');} }
            setTimeout(()=>document.getElementById('modalResult').classList.add('visible'),500);
        }
        function aiMove(){const pcs=[];for(let r=0;r<8;r++)for(let c=0;c<8;c++)if(board[r][c].piece&&board[r][c].piece.color==='black')pcs.push({r,c});if(forcedPiece){const ms=getValidMoves(forcedPiece.r,forcedPiece.c,board);if(ms.length>0)executeMove(ms[0]);return;}let all=[];pcs.forEach(p=>{const ms=getValidMoves(p.r,p.c,board);ms.forEach(m=>{let s=0;if(m.isCapture)s+=10;if(m.toR===7)s+=5;if(m.toR>p.r)s+=1;all.push({m,s:s+Math.random()});});});if(all.length>0){all.sort((a,b)=>b.s-a.s);executeMove(all[0].m);}else endGame('white');}
        
        /* --- BLOCK BLAST (FIXED) --- */
        const BB_ROWS=8, BB_COLS=8; let bbGrid=[], bbScore=0, bbDisplayedScore=0, bbShapes=[], bbState=null, bbCombo=0, bbComboBuffer=0, bbIsAnimating=false; 
        const SHAPES = [[[1]],[[1,1]],[[1],[1]],[[1,1,1]],[[1],[1],[1]],[[1,1,1,1]],[[1],[1],[1],[1]],[[1,1,1,1,1]],[[1],[1],[1],[1],[1]],[[1,1],[1,1]],[[1,1,1],[1,1,1]],[[1,1],[1,1],[1,1]],[[1,1,1],[1,1,1],[1,1,1]],[[1,0],[1,0],[1,1]],[[1,1,1],[1,0,0]],[[1,1],[0,1],[0,1]],[[0,0,1],[1,1,1]],[[0,1],[0,1],[1,1]],[[1,0,0],[1,1,1]],[[1,1],[1,0],[1,0]],[[1,1,1],[0,0,1]],[[1,0],[1,1]],[[1,1],[1,0]],[[1,1],[0,1]],[[0,1],[1,1]],[[1,1,1],[0,1,0]],[[0,1,0],[1,1,1]],[[1,0],[1,1],[1,0]],[[0,1],[1,1],[0,1]]];
        const COLORS = ['bb-c-1','bb-c-2','bb-c-3','bb-c-4','bb-c-5','bb-c-6','bb-c-7'];
        const DRAG_LIFT_Y = 150; 
        function startBlockBlastCheck() { if(localStorage.getItem('bb_state')) document.getElementById('modalBBResume').classList.add('visible'); else newGameBB(); }
        function resumeBB() { document.getElementById('modalBBResume').classList.remove('visible'); document.getElementById('bb-screen').classList.add('visible'); restoreBBState(); }
        function newGameBB() { document.getElementById('modalBBResume').classList.remove('visible'); document.getElementById('bb-screen').classList.add('visible'); initBB(); }
        function initBB() { bbGrid = Array(BB_ROWS).fill().map(() => Array(BB_COLS).fill(0)); bbScore = 0; bbDisplayedScore = 0; bbCombo=0; bbComboBuffer=0; bbIsAnimating=false; updateBBScoreUI(); document.getElementById('bbBestScore').innerText = localStorage.getItem('bb_best_score') || 0; renderBBGrid(); spawnShapes(); saveBBState(); }
        function renderBBGrid() { const el = document.getElementById('bbGrid'); el.innerHTML = ''; for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { const cell = document.createElement('div'); cell.className = 'bb-cell'; cell.dataset.r = r; cell.dataset.c = c; if(bbGrid[r][c] !== 0) { cell.classList.add('filled', bbGrid[r][c]); } el.appendChild(cell); } } }
        function countFreeCells() { let free = 0; for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { if(bbGrid[r][c] === 0) free++; } } return free; }
        function spawnShapes() { bbShapes = []; const freeCells = countFreeCells(); let availableIndices = []; for(let i=0; i<SHAPES.length; i++) { const matrix = SHAPES[i]; const size = matrix.reduce((acc, row) => acc + row.reduce((a,b)=>a+b, 0), 0); if (freeCells < 25) { if (size <= 4) availableIndices.push(i); } else { availableIndices.push(i); } } for(let i=0; i<3; i++) { const rand = Math.floor(Math.random() * availableIndices.length); const shapeIdx = availableIndices[rand]; const color = COLORS[Math.floor(Math.random() * COLORS.length)]; bbShapes.push({ matrix: SHAPES[shapeIdx], color: color, id: i }); renderShapePreview(i, SHAPES[shapeIdx], color); } }
        function renderShapePreview(slotId, matrix, color) { const container = document.getElementById(`shape${slotId}`); container.innerHTML = ''; if(!matrix) return; const preview = document.createElement('div'); preview.className = 'bb-shape-preview'; preview.style.gridTemplateColumns = `repeat(${matrix[0].length}, 18px)`; matrix.forEach((row, ri) => { row.forEach((val, ci) => { const b = document.createElement('div'); if(val) { b.className = `bb-block ${color}`; b.dataset.ri = ri; b.dataset.ci = ci; } else { b.style.opacity = 0; } preview.appendChild(b); }); }); container.appendChild(preview); container.ontouchstart = (e) => startDrag(e, slotId, matrix, color); container.onmousedown = (e) => startDrag(e, slotId, matrix, color); }
        let draggedElement = null; let dragGhost = null; let dragData = null; let touchOffsetX = 0, touchOffsetY = 0;
        function hexToRgba(hex, alpha) { const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }

        // --- FIXED DRAG FUNCTION ---
        function startDrag(e, slotId, matrix, color) { 
            if(bbIsAnimating) return; 
            e.preventDefault(); 
            const touch = e.touches ? e.touches[0] : e; 
            const gridRect = document.getElementById('bbGrid').getBoundingClientRect(); 
            const cellFullSize = gridRect.width / 8; 
            dragData = { slotId, matrix, color }; 
            dragGhost = document.createElement('div'); 
            dragGhost.className = 'drag-ghost'; 
            dragGhost.style.gridTemplateColumns = `repeat(${matrix[0].length}, ${cellFullSize}px)`; 
            dragGhost.style.gridTemplateRows = `repeat(${matrix.length}, ${cellFullSize}px)`; 
            dragGhost.style.gap = '4px'; 
            dragGhost.style.display = 'grid'; 
            const shapePixelW = matrix[0].length * cellFullSize; 
            
            // Исправленный цикл
            matrix.forEach((row, ri) => { 
                row.forEach((val, ci) => { 
                    const b = document.createElement('div'); 
                    if(val) { b.className = `bb-block ${color}`; b.dataset.ri = ri; b.dataset.ci = ci; } else { b.style.opacity = 0; } 
                    dragGhost.appendChild(b); 
                }); 
            }); 
            
            document.body.appendChild(dragGhost); 
            touchOffsetX = (shapePixelW / 2); touchOffsetY = (shapePixelW / 2); 
            moveGhost(touch.clientX, touch.clientY); 
            const preview = document.querySelector(`#shape${slotId} .bb-shape-preview`); if(preview) preview.style.opacity = 0; 
            document.addEventListener('touchmove', onTouchMove, {passive: false}); document.addEventListener('touchend', onTouchEnd); document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onTouchEnd); 
        }

        function onTouchMove(e) { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }
        function onMouseMove(e) { e.preventDefault(); handleMove(e.clientX, e.clientY); }
        function handleMove(x, y) { const ghostX = x - touchOffsetX; const ghostY = y - touchOffsetY - DRAG_LIFT_Y; if(dragGhost) { dragGhost.style.left = ghostX + 'px'; dragGhost.style.top = ghostY + 'px'; } const gridRect = document.getElementById('bbGrid').getBoundingClientRect(); const cellFullSize = gridRect.width / 8; const relX = ghostX - gridRect.left; const relY = ghostY - gridRect.top; const col = Math.round(relX / cellFullSize); const row = Math.round(relY / cellFullSize); checkPlacement(row, col); }
        function moveGhost(x, y) { const ghostX = x - touchOffsetX; const ghostY = y - touchOffsetY - DRAG_LIFT_Y; if(dragGhost) { dragGhost.style.left = ghostX + 'px'; dragGhost.style.top = ghostY + 'px'; } }
        
        function checkPlacement(r, c) { 
            document.querySelectorAll('.bb-cell.bb-shadow').forEach(c => c.classList.remove('bb-shadow', 'bb-c-1','bb-c-2','bb-c-3','bb-c-4','bb-c-5','bb-c-6','bb-c-7')); 
            document.querySelectorAll('.bb-cell.pre-clear').forEach(c => { c.classList.remove('pre-clear'); c.style.backgroundColor = ''; });
            if(canPlace(dragData.matrix, r, c)) { 
                drawShadow(dragData.matrix, r, c, dragData.color); 
                dragData.validPos = { r: r, c: c }; 
                let tempGrid = bbGrid.map(row => [...row]); let rowsToClear = [], colsToClear = [];
                for(let i=0; i<dragData.matrix.length; i++) { for(let j=0; j<dragData.matrix[0].length; j++) { if(dragData.matrix[i][j] === 1) tempGrid[r+i][c+j] = 1; } }
                for(let rr=0; rr<BB_ROWS; rr++) if(tempGrid[rr].every(val => val !== 0)) rowsToClear.push(rr);
                for(let cc=0; cc<BB_COLS; cc++) { let full = true; for(let rr=0; rr<BB_ROWS; rr++) if(tempGrid[rr][cc] === 0) full = false; if(full) colsToClear.push(cc); }
                rowsToClear.forEach(rr => { for(let cc=0; cc<BB_COLS; cc++) highlightPreClear(rr, cc, dragData.color); });
                colsToClear.forEach(cc => { for(let rr=0; rr<BB_ROWS; rr++) highlightPreClear(rr, cc, dragData.color); });
            } else { dragData.validPos = null; } 
        }
        function highlightPreClear(r, c, colorClass) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); if(cell) { cell.classList.add('pre-clear'); const hex = COLOR_MAP[colorClass] || '#007aff'; cell.style.backgroundColor = hexToRgba(hex, 0.4); } }
        function canPlace(matrix, r, c) { for(let i=0; i<matrix.length; i++) { for(let j=0; j<matrix[0].length; j++) { if(matrix[i][j] === 1) { let nr = r + i; let nc = c + j; if(nr < 0 || nr >= BB_ROWS || nc < 0 || nc >= BB_COLS || bbGrid[nr][nc] !== 0) return false; } } } return true; }
        function drawShadow(matrix, r, c, color) { for(let i=0; i<matrix.length; i++) { for(let j=0; j<matrix[0].length; j++) { if(matrix[i][j] === 1) { const cell = document.querySelector(`.bb-cell[data-r="${r+i}"][data-c="${c+j}"]`); if(cell) cell.classList.add('bb-shadow', color); } } } }
        
        function onTouchEnd(e) { 
            document.removeEventListener('touchmove', onTouchMove); document.removeEventListener('touchend', onTouchEnd); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onTouchEnd); 
            if(dragGhost) dragGhost.remove(); 
            document.querySelectorAll('.bb-cell.pre-clear').forEach(c => { c.classList.remove('pre-clear'); c.style.backgroundColor = ''; });
            document.querySelectorAll('.bb-cell.bb-shadow').forEach(c => c.classList.remove('bb-shadow', 'bb-c-1','bb-c-2','bb-c-3','bb-c-4','bb-c-5','bb-c-6','bb-c-7')); 
            const original = document.querySelector(`#shape${dragData.slotId} .bb-shape-preview`); if(original) original.style.opacity = 1; 
            if(dragData.validPos) { 
                placeShape(dragData.matrix, dragData.validPos.r, dragData.validPos.c, dragData.color); 
                document.getElementById(`shape${dragData.slotId}`).innerHTML = ''; 
                const container = document.getElementById(`shape${dragData.slotId}`); container.ontouchstart = null; container.onmousedown = null; bbShapes[dragData.slotId] = null; 
                const linesCleared = checkLines(dragData.color); 
                if(linesCleared === 0) { if (bbCombo > 0) { bbComboBuffer--; if(bbComboBuffer <= 0) { bbCombo = 0; updateBBScoreUI(); } } if(bbShapes.every(s => s === null)) spawnShapes(); checkGameOver(); saveBBState(); } 
                else { if(bbShapes.every(s => s === null)) spawnShapes(); } 
            } 
        }

        function placeShape(matrix, r, c, color) { 
            tg.HapticFeedback.impactOccurred('light'); let placedCount = 0; 
            for(let i=0; i<matrix.length; i++) { for(let j=0; j<matrix[0].length; j++) { if(matrix[i][j] === 1) { bbGrid[r+i][c+j] = color; const cell = document.querySelector(`.bb-cell[data-r="${r+i}"][data-c="${c+j}"]`); cell.classList.add('no-transition'); cell.classList.add('filled', color); cell.style.backgroundColor = ''; setTimeout(() => cell.classList.remove('no-transition'), 50); placedCount++; } } } addScore(placedCount); 
        }
        function checkLines(triggerColor) { 
            let linesCleared = 0; const rowsToClear = []; const colsToClear = []; 
            for(let r=0; r<BB_ROWS; r++) { if(bbGrid[r].every(val => val !== 0)) rowsToClear.push(r); } 
            for(let c=0; c<BB_COLS; c++) { let full = true; for(let r=0; r<BB_ROWS; r++) if(bbGrid[r][c] === 0) full = false; if(full) colsToClear.push(c); } 
            const totalCleared = rowsToClear.length + colsToClear.length; 
            if(totalCleared > 0) { 
                bbCombo++; bbComboBuffer = 3; updateBBScoreUI(); tg.HapticFeedback.notificationOccurred('success'); 
                if(!isLiteMode) document.querySelector('.bb-game-container').classList.add('shake-screen');
                rowsToClear.forEach(r => { if(!isLiteMode) fireNeonParticles(r, -1, triggerColor); for(let c=0; c<BB_COLS; c++) { bbGrid[r][c] = 0; animateClear(r, c, triggerColor); } }); 
                colsToClear.forEach(c => { if(!isLiteMode) fireNeonParticles(-1, c, triggerColor); for(let r=0; r<BB_ROWS; r++) { bbGrid[r][c] = 0; animateClear(r, c, triggerColor); } }); 
                setTimeout(() => { document.querySelector('.bb-game-container').classList.remove('shake-screen'); let points = totalCleared * 10; if (totalCleared >= 2) { points = points * totalCleared; showComboPopup(`X${totalCleared} MULTIPLIER!`); } else if(bbCombo > 1) { points += bbCombo * 10; showComboPopup(`COMBO x${bbCombo}!`); } addScore(points); saveBBState(); setTimeout(checkAllClear, 50); checkGameOver(); }, 350); return totalCleared; 
            } return 0; 
        }
        function fireNeonParticles(row, col, colorClass) {
            const hex = COLOR_MAP[colorClass] || '#ffffff'; const gridRect = document.getElementById('bbGrid').getBoundingClientRect(); const cellW = gridRect.width / 8; const cellH = gridRect.height / 8;
            let xOrigin, yOrigin; if (row !== -1) { xOrigin = (gridRect.left + gridRect.width / 2) / window.innerWidth; yOrigin = (gridRect.top + (row * cellH) + (cellH/2)) / window.innerHeight; } else { xOrigin = (gridRect.left + (col * cellW) + (cellW/2)) / window.innerWidth; yOrigin = (gridRect.top + gridRect.height / 2) / window.innerHeight; }
            confetti({ particleCount: 40, startVelocity: 35, spread: 360, origin: { x: xOrigin, y: yOrigin }, colors: [hex, '#ffffff'], shapes: ['square'], scalar: 0.5, drift: 0, ticks: 50, gravity: 0.5, zIndex: 11000, disableForReducedMotion: true });
        }
        function showComboPopup(text) { const p = document.createElement('div'); p.className = 'combo-popup'; p.innerText = text; document.querySelector('.bb-game-container').appendChild(p); setTimeout(() => p.remove(), 1000); }
        function animateClear(r, c, color) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); if(cell) { cell.className = 'bb-cell'; cell.style.backgroundColor = ''; cell.style.boxShadow = ''; if(!isLiteMode) { cell.classList.add('appear-gray'); setTimeout(() => { cell.classList.remove('appear-gray'); }, 400); } } }
        function addScore(points) { bbScore += points; const target = bbScore; const step = Math.ceil((target - bbDisplayedScore) / 10); const int = setInterval(() => { bbDisplayedScore += step; if(bbDisplayedScore >= target) { bbDisplayedScore = target; clearInterval(int); } updateBBScoreUI(); }, 30); }
        function updateBBScoreUI() { const el = document.getElementById('bbScore'); el.innerText = bbDisplayedScore; if(bbCombo > 0) el.classList.add('active-combo'); else el.classList.remove('active-combo'); }
        function checkAllClear() { if(bbIsAnimating) return; const free = countFreeCells(); if(free === BB_ROWS * BB_COLS) { bbIsAnimating = true; tg.HapticFeedback.notificationOccurred('success'); const bonus = 500 * (bbCombo > 0 ? bbCombo : 1); let delay = 0; for(let r=BB_ROWS-1; r>=0; r--) { setTimeout(() => { for(let c=0; c<BB_COLS; c++) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); const randColor = COLORS[Math.floor(Math.random()*COLORS.length)]; cell.className = `bb-cell filled ${randColor}`; } tg.HapticFeedback.impactOccurred('light'); }, delay); delay += 50; } setTimeout(() => { for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); cell.className = 'bb-cell clearing'; } } setTimeout(() => { renderBBGrid(); }, 200); const container = document.querySelector('.bb-game-container'); const pop = document.createElement('div'); pop.className = 'all-clear-popup'; pop.innerHTML = `<div class="ac-text">UNBELIEVABLE</div><div class="ac-score">+${bonus}</div>`; container.appendChild(pop); confetti({ particleCount: 150, spread: 100, origin: { y: 0.5 }, zIndex: 11000 }); addScore(bonus); setTimeout(() => { pop.remove(); bbIsAnimating = false; saveBBState(); }, 2000); }, delay + 200); } }
        async function checkGameOver() { if(bbIsAnimating) return; const shapesLeft = bbShapes.filter(s => s !== null); if(shapesLeft.length === 0) return; const canMove = shapesLeft.some(s => { for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { if(canPlace(s.matrix, r, c)) return true; } } return false; }); if(!canMove) { tg.HapticFeedback.notificationOccurred('error'); await animateGameOverFill(); const currentBest = parseInt(localStorage.getItem('bb_best_score') || 0); const isRecord = bbScore > currentBest; if(isRecord) { saveStatToCloud('bb_best_score', bbScore); sendStatToBackend('bb_best_score', bbScore); } localStorage.removeItem('bb_state'); let t = parseInt(localStorage.getItem('bb_total_games')||0)+1; saveStatToCloud('bb_total_games', t); sendStatToBackend('bb_total_games', t); showBBGameOverModal(isRecord, bbScore, currentBest); } }
        function animateGameOverFill() { return new Promise(resolve => { const emptyCells = []; for(let r=BB_ROWS-1; r>=0; r--) { for(let c=0; c<BB_COLS; c++) { if(bbGrid[r][c] === 0) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); emptyCells.push(cell); } } } let i = 0; const int = setInterval(() => { if(i >= emptyCells.length) { clearInterval(int); setTimeout(resolve, 300); return; } const cell = emptyCells[i]; const color = COLORS[Math.floor(Math.random() * COLORS.length)]; if(cell) cell.classList.add('filled', color); i++; }, 10); }); }
        function showBBGameOverModal(isRecord, score, oldBest) { const modal = document.getElementById('bbGameOverContent'); const overlay = document.getElementById('modalBBGameOver'); modal.innerHTML = ''; if(isRecord) { confetti({ particleCount: 200, spread: 100, origin: { y: 0.6 }, zIndex: 22000 }); modal.innerHTML = `${ICON_CROWN}<h2 style="margin:0 0 10px 0; font-size:24px;">Новый Рекорд!</h2><div style="font-size:48px; font-weight:800; color:var(--accent); margin:10px 0;" id="recCounter">0</div><button class="btn-main" onclick="closeResult(); newGameBB();">Играть снова</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="closeResult()">Выйти</button>`; let s = oldBest; const step = Math.ceil((score - oldBest) / 30); const counter = document.getElementById('recCounter'); const int = setInterval(() => { s += step; if(s >= score) { s = score; clearInterval(int); } counter.innerText = s; }, 30); } else { modal.innerHTML = `<h2 style="margin:0 0 5px 0;">Рекорд не побит</h2><p style="color:#8e8e93; margin:0 0 20px 0;">Попробуйте еще раз!</p><div style="font-size:32px; font-weight:700;">${score}</div><div style="font-size:14px; color:#8e8e93; margin-bottom:20px;">Лучший: ${oldBest}</div><button class="btn-main" onclick="closeResult(); newGameBB();">Новая игра</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="closeResult()">Выйти</button>`; } overlay.classList.add('visible'); }
        function saveBBState() { if(bbShapes.every(s=>s===null)) return; const state = { grid: bbGrid, score: bbScore, shapes: bbShapes, combo: bbCombo, buffer: bbComboBuffer }; localStorage.setItem('bb_state', JSON.stringify(state)); }
        function restoreBBState() { const data = JSON.parse(localStorage.getItem('bb_state')); if(!data) { initBB(); return; } bbGrid = data.grid; bbScore = data.score; bbCombo = data.combo || 0; bbComboBuffer = data.buffer || 0; bbDisplayedScore = bbScore; bbShapes = data.shapes; updateBBScoreUI(); document.getElementById('bbBestScore').innerText = localStorage.getItem('bb_best_score') || 0; renderBBGrid(); for(let i=0; i<3; i++) { if(bbShapes[i]) renderShapePreview(i, bbShapes[i].matrix, bbShapes[i].color); else document.getElementById(`shape${i}`).innerHTML = ''; } }
        function showResult(title, text, btnText="Закрыть", action=null) { document.getElementById('resTitle').innerText=title; document.getElementById('resText').innerText=text; const btn=document.getElementById('resBtn'); btn.innerText=btnText; btn.onclick=action?action:closeResult; document.getElementById('modalResult').classList.add('visible'); }

        /* --- SUDOKU LOGIC --- */
        let sudoBoard = [], sudoSolution = [], activeDigit = null, sudoLives = 3, sudoFilled = 0; let selectedSudoDiff = 40; let currentSudoMode = 1;
        function startSudokuCheck() { if(localStorage.getItem('sudo_state')) document.getElementById('modalSudokuResume').classList.add('visible'); else document.getElementById('modalSudoku').classList.add('visible'); }
        function resumeSudoku() { document.getElementById('modalSudokuResume').classList.remove('visible'); document.getElementById('sudoku-screen').classList.add('visible'); restoreSudokuState(); }
        function selectSudokuDiff(diff, btn, index) { selectedSudoDiff = diff; const glider = document.getElementById('sudokuGlider'); glider.style.transform = `translateY(${index * 100}%)`; const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active'); tg.HapticFeedback.selectionChanged(); }
        function startSudoku() { document.getElementById('modalSudoku').classList.remove('visible'); document.getElementById('sudoku-screen').classList.add('visible'); generateSudoku(selectedSudoDiff); }
        function generateSudoku(holes) {
            if (holes === 30) currentSudoMode = 1; else if (holes === 40) currentSudoMode = 2; else currentSudoMode = 3;
            sudoBoard = Array(81).fill(0); sudoSolution = Array(81).fill(0); sudoLives = 3; sudoFilled = 0; activeDigit = null; document.querySelectorAll('.num-btn').forEach(b => { b.classList.remove('active-digit', 'disabled'); });
            document.getElementById('sudokuLives').innerText = "0/3"; document.getElementById('sudokuLives').style.color = "var(--text-color)";
            fillSudo(0, 0); sudoSolution = [...sudoBoard]; let removed = 0; while (removed < holes) { let idx = Math.floor(Math.random() * 81); if (sudoBoard[idx] !== 0) { sudoBoard[idx] = 0; removed++; } }
            renderSudoku(); checkNumberCompletion(); saveSudokuState();
        }
        function fillSudo(row, col) { if (col === 9) { row++; col = 0; } if (row === 9) return true; const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5); for (let num of nums) { if (isValidSudo(sudoBoard, row, col, num)) { sudoBoard[row * 9 + col] = num; if (fillSudo(row, col + 1)) return true; sudoBoard[row * 9 + col] = 0; } } return false; }
        function isValidSudo(board, row, col, num) { for (let x = 0; x < 9; x++) if (board[row * 9 + x] === num) return false; for (let x = 0; x < 9; x++) if (board[x * 9 + col] === num) return false; let startRow = Math.floor(row / 3) * 3, startCol = Math.floor(col / 3) * 3; for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) if (board[(startRow + i) * 9 + (startCol + j)] === num) return false; return true; }
        function renderSudoku() { const el = document.getElementById('sudokuBoard'); el.innerHTML = ''; sudoFilled = 0; for (let i = 0; i < 81; i++) { const cell = document.createElement('div'); cell.className = 'sudo-cell'; if (sudoBoard[i] !== 0) { cell.innerText = sudoBoard[i]; cell.classList.add('given'); sudoFilled++; } cell.onclick = () => onCellClick(i, cell); cell.dataset.idx = i; el.appendChild(cell); } }
        function activateDigit(num, btn) { if (btn.classList.contains('disabled')) return; if (activeDigit === num) { activeDigit = null; btn.classList.remove('active-digit'); highlightSameNumbers(null); tg.HapticFeedback.selectionChanged(); return; } activeDigit = num; document.querySelectorAll('.num-btn').forEach(b => b.classList.remove('active-digit')); btn.classList.add('active-digit'); highlightSameNumbers(num); tg.HapticFeedback.selectionChanged(); }
        function highlightSameNumbers(num) { const cells = document.querySelectorAll('.sudo-cell'); cells.forEach(c => c.classList.remove('same-num')); if (num === null) return; cells.forEach(cell => { if (parseInt(cell.innerText) === num) cell.classList.add('same-num'); }); }
        function checkNumberCompletion() { for(let i=1; i<=9; i++) { let count = 0; for(let j=0; j<81; j++) if(sudoBoard[j] === i) count++; const btn = document.getElementById(`nb${i}`); if(count >= 9) { btn.classList.add('disabled'); btn.classList.remove('active-digit'); if(activeDigit === i) { activeDigit = null; highlightSameNumbers(null); } } else { btn.classList.remove('disabled'); } } }
        function onCellClick(idx, cell) { if (activeDigit === null) return; if (sudoBoard[idx] !== 0) return; const correctVal = sudoSolution[idx]; if (activeDigit === correctVal) { cell.innerText = activeDigit; cell.classList.add('user-val', 'correct', 'same-num'); sudoBoard[idx] = activeDigit; sudoFilled++; tg.HapticFeedback.notificationOccurred('success'); cell.animate([{ transform: 'scale(0.5)' }, { transform: 'scale(1.2)' }, { transform: 'scale(1)' }], { duration: 300 }); checkNumberCompletion(); saveSudokuState(); checkSudokuWin(); } else { cell.innerText = activeDigit; cell.classList.add('error'); tg.HapticFeedback.notificationOccurred('error'); sudoLives--; document.getElementById('sudokuLives').innerText = `${3-sudoLives}/3`; document.getElementById('sudokuLives').style.color = "var(--danger)"; setTimeout(() => { cell.innerText = ''; cell.classList.remove('error'); }, 400); saveSudokuState(); if (sudoLives <= 0) { localStorage.removeItem('sudo_state'); setTimeout(() => showResult('Поражение', 'Слишком много ошибок'), 500); } } }
        function checkSudokuWin() { if (sudoFilled === 81) { confetti({particleCount:150,spread:70,origin:{y:0.6},zIndex:2147483647}); let points = currentSudoMode; let w = parseInt(localStorage.getItem('sudoku_wins')||0) + points; saveStatToCloud('sudoku_wins', w); sendStatToBackend('sudoku_wins', w); localStorage.removeItem('sudo_state'); showResult('Победа!', `Судоку решено! (+${points})`); } }
        function saveSudokuState() { if(sudoFilled === 81 || sudoLives <= 0) return; const state = { board: sudoBoard, sol: sudoSolution, lives: sudoLives, mode: currentSudoMode }; localStorage.setItem('sudo_state', JSON.stringify(state)); }
        function restoreSudokuState() { const data = JSON.parse(localStorage.getItem('sudo_state')); if(!data) { generateSudoku(40); return; } sudoBoard = data.board; sudoSolution = data.sol; sudoLives = data.lives; currentSudoMode = data.mode; document.getElementById('sudokuLives').innerText = `${3-sudoLives}/3`; if(sudoLives < 3) document.getElementById('sudokuLives').style.color = "var(--danger)"; renderSudoku(); checkNumberCompletion(); }

        /* --- TOWER (STACK) GAME LOGIC --- */
        let twCanvas, twCtx;
        let twBlocks = [];
        let twDebris = []; 
        let twScore = 0;
        let twState = 'start'; 
        let twHue = 0; 
        let twCameraY = 0; 
        let twPerfectMatchAlpha = 0;
        let twCurrentBlock = null;
        let twDirection = 'x'; 
        let twSpeed = 3.0;
        let twAnimationFrameId = null;
        let twBestScore = 0;
        let twBestCombo = 0;
        let twCurrentCombo = 0;
        let twMaxComboThisGame = 0;

        const TW_BLOCK_HEIGHT = 35; 
        const TW_BASE_SIZE = 130; 
        let twInitialized = false;
        let twLastTapTime = 0;
        
        function initTower() {
            twCanvas = document.getElementById('towerCanvas');
            twCtx = twCanvas.getContext('2d');
            twResizeCanvas();
            
            twBestScore = parseInt(localStorage.getItem('tower_best') || 0);
            twBestCombo = parseInt(localStorage.getItem('tower_combo') || 0);
            document.getElementById('towerBestScore').innerText = twBestScore;
            
            if(!twInitialized) {
                window.addEventListener('resize', twResizeCanvas);
                // Используем только touchstart для тач-устройств, pointerdown для мыши
                twCanvas.addEventListener('touchstart', (e) => { 
                    e.preventDefault(); 
                    twLastTapTime = Date.now();
                    twHandleAction(); 
                }, { passive: false });
                twCanvas.addEventListener('mousedown', (e) => { 
                    // Игнорируем клик мыши если только что был тач (предотвращает двойное срабатывание)
                    if (Date.now() - twLastTapTime < 300) return;
                    e.preventDefault();
                    twHandleAction(); 
                });
                twInitialized = true;
            }
            
            twResetGame();
            twLoop();
        }
        
        function twResizeCanvas() {
            if(!twCanvas) return;
            twCanvas.width = window.innerWidth * window.devicePixelRatio;
            twCanvas.height = window.innerHeight * window.devicePixelRatio;
            twCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        function twResetGame() {
            if (twAnimationFrameId) {
                cancelAnimationFrame(twAnimationFrameId);
                twAnimationFrameId = null;
            }
            twBlocks = [];
            twDebris = [];
            twScore = 0;
            twSpeed = 3.0;
            twDirection = 'x';
            twHue = Math.floor(Math.random() * 360);
            twState = 'start';
            twCameraY = 0;
            twPerfectMatchAlpha = 0;
            twCurrentBlock = null;
            twCurrentCombo = 0;
            twMaxComboThisGame = 0;
            
            // Добавляем базовый блок для отображения
            twBlocks.push({
                x: 0, z: 0, w: TW_BASE_SIZE, d: TW_BASE_SIZE, color: twGetHSL(twHue)
            });
            
            document.getElementById('towerScore').innerText = twScore;
            document.getElementById('towerScore').style.color = "var(--accent)";
            document.getElementById('towerStartMsg').style.display = 'block';
            document.getElementById('modalTowerGameOver').classList.remove('visible');
        }

        function twStartGame() {
            if (twAnimationFrameId) {
                cancelAnimationFrame(twAnimationFrameId);
                twAnimationFrameId = null;
            }
            twState = 'playing';
            document.getElementById('towerStartMsg').style.display = 'none';
            
            twSpawnNextBlock();
            twLoop();
        }

        function twSpawnNextBlock() {
            const prev = twBlocks[twBlocks.length - 1];
            twHue += 6; 
            twDirection = twDirection === 'x' ? 'z' : 'x'; 
            const dist = 350;
            const nextColor = twGetHSL(twHue);
            document.getElementById('towerScore').style.color = nextColor;
            
            twCurrentBlock = {
                x: twDirection === 'x' ? -dist : prev.x,
                z: twDirection === 'z' ? -dist : prev.z,
                w: prev.w, d: prev.d,
                color: nextColor,
                moveDir: 1 
            };
        }

        function twUpdatePhysics() {
            if (twState !== 'playing' || !twCurrentBlock) return;
            const limit = 360;
            
            if (twDirection === 'x') {
                twCurrentBlock.x += twSpeed * twCurrentBlock.moveDir;
                if (twCurrentBlock.x > limit) twCurrentBlock.moveDir = -1;
                if (twCurrentBlock.x < -limit) twCurrentBlock.moveDir = 1;
            } else {
                twCurrentBlock.z += twSpeed * twCurrentBlock.moveDir;
                if (twCurrentBlock.z > limit) twCurrentBlock.moveDir = -1;
                if (twCurrentBlock.z < -limit) twCurrentBlock.moveDir = 1;
            }

            const targetY = (twBlocks.length * TW_BLOCK_HEIGHT) - 150;
            if(targetY > 0) twCameraY += (targetY - twCameraY) * 0.05;
            if(twPerfectMatchAlpha > 0) twPerfectMatchAlpha -= 0.05;
        }

        function twHandleAction(e) {
            if (e) e.preventDefault(); 
            if (twState === 'start') {
                twStartGame();
                return;
            }
            if (twState === 'gameover') return;
            twPlaceBlock();
        }

        function twPlaceBlock() {
            if (!twCurrentBlock) return;
            const prev = twBlocks[twBlocks.length - 1];
            let diff;
            if (twDirection === 'x') diff = twCurrentBlock.x - prev.x;
            else diff = twCurrentBlock.z - prev.z;

            // Perfect match
            if (Math.abs(diff) < 4) {
                twCurrentBlock.x = prev.x;
                twCurrentBlock.z = prev.z;
                twCurrentBlock.w = prev.w;
                twCurrentBlock.d = prev.d;
                
                const scoreEl = document.getElementById('towerScore');
                scoreEl.style.transform = 'scale(1.2)';
                setTimeout(() => scoreEl.style.transform = 'scale(1)', 150);
                tg.HapticFeedback.notificationOccurred('success');
                
                twPerfectMatchAlpha = 1.0;
                twCurrentCombo++;
                if(twCurrentCombo > twMaxComboThisGame) twMaxComboThisGame = twCurrentCombo;
                
                twCommitBlock();
                return;
            }

            // Reset combo on imperfect match
            twCurrentCombo = 0;

            let overlap, cutSize, debrisX, debrisZ;
            let isGameOver = false;
            let impulseX = 0, impulseZ = 0;
            let debrisBehind = (diff < 0);

            if (twDirection === 'x') {
                overlap = prev.w - Math.abs(diff);
                if (overlap > 0) {
                    cutSize = Math.abs(diff);
                    twCurrentBlock.w = overlap; 
                    if (diff > 0) { 
                        twCurrentBlock.x = prev.x + (diff / 2);
                        debrisX = twCurrentBlock.x + (overlap/2) + (cutSize/2);
                        impulseX = 2.5; 
                    } else { 
                        twCurrentBlock.x = prev.x + (diff / 2);
                        debrisX = twCurrentBlock.x - (overlap/2) - (cutSize/2);
                        impulseX = -2.5;
                    }
                    twAddDebris(debrisX, twCurrentBlock.z, cutSize, twCurrentBlock.d, impulseX, 0, debrisBehind);
                } else isGameOver = true;
            } else { 
                overlap = prev.d - Math.abs(diff);
                if (overlap > 0) {
                    cutSize = Math.abs(diff);
                    twCurrentBlock.d = overlap; 
                    if (diff > 0) { 
                        twCurrentBlock.z = prev.z + (diff / 2);
                        debrisZ = twCurrentBlock.z + (overlap/2) + (cutSize/2);
                        impulseZ = 2.5;
                    } else { 
                        twCurrentBlock.z = prev.z + (diff / 2);
                        debrisZ = twCurrentBlock.z - (overlap/2) - (cutSize/2);
                        impulseZ = -2.5;
                    }
                    twAddDebris(twCurrentBlock.x, debrisZ, twCurrentBlock.w, cutSize, 0, impulseZ, debrisBehind);
                } else isGameOver = true;
            }

            if (isGameOver) {
                let gameOverBehind = (diff < 0); 
                twAddDebris(twCurrentBlock.x, twCurrentBlock.z, twCurrentBlock.w, twCurrentBlock.d, twDirection==='x'?twCurrentBlock.moveDir*2:0, twDirection==='z'?twCurrentBlock.moveDir*2:0, gameOverBehind);
                twGameOver();
            } else {
                tg.HapticFeedback.impactOccurred('light');
                twCommitBlock();
            }
        }

        function twCommitBlock() {
            twBlocks.push(twCurrentBlock);
            twScore++;
            document.getElementById('towerScore').innerText = twScore;
            twSpeed += 0.02; 
            twSpawnNextBlock();
        }

        function twAddDebris(x, z, w, d, vx, vz, isBehind) {
            const rotSpeed = (Math.random() > 0.5 ? 1 : -1) * (0.02 + Math.random() * 0.04); 
            twDebris.push({
                x: x, z: z, w: w, d: d,
                color: twCurrentBlock.color,
                vy: 0, vx: vx, vz: vz,
                yOffset: 0, angle: 0, 
                vRot: rotSpeed, alpha: 1,
                isBehind: isBehind
            });
        }

        function twGameOver() {
            twState = 'gameover';
            tg.HapticFeedback.notificationOccurred('error');
            
            let isScoreRecord = false;
            let isComboRecord = false;
            
            if(twScore > twBestScore) {
                twBestScore = twScore;
                localStorage.setItem('tower_best', twBestScore);
                saveStatToCloud('tower_best', twBestScore);
                sendStatToBackend('tower_best', twBestScore);
                document.getElementById('towerBestScore').innerText = twBestScore;
                isScoreRecord = true;
            }
            
            if(twMaxComboThisGame > twBestCombo) {
                twBestCombo = twMaxComboThisGame;
                localStorage.setItem('tower_combo', twBestCombo);
                saveStatToCloud('tower_combo', twBestCombo);
                sendStatToBackend('tower_combo', twBestCombo);
                isComboRecord = true;
            }

            const modal = document.getElementById('towerGameOverContent');
            const overlay = document.getElementById('modalTowerGameOver');
            
            let html = '';
            if(isScoreRecord && twScore > 0) {
                html = `${ICON_CROWN}<h2 style="margin:0 0 5px 0;">Новый рекорд!</h2>
                <div style="font-size:14px; color:#8e8e93; margin-bottom:10px;">Вы построили огромную башню!</div>
                <div style="font-size:56px; font-weight:200; color:var(--accent); line-height:1;">${twScore}</div>
                <div style="font-size:14px; color:#8e8e93; margin-top:10px;">Чистая серия: ${twMaxComboThisGame}${isComboRecord ? ' 🔥' : ''}</div>
                <button class="btn-main" onclick="twRestartGame()">Играть снова</button>`;
                
                confetti({ particleCount: 100, spread: 70, origin: { x: 0, y: 0.6 }, angle: 60, shapes: ['circle'], drift: 1, zIndex: 23000 });
                confetti({ particleCount: 100, spread: 70, origin: { x: 1, y: 0.6 }, angle: 120, shapes: ['circle'], drift: -1, zIndex: 23000 });
            } else {
                html = `<h2 style="margin:0 0 5px 0;">Башня упала</h2>
                <div style="font-size:14px; color:#8e8e93; margin-bottom:10px;">Лучший: ${twBestScore}</div>
                <div style="font-size:48px; font-weight:700; margin-bottom:5px;">${twScore}</div>
                <div style="font-size:14px; color:#8e8e93;">Чистая серия: ${twMaxComboThisGame}${isComboRecord ? ' 🔥 Рекорд!' : ''}</div>
                <button class="btn-main" onclick="twRestartGame()">Попробовать еще</button>`;
            }
            html += `<button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="twExitGame()">Выйти</button>`;
            
            modal.innerHTML = html;
            setTimeout(() => overlay.classList.add('visible'), 500);
        }

        function twRestartGame() {
            document.getElementById('modalTowerGameOver').classList.remove('visible');
            twResetGame();
            twStartGame();
        }

        function twExitGame() {
            document.getElementById('modalTowerGameOver').classList.remove('visible');
            closeGame('tower');
        }

        function twLoop() {
            if(!document.getElementById('tower-screen').classList.contains('visible')) {
                twAnimationFrameId = null;
                return;
            }
            if(twState === 'gameover' && twDebris.length === 0 && twPerfectMatchAlpha <= 0) {
                twAnimationFrameId = null;
                return;
            }
            
            twAnimationFrameId = requestAnimationFrame(twLoop);
            twUpdatePhysics();
            twCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 1.5; 

            // Draw debris behind blocks
            twDebris.forEach(d => { if (d.isBehind) twUpdateAndDrawDebris(d, cx, cy); });

            // Draw stacked blocks
            twBlocks.forEach((b, i) => {
                const stackY = i * TW_BLOCK_HEIGHT; 
                let highlight = (i === twBlocks.length - 1 && twPerfectMatchAlpha > 0);
                twDrawIsoBlock(cx, cy, b.x, b.z, b.w, b.d, stackY, b.color, highlight);
            });

            // Draw current moving block
            if (twCurrentBlock && twState === 'playing') {
                const stackY = twBlocks.length * TW_BLOCK_HEIGHT;
                twDrawIsoBlock(cx, cy, twCurrentBlock.x, twCurrentBlock.z, twCurrentBlock.w, twCurrentBlock.d, stackY, twCurrentBlock.color, false);
            }

            // Draw debris in front of blocks
            twDebris.forEach(d => { if (!d.isBehind) twUpdateAndDrawDebris(d, cx, cy); });
            twDebris = twDebris.filter(d => d.alpha > 0);
        }
        
        function twUpdateAndDrawDebris(d, cx, cy) {
            d.vy += 0.5; 
            d.yOffset -= d.vy;
            d.x += d.vx; d.z += d.vz;
            d.angle += d.vRot; 
            d.alpha -= 0.015; 
            
            const stackY = (twBlocks.length) * TW_BLOCK_HEIGHT + d.yOffset;

            if (d.alpha > 0) {
                twCtx.globalAlpha = d.alpha;
                twCtx.save();
                const isoX = (d.x - d.z);
                const isoY = (d.x + d.z) * 0.5;
                const screenX = cx + isoX;
                const screenY = cy + isoY - stackY + twCameraY - (TW_BLOCK_HEIGHT/2);
                twCtx.translate(screenX, screenY);
                twCtx.rotate(d.angle);
                twDrawRotatedIsoBlock(d.w, d.d, d.color);
                twCtx.restore();
                twCtx.globalAlpha = 1;
            }
        }
        
        function twDrawRotatedIsoBlock(w, d, color) {
            const vecX_x = 1, vecX_y = 0.5;
            const vecZ_x = -1, vecZ_y = 0.5;
            
            function getLocIso(lx, lz) {
                return { x: (lx * vecX_x + lz * vecZ_x), y: (lx * vecX_y + lz * vecZ_y) - (TW_BLOCK_HEIGHT/2) };
            }
            
            const p_top = getLocIso(-w/2, -d/2);
            const p_right = getLocIso(w/2, -d/2);
            const p_bottom = getLocIso(w/2, d/2);
            const p_left = getLocIso(-w/2, d/2);

            twCtx.fillStyle = twLighten(color, 15); twCtx.beginPath(); twCtx.moveTo(p_top.x, p_top.y); twCtx.lineTo(p_right.x, p_right.y); twCtx.lineTo(p_bottom.x, p_bottom.y); twCtx.lineTo(p_left.x, p_left.y); twCtx.closePath(); twCtx.fill();
            twCtx.fillStyle = twDarken(color, 10); twCtx.beginPath(); twCtx.moveTo(p_right.x, p_right.y); twCtx.lineTo(p_bottom.x, p_bottom.y); twCtx.lineTo(p_bottom.x, p_bottom.y + TW_BLOCK_HEIGHT); twCtx.lineTo(p_right.x, p_right.y + TW_BLOCK_HEIGHT); twCtx.closePath(); twCtx.fill();
            twCtx.fillStyle = twDarken(color, 25); twCtx.beginPath(); twCtx.moveTo(p_left.x, p_left.y); twCtx.lineTo(p_bottom.x, p_bottom.y); twCtx.lineTo(p_bottom.x, p_bottom.y + TW_BLOCK_HEIGHT); twCtx.lineTo(p_left.x, p_left.y + TW_BLOCK_HEIGHT); twCtx.closePath(); twCtx.fill();
            twCtx.strokeStyle = "rgba(255,255,255,0.4)"; twCtx.lineWidth = 1; twCtx.beginPath(); twCtx.moveTo(p_top.x, p_top.y); twCtx.lineTo(p_right.x, p_right.y); twCtx.lineTo(p_bottom.x, p_bottom.y); twCtx.lineTo(p_left.x, p_left.y); twCtx.closePath(); twCtx.stroke();
        }

        function twDrawIsoBlock(cx, cy, x, z, w, d, yLevel, color, highlight) {
            const isoX = (x - z);
            const isoY = (x + z) * 0.5;
            const screenX = cx + isoX;
            const screenY = cy + isoY - yLevel + twCameraY;

            const p_top = twGetIsoPoint(screenX, screenY, -w/2, -d/2);
            const p_right = twGetIsoPoint(screenX, screenY, w/2, -d/2);
            const p_bottom = twGetIsoPoint(screenX, screenY, w/2, d/2);
            const p_left = twGetIsoPoint(screenX, screenY, -w/2, d/2);

            twCtx.fillStyle = twLighten(color, 15); twCtx.beginPath(); twCtx.moveTo(p_top.x, p_top.y); twCtx.lineTo(p_right.x, p_right.y); twCtx.lineTo(p_bottom.x, p_bottom.y); twCtx.lineTo(p_left.x, p_left.y); twCtx.closePath(); twCtx.fill();
            twCtx.fillStyle = twDarken(color, 10); twCtx.beginPath(); twCtx.moveTo(p_right.x, p_right.y); twCtx.lineTo(p_bottom.x, p_bottom.y); twCtx.lineTo(p_bottom.x, p_bottom.y + TW_BLOCK_HEIGHT); twCtx.lineTo(p_right.x, p_right.y + TW_BLOCK_HEIGHT); twCtx.closePath(); twCtx.fill();
            twCtx.fillStyle = twDarken(color, 25); twCtx.beginPath(); twCtx.moveTo(p_left.x, p_left.y); twCtx.lineTo(p_bottom.x, p_bottom.y); twCtx.lineTo(p_bottom.x, p_bottom.y + TW_BLOCK_HEIGHT); twCtx.lineTo(p_left.x, p_left.y + TW_BLOCK_HEIGHT); twCtx.closePath(); twCtx.fill();
            twCtx.strokeStyle = "rgba(255,255,255,0.4)"; twCtx.lineWidth = 1; twCtx.beginPath(); twCtx.moveTo(p_top.x, p_top.y); twCtx.lineTo(p_right.x, p_right.y); twCtx.lineTo(p_bottom.x, p_bottom.y); twCtx.lineTo(p_left.x, p_left.y); twCtx.closePath(); twCtx.stroke();

            // Perfect match glow effect
            if(highlight) {
                twCtx.save();
                twCtx.globalAlpha = twPerfectMatchAlpha;
                twCtx.strokeStyle = "#ffffff";
                twCtx.lineWidth = 3;
                twCtx.shadowColor = "#ffffff";
                twCtx.shadowBlur = 15;
                twCtx.beginPath();
                twCtx.moveTo(p_left.x, p_left.y + TW_BLOCK_HEIGHT);
                twCtx.lineTo(p_bottom.x, p_bottom.y + TW_BLOCK_HEIGHT);
                twCtx.lineTo(p_right.x, p_right.y + TW_BLOCK_HEIGHT);
                twCtx.stroke();
                twCtx.restore();
            }
        }
        
        function twGetIsoPoint(cx, cy, dx, dz) {
            return { x: cx + (dx - dz), y: cy + (dx + dz) * 0.5 - TW_BLOCK_HEIGHT };
        }

        function twGetHSL(h) { return `hsl(${Math.floor(h % 360)}, 75%, ${isDark ? 60 : 55}%)`; }
        function twLighten(hsl, amt) { return twAdjustLight(hsl, amt); }
        function twDarken(hsl, amt) { return twAdjustLight(hsl, -amt); }
        function twAdjustLight(hsl, amt) {
            const parts = hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
            if(!parts) return hsl;
            let l = Math.max(0, Math.min(100, parseInt(parts[3]) + amt));
            return `hsl(${parts[1]}, ${parts[2]}%, ${l}%)`;
        }

        // Start App
        initApp();
    </script>
</body>
</html>
