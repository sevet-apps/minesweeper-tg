<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tower Stack</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root {
            --bg-light: #f2f2f7;
            --bg-dark: #000000;
            --text-light: #000000;
            --text-dark: #ffffff;
            --accent: #007aff;
            --glass-bg: rgba(255, 255, 255, 0.85);
            --glass-border: rgba(255, 255, 255, 0.5);
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: var(--bg-light);
            color: var(--text-light);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body.dark-mode {
            background-color: var(--bg-dark);
            color: var(--text-dark);
            --glass-bg: rgba(30, 30, 30, 0.85);
            --glass-border: rgba(255, 255, 255, 0.1);
        }
        
        #game-background {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(0,0,0,0.05) 100%);
            pointer-events: none;
            z-index: -1;
        }
        body.dark-mode #game-background {
            background: linear-gradient(180deg, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.3) 100%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1;
        }

        /* --- UI LAYER --- */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #score {
            position: absolute;
            top: 12%;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 100px;
            font-weight: 100;
            color: var(--text-light);
            opacity: 0.15;
            font-feature-settings: "tnum";
            transition: transform 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
        }
        body.dark-mode #score { color: var(--text-dark); opacity: 0.2; }
        #score.bump { transform: scale(1.15); opacity: 0.3; }

        #start-msg {
            position: absolute;
            bottom: 15%;
            width: 100%;
            text-align: center;
            font-size: 17px;
            font-weight: 500;
            color: var(--accent);
            opacity: 0.8;
            animation: pulse 2s infinite;
        }

        /* Модальное окно */
        #game-over-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 100;
        }
        #game-over-modal.visible { opacity: 1; pointer-events: auto; }
        
        .card {
            background: var(--glass-bg);
            padding: 30px 20px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
            border: 1px solid var(--glass-border);
            
            /* ИСПРАВЛЕНИЕ 1: Ширина окна меньше (70%) */
            width: 70%;
            max-width: 280px;
            
            transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #game-over-modal.visible .card { transform: scale(1); }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 14px;
            font-size: 17px;
            font-weight: 600;
            margin-top: 20px;
            cursor: pointer;
            width: 100%;
            transition: transform 0.1s, opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
        }
        .btn:active { opacity: 0.8; transform: scale(0.96); }
        
        /* Иконка короны для рекорда */
        .crown-icon {
            width: 40px; height: 40px; 
            fill: #FFD700; 
            margin-bottom: 10px;
            display: none; /* Скрыта по умолчанию */
        }

        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.5; transform: scale(0.98); }
        }
    </style>
</head>
<body>

    <div id="game-background"></div>

    <div class="ui-layer">
        <div id="score">0</div>
        <div id="start-msg">Нажми, чтобы начать</div>
    </div>

    <div id="game-over-modal">
        <div class="card">
            <svg id="crown" class="crown-icon" viewBox="0 0 24 24"><path d="M5 16L3 5l5.5 5L12 4l3.5 6L21 5l-2 11H5zm14 3c0 .6-.4 1-1 1H6c-.6 0-1-.4-1-1v-1h14v1z"/></svg>
            <h2 id="go-title" style="margin: 0 0 5px; font-weight: 800; font-size: 22px;">Игра окончена</h2>
            <div id="go-subtitle" style="font-size: 14px; color: #8e8e93; margin-bottom: 10px;">Ваш результат</div>
            <div id="final-score" style="font-size: 56px; font-weight: 200; color: var(--text-light); line-height: 1;">0</div>
            <button class="btn" onclick="restartGame()">Играть снова</button>
        </div>
    </div>

    <canvas id="canvas"></canvas>

<script>
    const tg = window.Telegram.WebApp;
    tg.expand();
    const isDark = tg.colorScheme === 'dark';
    if(isDark) document.body.classList.add('dark-mode');

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const startMsg = document.getElementById('start-msg');
    const modal = document.getElementById('game-over-modal');
    const finalScoreEl = document.getElementById('final-score');
    const goTitle = document.getElementById('go-title');
    const goSub = document.getElementById('go-subtitle');
    const crown = document.getElementById('crown');

    let blocks = [];
    let debris = []; 
    let score = 0;
    let state = 'start'; 
    let hue = 0; 
    let cameraY = 0; 
    
    let currentBlock = null;
    let direction = 'x'; 
    let speed = 3.0;
    
    // Получаем лучший результат из памяти (для теста)
    let bestScore = parseInt(localStorage.getItem('tower_best') || 0);

    const BLOCK_HEIGHT = 35; 
    const BASE_SIZE = 130; 
    
    function resize() {
        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }
    window.addEventListener('resize', resize);
    resize();

    function startGame() {
        blocks = [];
        debris = [];
        score = 0;
        speed = 3.0;
        direction = 'x';
        hue = Math.floor(Math.random() * 360);
        state = 'playing';
        cameraY = 0;
        
        scoreEl.innerText = score;
        startMsg.style.display = 'none';
        modal.classList.remove('visible');

        addBlock({
            x: 0,
            z: 0,
            w: BASE_SIZE,
            d: BASE_SIZE,
            color: getHSL(hue)
        });

        spawnNextBlock();
        loop();
    }

    function addBlock(block) {
        blocks.push(block);
    }

    function spawnNextBlock() {
        const prev = blocks[blocks.length - 1];
        hue += 6; 
        direction = direction === 'x' ? 'z' : 'x'; 
        const dist = 350;
        
        currentBlock = {
            x: direction === 'x' ? -dist : prev.x,
            z: direction === 'z' ? -dist : prev.z,
            w: prev.w,
            d: prev.d,
            color: getHSL(hue),
            moveDir: 1 
        };
    }

    function updatePhysics() {
        if (state !== 'playing' || !currentBlock) return;
        const limit = 360;
        
        if (direction === 'x') {
            currentBlock.x += speed * currentBlock.moveDir;
            if (currentBlock.x > limit) currentBlock.moveDir = -1;
            if (currentBlock.x < -limit) currentBlock.moveDir = 1;
        } else {
            currentBlock.z += speed * currentBlock.moveDir;
            if (currentBlock.z > limit) currentBlock.moveDir = -1;
            if (currentBlock.z < -limit) currentBlock.moveDir = 1;
        }

        const targetY = (blocks.length * BLOCK_HEIGHT) - 150;
        if(targetY > 0) cameraY += (targetY - cameraY) * 0.05;
    }

    function handleAction(e) {
        if (e) e.preventDefault(); 
        if (state === 'start' || state === 'gameover') {
            if(state === 'start') startGame();
            return;
        }
        placeBlock();
    }

    // --- ГЛАВНОЕ ИСПРАВЛЕНИЕ ЛОГИКИ РЕЗКИ ---
    function placeBlock() {
        if (!currentBlock) return;
        const prev = blocks[blocks.length - 1];
        let diff;
        
        if (direction === 'x') diff = currentBlock.x - prev.x;
        else diff = currentBlock.z - prev.z;

        // ШАГ 1: Сначала проверяем на Идеальное Совпадение (threshold 4px)
        // Если попали идеально - НЕ РЕЖЕМ, а примагничиваем
        if (Math.abs(diff) < 4) {
            currentBlock.x = prev.x;
            currentBlock.z = prev.z;
            currentBlock.w = prev.w;
            currentBlock.d = prev.d;
            
            scoreEl.classList.add('bump');
            setTimeout(() => scoreEl.classList.remove('bump'), 150);
            tg.HapticFeedback.notificationOccurred('success');
            
            // Сразу добавляем блок без резки
            commitBlock();
            return;
        }

        // ШАГ 2: Если не идеально, тогда вычисляем резку
        let overlap;
        let cutSize;
        let isGameOver = false;

        if (direction === 'x') {
            overlap = prev.w - Math.abs(diff);
            if (overlap > 0) {
                cutSize = Math.abs(diff);
                currentBlock.w = overlap; 
                
                if (diff > 0) { 
                    currentBlock.x = prev.x + (diff / 2);
                    addDebris(currentBlock.x + (overlap/2) + (cutSize/2), currentBlock.z, cutSize, currentBlock.d);
                } else {
                    currentBlock.x = prev.x + (diff / 2);
                    addDebris(currentBlock.x - (overlap/2) - (cutSize/2), currentBlock.z, cutSize, currentBlock.d);
                }
            } else isGameOver = true;
        } else { 
            overlap = prev.d - Math.abs(diff);
            if (overlap > 0) {
                cutSize = Math.abs(diff);
                currentBlock.d = overlap; 
                if (diff > 0) {
                    currentBlock.z = prev.z + (diff / 2);
                    addDebris(currentBlock.x, currentBlock.z + (overlap/2) + (cutSize/2), currentBlock.w, cutSize);
                } else {
                    currentBlock.z = prev.z + (diff / 2);
                    addDebris(currentBlock.x, currentBlock.z - (overlap/2) - (cutSize/2), currentBlock.w, cutSize);
                }
            } else isGameOver = true;
        }

        if (isGameOver) {
            addDebris(currentBlock.x, currentBlock.z, currentBlock.w, currentBlock.d);
            gameOver();
        } else {
            tg.HapticFeedback.impactOccurred('light');
            commitBlock();
        }
    }

    function commitBlock() {
        addBlock(currentBlock);
        score++;
        scoreEl.innerText = score;
        speed += 0.02; 
        spawnNextBlock();
    }

    function addDebris(x, z, w, d) {
        debris.push({
            x: x, z: z, w: w, d: d,
            color: currentBlock.color,
            vy: 0,
            yOffset: 0, 
            alpha: 1
        });
    }

    // --- ИСПРАВЛЕНИЕ 2: Рекорд и Конфетти ---
    function gameOver() {
        state = 'gameover';
        tg.HapticFeedback.notificationOccurred('error');
        finalScoreEl.innerText = score;
        
        let isRecord = false;
        if(score > bestScore) {
            bestScore = score;
            localStorage.setItem('tower_best', bestScore);
            isRecord = true;
        }

        if(isDark) finalScoreEl.style.color = '#ffffff';
        else finalScoreEl.style.color = '#000000';

        if(isRecord && score > 0) {
            goTitle.innerText = "Новый рекорд!";
            goSub.innerText = "Вы построили огромную башню!";
            crown.style.display = "block";
            finalScoreEl.style.color = "var(--accent)";
            
            // Запуск конфетти
            confetti({
                particleCount: 150,
                spread: 70,
                origin: { y: 0.6 },
                zIndex: 20000
            });
        } else {
            goTitle.innerText = "Игра окончена";
            goSub.innerText = `Лучший: ${bestScore}`;
            crown.style.display = "none";
        }

        modal.classList.add('visible');
    }

    function restartGame() {
        startGame();
    }

    function loop() {
        if(state === 'gameover' && debris.length === 0) return;
        requestAnimationFrame(loop);
        updatePhysics();
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        const cx = window.innerWidth / 2;
        const cy = window.innerHeight / 1.5; 

        blocks.forEach((b, i) => {
            const stackY = i * BLOCK_HEIGHT; 
            drawIsoBlock(cx, cy, b.x, b.z, b.w, b.d, stackY, b.color);
        });

        if (currentBlock && state === 'playing') {
            const stackY = blocks.length * BLOCK_HEIGHT;
            drawIsoBlock(cx, cy, currentBlock.x, currentBlock.z, currentBlock.w, currentBlock.d, stackY, currentBlock.color);
        }

        debris.forEach((d, i) => {
            d.vy += 1; 
            d.yOffset -= d.vy;
            d.alpha -= 0.03; 
            const stackY = (blocks.length) * BLOCK_HEIGHT + d.yOffset;
            if (d.alpha <= 0) debris.splice(i, 1);
            else {
                ctx.globalAlpha = d.alpha;
                drawIsoBlock(cx, cy, d.x, d.z, d.w, d.d, stackY, d.color);
                ctx.globalAlpha = 1;
            }
        });
    }

    function drawIsoBlock(cx, cy, x, z, w, d, yLevel, color) {
        const isoX = (x - z);
        const isoY = (x + z) * 0.5;
        const screenX = cx + isoX;
        const screenY = cy + isoY - yLevel + cameraY;

        const p_top = getIsoPoint(screenX, screenY, -w/2, -d/2);
        const p_right = getIsoPoint(screenX, screenY, w/2, -d/2);
        const p_bottom = getIsoPoint(screenX, screenY, w/2, d/2);
        const p_left = getIsoPoint(screenX, screenY, -w/2, d/2);

        ctx.fillStyle = lighten(color, 15);
        ctx.beginPath(); ctx.moveTo(p_top.x, p_top.y); ctx.lineTo(p_right.x, p_right.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_left.x, p_left.y); ctx.closePath(); ctx.fill();

        ctx.fillStyle = darken(color, 10);
        ctx.beginPath(); ctx.moveTo(p_right.x, p_right.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_bottom.x, p_bottom.y + BLOCK_HEIGHT); ctx.lineTo(p_right.x, p_right.y + BLOCK_HEIGHT); ctx.closePath(); ctx.fill();

        ctx.fillStyle = darken(color, 25);
        ctx.beginPath(); ctx.moveTo(p_left.x, p_left.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_bottom.x, p_bottom.y + BLOCK_HEIGHT); ctx.lineTo(p_left.x, p_left.y + BLOCK_HEIGHT); ctx.closePath(); ctx.fill();
        
        ctx.strokeStyle = "rgba(255,255,255,0.4)";
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(p_top.x, p_top.y); ctx.lineTo(p_right.x, p_right.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_left.x, p_left.y); ctx.closePath(); ctx.stroke();
    }
    
    function getIsoPoint(cx, cy, dx, dz) {
        return { x: cx + (dx - dz), y: cy + (dx + dz) * 0.5 - BLOCK_HEIGHT };
    }

    function getHSL(h) { return `hsl(${Math.floor(h % 360)}, 75%, ${isDark ? 60 : 55}%)`; }
    function lighten(hsl, amt) { return adjustLight(hsl, amt); }
    function darken(hsl, amt) { return adjustLight(hsl, -amt); }
    function adjustLight(hsl, amt) {
        const parts = hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
        if(!parts) return hsl;
        let l = Math.max(0, Math.min(100, parseInt(parts[3]) + amt));
        return `hsl(${parts[1]}, ${parts[2]}%, ${l}%)`;
    }

    document.addEventListener('pointerdown', handleAction);
    document.addEventListener('keydown', (e) => { if(e.code === 'Space') handleAction(e); });

</script>
</body>
</html>
