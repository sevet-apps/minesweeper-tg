<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tower Stack</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root { --bg: #f2f2f7; --text: #000; --accent: #007aff; --glass: rgba(255,255,255,0.85); --border: rgba(255,255,255,0.5); }
        body.dark-mode { --bg: #000; --text: #fff; --glass: rgba(30,30,30,0.85); --border: rgba(255,255,255,0.1); }
        body { margin: 0; overflow: hidden; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        #bg { position: absolute; inset: 0; background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.05) 100%); z-index: -1; pointer-events: none; }
        body.dark-mode #bg { background: linear-gradient(180deg, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.3) 100%); }
        
        canvas { display: block; width: 100%; height: 100%; cursor: pointer; }
        .ui, #modal { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .ui { justify-content: flex-start; }
        
        #score { margin-top: 10vh; font-size: 80px; font-weight: 800; color: var(--accent); transition: transform .15s, color .5s; text-shadow: 0 4px 20px rgba(0,0,0,0.1); font-variant-numeric: tabular-nums; }
        #score.bump { transform: scale(1.2); }
        
        /* ИЗМЕНЕНИЕ: Текст стал больше (24px) и чуть выше */
        #msg { position: absolute; bottom: 20%; font-size: 24px; font-weight: 700; color: var(--accent); opacity: .9; animation: p 2s infinite; text-transform: uppercase; letter-spacing: 1px; }
        
        #modal { background: rgba(0,0,0,0.3); backdrop-filter: blur(10px); opacity: 0; transition: opacity .3s; z-index: 100; }
        #modal.v { opacity: 1; pointer-events: auto; }
        .card { background: var(--glass); padding: 30px 20px; border-radius: 24px; text-align: center; border: 1px solid var(--border); width: 70%; max-width: 280px; transform: scale(0.95); transition: transform .3s; }
        #modal.v .card { transform: scale(1); }
        
        .btn { background: var(--accent); color: #fff; border: none; padding: 12px 20px; border-radius: 14px; font-size: 17px; font-weight: 600; margin-top: 20px; width: 100%; cursor: pointer; }
        .btn:active { opacity: .8; transform: scale(.96); }
        .crown { width: 40px; height: 40px; fill: #fff; margin: 0 auto 10px; display: none; }
        @keyframes p { 0%, 100% { opacity: .5; transform: scale(.98); } 50% { opacity: 1; transform: scale(1.02); } }
    </style>
</head>
<body>
    <div id="bg"></div>
    <div class="ui"><div id="score">0</div><div id="msg">Нажми, чтобы начать</div></div>
    <div id="modal">
        <div class="card">
            <svg id="crown" class="crown" viewBox="0 0 24 24"><path d="M5 16L3 5l5.5 5L12 4l3.5 6L21 5l-2 11H5zm14 3c0 .6-.4 1-1 1H6c-.6 0-1-.4-1-1v-1h14v1z"/></svg>
            <h2 id="go-title" style="margin:0 0 5px; font-weight:800; font-size:22px;"></h2>
            <div style="font-size:14px; color:#8e8e93; margin-bottom:10px;">Результат</div>
            <div id="final" style="font-size:56px; font-weight:200; line-height:1;">0</div>
            <button class="btn" onclick="init()">Играть снова</button>
        </div>
    </div>
    <canvas id="c"></canvas>

<script>
    const tg = window.Telegram.WebApp; tg.expand();
    const isDark = tg.colorScheme === 'dark';
    if(isDark) document.body.classList.add('dark-mode');

    const cvs = document.getElementById('c'), ctx = cvs.getContext('2d');
    const els = { score: document.getElementById('score'), msg: document.getElementById('msg'), modal: document.getElementById('modal'), final: document.getElementById('final'), crown: document.getElementById('crown'), title: document.getElementById('go-title') };
    
    // Config
    const CFG = { h: 35, base: 130, dist: 350 };
    let game = { blocks: [], debris: [], score: 0, state: 'start', hue: 0, camY: 0, perf: 0, curr: null, dir: 'x', speed: 3.0 };
    let best = parseInt(localStorage.getItem('tower_best') || 0);

    const resize = () => {
        cvs.width = window.innerWidth * window.devicePixelRatio;
        cvs.height = window.innerHeight * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    };
    window.onresize = resize; resize();

    function init() {
        game = { blocks: [], debris: [], score: 0, state: 'play', hue: Math.random()*360, camY: 0, perf: 0, curr: null, dir: 'x', speed: 3.0 };
        els.score.innerText = 0; els.score.style.color = 'var(--accent)';
        els.msg.style.display = 'none'; els.modal.classList.remove('v');
        
        game.blocks.push({ x: 0, z: 0, w: CFG.base, d: CFG.base, c: hsl(game.hue) });
        spawn(); loop();
    }

    function spawn() {
        const prev = game.blocks[game.blocks.length - 1];
        game.hue += 6; game.dir = game.dir === 'x' ? 'z' : 'x';
        const c = hsl(game.hue);
        els.score.style.color = c;
        game.curr = { 
            x: game.dir === 'x' ? -CFG.dist : prev.x, 
            z: game.dir === 'z' ? -CFG.dist : prev.z, 
            w: prev.w, d: prev.d, c: c, m: 1 
        };
    }

    function action(e) {
        if(e) e.preventDefault();
        if (game.state !== 'play') return game.state === 'start' ? init() : null;
        
        const { curr: c, dir } = game;
        const prev = game.blocks[game.blocks.length - 1];
        const diff = c[dir] - prev[dir];
        
        // Perfect Match
        if (Math.abs(diff) < 4) {
            c.x = prev.x; c.z = prev.z;
            game.perf = 1; commit();
            els.score.classList.add('bump'); setTimeout(() => els.score.classList.remove('bump'), 150);
            tg.HapticFeedback.notificationOccurred('success');
            return;
        }

        const isX = dir === 'x';
        const size = isX ? prev.w : prev.d;
        const overlap = size - Math.abs(diff);

        if (overlap > 0) {
            const cut = Math.abs(diff);
            c[isX?'w':'d'] = overlap;
            c[dir] = prev[dir] + diff / 2;
            
            // PHYSICS CORRECTION:
            // sign = 1 (перелет, режем спереди) или -1 (недолет, режем сзади)
            const sign = diff > 0 ? 1 : -1;
            
            // Позиция обломка: центр оставшегося блока + (половина остатка + половина среза) * направление
            const dbX = isX ? c.x + (overlap/2 + cut/2)*sign : c.x;
            const dbZ = !isX ? c.z + (overlap/2 + cut/2)*sign : c.z;
            
            // Скорость: Строго по направлению среза (sign)
            // Увеличили силу до 3.5 для четкого отлета
            addDebris(dbX, dbZ, isX?cut:c.w, !isX?cut:c.d, isX?sign*3.5:0, !isX?sign*3.5:0, sign);
            
            tg.HapticFeedback.impactOccurred('light');
            commit();
        } else {
            // Game Over - летит по инерции движения (c.m)
            addDebris(c.x, c.z, c.w, c.d, isX?c.m*3:0, !isX?c.m*3:0, diff < 0 ? -1 : 1);
            over();
        }
    }

    function commit() {
        game.blocks.push(game.curr);
        game.score++; els.score.innerText = game.score;
        game.speed += 0.02; spawn();
    }

    function addDebris(x, z, w, d, vx, vz, sign) {
        // Вращение теперь зависит от знака (скатывается с края)
        const va = sign * (0.05 + Math.random() * 0.05);
        game.debris.push({ 
            x, z, w, d, c: game.curr.c, vx, vz, vy: 0, 
            y: 0, a: 0, va: va, alp: 1, 
            behind: (vx < 0 && vz === 0) || (vz < 0 && vx === 0) // Определяем Z-index (сзади или спереди)
        });
    }

    function loop() {
        if (game.state === 'over' && !game.debris.length && game.perf <= 0) return;
        requestAnimationFrame(loop);
        
        // Update Physics
        if (game.curr && game.state === 'play') {
            const limit = 360;
            game.curr[game.dir] += game.speed * game.curr.m;
            if (game.curr[game.dir] > limit) game.curr.m = -1;
            else if (game.curr[game.dir] < -limit) game.curr.m = 1;
        }
        const ty = (game.blocks.length * CFG.h) - 150;
        if (ty > 0) game.camY += (ty - game.camY) * 0.05;
        if (game.perf > 0) game.perf -= 0.05;

        // Draw
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        const cx = window.innerWidth / 2, cy = window.innerHeight / 1.5;

        const draw = (b, yOff, rot, isGlow) => {
            if (b.alp <= 0) return;
            ctx.globalAlpha = b.alp || 1;
            
            let sx = cx + (b.x - b.z), sy = cy + (b.x + b.z) * 0.5 - yOff + game.camY;
            if (rot) { 
                ctx.save();
                ctx.translate(sx, sy - CFG.h/2); ctx.rotate(b.a);
                sx = 0; sy = -CFG.h/2; 
            }

            const p = (dx, dz) => ({ x: sx + (dx - dz), y: sy + (dx + dz) * 0.5 - CFG.h });
            const pts = [p(-b.w/2, -b.d/2), p(b.w/2, -b.d/2), p(b.w/2, b.d/2), p(-b.w/2, b.d/2)];
            
            const face = (idx, c) => {
                ctx.fillStyle = c; ctx.beginPath();
                if(idx===0) { ctx.moveTo(pts[0].x,pts[0].y); ctx.lineTo(pts[1].x,pts[1].y); ctx.lineTo(pts[2].x,pts[2].y); ctx.lineTo(pts[3].x,pts[3].y); }
                else if(idx===1) { ctx.moveTo(pts[1].x,pts[1].y); ctx.lineTo(pts[2].x,pts[2].y); ctx.lineTo(pts[2].x,pts[2].y+CFG.h); ctx.lineTo(pts[1].x,pts[1].y+CFG.h); }
                else { ctx.moveTo(pts[3].x,pts[3].y); ctx.lineTo(pts[2].x,pts[2].y); ctx.lineTo(pts[2].x,pts[2].y+CFG.h); ctx.lineTo(pts[3].x,pts[3].y+CFG.h); }
                ctx.fill();
            };

            face(0, lighten(b.c, 15)); 
            face(1, darken(b.c, 10));  
            face(2, darken(b.c, 25));  
            
            ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y); ctx.lineTo(pts[1].x,pts[1].y); ctx.lineTo(pts[2].x,pts[2].y); ctx.lineTo(pts[3].x,pts[3].y); ctx.closePath(); ctx.stroke();

            if (isGlow) {
                ctx.save(); ctx.globalAlpha = game.perf; ctx.strokeStyle = "#fff"; ctx.lineWidth = 3; ctx.shadowColor = "#fff"; ctx.shadowBlur = 15;
                ctx.beginPath(); ctx.moveTo(pts[3].x, pts[3].y+CFG.h); ctx.lineTo(pts[2].x, pts[2].y+CFG.h); ctx.lineTo(pts[1].x, pts[1].y+CFG.h); ctx.stroke(); ctx.restore();
            }
            if (rot) ctx.restore();
            ctx.globalAlpha = 1;
        };

        // Render Order (Back Debris -> Tower -> Current -> Front Debris)
        game.debris.forEach(d => { if(d.behind) updDebris(d); draw(d, (game.blocks.length*CFG.h)+d.y, true); }); 
        game.blocks.forEach((b, i) => draw(b, i*CFG.h, false, i===game.blocks.length-1 && game.perf>0)); 
        if (game.curr && game.state === 'play') draw(game.curr, game.blocks.length*CFG.h, false); 
        game.debris.forEach(d => { if(!d.behind) updDebris(d); draw(d, (game.blocks.length*CFG.h)+d.y, true); }); 
        game.debris = game.debris.filter(d => d.alp > 0);
    }

    function updDebris(d) {
        d.vy += 0.5; d.y -= d.vy; d.x += d.vx; d.z += d.vz; d.a += d.va; d.alp -= 0.015;
    }

    function over() {
        game.state = 'over'; tg.HapticFeedback.notificationOccurred('error');
        els.final.innerText = game.score; els.final.style.color = isDark?'#fff':'#000';
        
        const isRec = game.score > best;
        if(isRec) { best = game.score; localStorage.setItem('tower_best', best); }
        
        els.title.innerText = isRec && game.score > 0 ? "Новый рекорд!" : "Игра окончена";
        els.crown.style.display = isRec && game.score > 0 ? "block" : "none";
        if(isRec && game.score > 0) {
            els.final.style.color = "var(--accent)";
            confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 }, zIndex: 200 });
        }
        els.modal.classList.add('v');
    }

    const hsl = h => `hsl(${h|0},75%,${isDark?60:55}%)`;
    const modL = (c, a) => c.replace(/(\d+)%\)/, (m, l) => Math.max(0, Math.min(100, +l+a)) + "%)");
    const lighten = (c, a) => modL(c, a);
    const darken = (c, a) => modL(c, -a);

    document.onpointerdown = action; document.onkeydown = e => e.code==='Space'&&action(e);
</script>
</body>
</html>
