<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tower Stack</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root {
            --bg-light: #f2f2f7;
            --bg-dark: #000000;
            --text-light: #000000;
            --text-dark: #ffffff;
            --accent: #007aff; /* Ваш фирменный синий цвет */
            --glass-bg: rgba(255, 255, 255, 0.8);
            --glass-border: rgba(255, 255, 255, 0.5);
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: var(--bg-light);
            color: var(--text-light);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body.dark-mode {
            background-color: var(--bg-dark);
            color: var(--text-dark);
            --glass-bg: rgba(30, 30, 30, 0.8);
            --glass-border: rgba(255, 255, 255, 0.1);
        }
        
        #game-background {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(0,0,0,0.05) 100%);
            pointer-events: none;
            z-index: -1;
        }
        body.dark-mode #game-background {
            background: linear-gradient(180deg, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.3) 100%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1;
        }

        /* --- UI LAYER --- */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Эстетичный счетчик */
        #score {
            position: absolute;
            top: 10%;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 120px; /* Очень крупный */
            font-weight: 100; /* Очень тонкий (iOS Style) */
            color: var(--text-light);
            opacity: 0.15; /* Полупрозрачный, как водяной знак */
            font-feature-settings: "tnum"; /* Моноширинные цифры, чтобы не прыгали */
            transition: transform 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
        }
        body.dark-mode #score {
            color: var(--text-dark);
            opacity: 0.2;
        }
        #score.bump { transform: scale(1.1); opacity: 0.3; }

        #start-msg {
            position: absolute;
            bottom: 15%;
            width: 100%;
            text-align: center;
            font-size: 17px;
            font-weight: 500;
            color: var(--accent);
            opacity: 0.8;
            animation: pulse 2s infinite;
        }

        /* Модальное окно (Glassmorphism) */
        #game-over-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.2);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 100;
        }
        #game-over-modal.visible { opacity: 1; pointer-events: auto; }
        
        .card {
            background: var(--glass-bg);
            padding: 30px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
            border: 1px solid var(--glass-border);
            width: 85%;
            max-width: 320px;
            transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #game-over-modal.visible .card { transform: scale(1); }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 14px;
            font-size: 17px;
            font-weight: 600;
            margin-top: 25px;
            cursor: pointer;
            width: 100%;
            transition: transform 0.1s, opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
        }
        .btn:active { opacity: 0.8; transform: scale(0.96); }

        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.5; transform: scale(0.98); }
        }
    </style>
</head>
<body>

    <div id="game-background"></div>

    <div class="ui-layer">
        <div id="score">0</div>
        <div id="start-msg">Нажми, чтобы начать</div>
    </div>

    <div id="game-over-modal">
        <div class="card">
            <h2 style="margin: 0 0 5px; font-weight: 800;">Игра окончена</h2>
            <div style="font-size: 14px; color: #8e8e93; margin-bottom: 10px;">Ваш результат</div>
            <div id="final-score" style="font-size: 64px; font-weight: 200; color: var(--text-light); line-height: 1;">0</div>
            <button class="btn" onclick="restartGame()">Играть снова</button>
        </div>
    </div>

    <canvas id="canvas"></canvas>

<script>
    // --- ИНИЦИАЛИЗАЦИЯ TELEGRAM ---
    const tg = window.Telegram.WebApp;
    tg.expand();
    
    const isDark = tg.colorScheme === 'dark';
    if(isDark) document.body.classList.add('dark-mode');

    // --- НАСТРОЙКИ КАНВАСА ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // UI элементы
    const scoreEl = document.getElementById('score');
    const startMsg = document.getElementById('start-msg');
    const modal = document.getElementById('game-over-modal');
    const finalScoreEl = document.getElementById('final-score');

    // --- ПЕРЕМЕННЫЕ ИГРЫ ---
    let blocks = [];
    let debris = []; 
    let score = 0;
    let state = 'start'; 
    let hue = 0; 
    let cameraY = 0; 
    
    let currentBlock = null;
    let direction = 'x'; 
    let speed = 3.0; // Начальная скорость (чуть медленнее, было 3.5)
    
    const BLOCK_HEIGHT = 35; 
    const BASE_SIZE = 130; 
    
    function resize() {
        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }
    window.addEventListener('resize', resize);
    resize();

    // --- ЛОГИКА ---

    function startGame() {
        blocks = [];
        debris = [];
        score = 0;
        speed = 3.0; // Сброс скорости
        direction = 'x';
        hue = Math.floor(Math.random() * 360);
        state = 'playing';
        cameraY = 0;
        
        scoreEl.innerText = score;
        startMsg.style.display = 'none';
        modal.classList.remove('visible');

        addBlock({
            x: 0,
            z: 0,
            w: BASE_SIZE,
            d: BASE_SIZE,
            color: getHSL(hue)
        });

        spawnNextBlock();
        loop();
    }

    function addBlock(block) {
        blocks.push(block);
    }

    function spawnNextBlock() {
        const prev = blocks[blocks.length - 1];
        hue += 6; 
        direction = direction === 'x' ? 'z' : 'x'; 
        
        const dist = 350;
        
        currentBlock = {
            x: direction === 'x' ? -dist : prev.x,
            z: direction === 'z' ? -dist : prev.z,
            w: prev.w,
            d: prev.d,
            color: getHSL(hue),
            moveDir: 1 
        };
    }

    function updatePhysics() {
        if (state !== 'playing' || !currentBlock) return;

        const limit = 360;
        
        if (direction === 'x') {
            currentBlock.x += speed * currentBlock.moveDir;
            if (currentBlock.x > limit) currentBlock.moveDir = -1;
            if (currentBlock.x < -limit) currentBlock.moveDir = 1;
        } else {
            currentBlock.z += speed * currentBlock.moveDir;
            if (currentBlock.z > limit) currentBlock.moveDir = -1;
            if (currentBlock.z < -limit) currentBlock.moveDir = 1;
        }

        const targetY = (blocks.length * BLOCK_HEIGHT) - 150;
        if(targetY > 0) {
            cameraY += (targetY - cameraY) * 0.05;
        }
    }

    function handleAction(e) {
        if (e) e.preventDefault(); 

        if (state === 'start' || state === 'gameover') {
            if(state === 'start') startGame();
            return;
        }

        placeBlock();
    }

    function placeBlock() {
        if (!currentBlock) return;

        const prev = blocks[blocks.length - 1];
        
        let diff;
        let overlap; 
        let cutSize; 
        let isGameOver = false;

        if (direction === 'x') {
            diff = currentBlock.x - prev.x;
            overlap = prev.w - Math.abs(diff);
            
            if (overlap > 0) {
                cutSize = Math.abs(diff);
                currentBlock.w = overlap; 
                
                if (diff > 0) { 
                    currentBlock.x = prev.x + (diff / 2);
                    addDebris(currentBlock.x + (overlap/2) + (cutSize/2), currentBlock.z, cutSize, currentBlock.d);
                } else {
                    currentBlock.x = prev.x + (diff / 2);
                    addDebris(currentBlock.x - (overlap/2) - (cutSize/2), currentBlock.z, cutSize, currentBlock.d);
                }
            } else {
                isGameOver = true;
            }
        } else { 
            diff = currentBlock.z - prev.z;
            overlap = prev.d - Math.abs(diff);
            
            if (overlap > 0) {
                cutSize = Math.abs(diff);
                currentBlock.d = overlap; 

                if (diff > 0) {
                    currentBlock.z = prev.z + (diff / 2);
                    addDebris(currentBlock.x, currentBlock.z + (overlap/2) + (cutSize/2), currentBlock.w, cutSize);
                } else {
                    currentBlock.z = prev.z + (diff / 2);
                    addDebris(currentBlock.x, currentBlock.z - (overlap/2) - (cutSize/2), currentBlock.w, cutSize);
                }
            } else {
                isGameOver = true;
            }
        }

        if (isGameOver) {
            addDebris(currentBlock.x, currentBlock.z, currentBlock.w, currentBlock.d);
            gameOver();
        } else {
            // Идеальное попадание
            if (Math.abs(diff) < 4) {
                currentBlock.x = prev.x;
                currentBlock.z = prev.z;
                currentBlock.w = prev.w;
                currentBlock.d = prev.d;
                
                scoreEl.classList.add('bump');
                setTimeout(() => scoreEl.classList.remove('bump'), 150);
                tg.HapticFeedback.notificationOccurred('success');
            } else {
                tg.HapticFeedback.impactOccurred('light');
            }

            addBlock(currentBlock);
            score++;
            scoreEl.innerText = score;
            
            // ВНЕСЕННЫЕ ИЗМЕНЕНИЯ: Плавное ускорение
            // Было 0.08, стало 0.02
            speed += 0.02; 
            
            spawnNextBlock();
        }
    }

    function addDebris(x, z, w, d) {
        debris.push({
            x: x, z: z, w: w, d: d,
            color: currentBlock.color,
            vy: 0,
            yOffset: 0, 
            alpha: 1
        });
    }

    function gameOver() {
        state = 'gameover';
        tg.HapticFeedback.notificationOccurred('error');
        finalScoreEl.innerText = score;
        
        // Цвет цифр в модалке адаптируется под тему
        if(isDark) finalScoreEl.style.color = '#ffffff';
        else finalScoreEl.style.color = '#000000';

        modal.classList.add('visible');
    }

    function restartGame() {
        startGame();
    }

    // --- ОТРИСОВКА ---

    function loop() {
        if(state === 'gameover' && debris.length === 0) return;
        requestAnimationFrame(loop);
        
        updatePhysics();
        
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        
        const cx = window.innerWidth / 2;
        const cy = window.innerHeight / 1.5; 

        // 1. Установленные блоки
        blocks.forEach((b, i) => {
            const stackY = i * BLOCK_HEIGHT; 
            drawIsoBlock(cx, cy, b.x, b.z, b.w, b.d, stackY, b.color);
        });

        // 2. Текущий блок
        if (currentBlock && state === 'playing') {
            const stackY = blocks.length * BLOCK_HEIGHT;
            drawIsoBlock(cx, cy, currentBlock.x, currentBlock.z, currentBlock.w, currentBlock.d, stackY, currentBlock.color);
        }

        // 3. Обломки
        debris.forEach((d, i) => {
            d.vy += 1; 
            d.yOffset -= d.vy;
            d.alpha -= 0.03; 
            
            const stackY = (blocks.length) * BLOCK_HEIGHT + d.yOffset;

            if (d.alpha <= 0) {
                debris.splice(i, 1);
            } else {
                ctx.globalAlpha = d.alpha;
                drawIsoBlock(cx, cy, d.x, d.z, d.w, d.d, stackY, d.color);
                ctx.globalAlpha = 1;
            }
        });
    }

    function drawIsoBlock(cx, cy, x, z, w, d, yLevel, color) {
        const isoX = (x - z);
        const isoY = (x + z) * 0.5;
        
        const screenX = cx + isoX;
        const screenY = cy + isoY - yLevel + cameraY;

        const p_top = getIsoPoint(screenX, screenY, -w/2, -d/2);
        const p_right = getIsoPoint(screenX, screenY, w/2, -d/2);
        const p_bottom = getIsoPoint(screenX, screenY, w/2, d/2);
        const p_left = getIsoPoint(screenX, screenY, -w/2, d/2);

        // ВЕРХ
        ctx.fillStyle = lighten(color, 15);
        ctx.beginPath();
        ctx.moveTo(p_top.x, p_top.y);
        ctx.lineTo(p_right.x, p_right.y);
        ctx.lineTo(p_bottom.x, p_bottom.y);
        ctx.lineTo(p_left.x, p_left.y);
        ctx.closePath();
        ctx.fill();

        // ПРАВО
        ctx.fillStyle = darken(color, 10);
        ctx.beginPath();
        ctx.moveTo(p_right.x, p_right.y);
        ctx.lineTo(p_bottom.x, p_bottom.y);
        ctx.lineTo(p_bottom.x, p_bottom.y + BLOCK_HEIGHT);
        ctx.lineTo(p_right.x, p_right.y + BLOCK_HEIGHT);
        ctx.closePath();
        ctx.fill();

        // ЛЕВО
        ctx.fillStyle = darken(color, 25);
        ctx.beginPath();
        ctx.moveTo(p_left.x, p_left.y);
        ctx.lineTo(p_bottom.x, p_bottom.y);
        ctx.lineTo(p_bottom.x, p_bottom.y + BLOCK_HEIGHT);
        ctx.lineTo(p_left.x, p_left.y + BLOCK_HEIGHT);
        ctx.closePath();
        ctx.fill();
        
        // Обводка
        ctx.strokeStyle = "rgba(255,255,255,0.4)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p_top.x, p_top.y);
        ctx.lineTo(p_right.x, p_right.y);
        ctx.lineTo(p_bottom.x, p_bottom.y);
        ctx.lineTo(p_left.x, p_left.y);
        ctx.closePath();
        ctx.stroke();
    }
    
    function getIsoPoint(cx, cy, dx, dz) {
        return {
            x: cx + (dx * 1 + dz * -1),
            y: cy + (dx * 0.5 + dz * 0.5) - BLOCK_HEIGHT
        };
    }

    function getHSL(h) {
        const sat = 75; // Чуть насыщеннее для красоты
        const lig = isDark ? 60 : 55;
        return `hsl(${Math.floor(h % 360)}, ${sat}%, ${lig}%)`;
    }
    
    function lighten(hsl, amt) { return adjustLight(hsl, amt); }
    function darken(hsl, amt) { return adjustLight(hsl, -amt); }
    function adjustLight(hsl, amt) {
        const parts = hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
        if(!parts) return hsl;
        let h = parts[1];
        let s = parts[2];
        let l = parseInt(parts[3]) + amt;
        l = Math.max(0, Math.min(100, l));
        return `hsl(${h}, ${s}%, ${l}%)`;
    }

    document.addEventListener('pointerdown', handleAction);
    document.addEventListener('keydown', (e) => { 
        if(e.code === 'Space') handleAction(e); 
    });

</script>
</body>
</html>
