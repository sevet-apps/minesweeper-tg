<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Glass App v35.0 All Games</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script> 
    <style>
        :root { 
            --bg-color: #f2f2f7; 
            --text-color: #000000; 
            --glass-bg: rgba(255, 255, 255, 0.85); 
            --glass-border: rgba(255, 255, 255, 0.5); 
            --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1); 
            --accent: #007aff; 
            --danger: #ff3b30; 
            --success: #34c759; 
            --tab-bg: rgba(255,255,255,0.95); 
            --toggle-bg: #e9e9ea; 
            --toggle-circle: #ffffff; 
            --icon-color: #3a3a3c; 
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            
            /* Monopoly Colors */
            --mono-line-yellow: #FFD700;
            --mono-line-orange: #FF8C00;
            --mono-line-peach: #FF9999;
            --mono-line-red: #FF0000;
            --mono-line-pale-green: #90EE90;
            --mono-line-dark-green: #006400;
            --mono-line-blue: #0000FF;
            --mono-line-violet: #800080;
            
            /* Old Games Vars */
            --bb-grid: rgba(0,0,0,0.05); --bb-cell: rgba(255,255,255,0.5); 
            --sudoku-border: rgba(0,0,0,0.1); --sudoku-thick: #000000; 
            --sudoku-sel: rgba(0,122,255,0.25); --sudoku-same: rgba(0,122,255,0.2); --sudoku-err: rgba(255, 59, 48, 0.2);
            --rank-gold: #ffd700; --rank-silver: #c0c0c0; --rank-bronze: #cd7f32;
        }
        [data-theme="dark"] { 
            --bg-color: #000000; --text-color: #ffffff; 
            --glass-bg: rgba(30, 30, 30, 0.8); --glass-border: rgba(255, 255, 255, 0.15); 
            --shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5); 
            --tab-bg: rgba(30,30,30, 0.95); --toggle-bg: #2c2c2e; --toggle-circle: #636366; 
            --icon-color: #aeaeb2; --accent: #0a84ff; 
            --bb-grid: rgba(255,255,255,0.05); --bb-cell: rgba(255,255,255,0.1); 
            --sudoku-border: rgba(255,255,255,0.15); --sudoku-thick: #ffffff; 
            --sudoku-sel: rgba(10, 132, 255, 0.4); --sudoku-same: rgba(10, 132, 255, 0.25); --sudoku-err: rgba(255, 69, 58, 0.3); 
        }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; width: 100%; height: 100dvh; overflow: hidden; overscroll-behavior: none; touch-action: none; transition: background 0.4s; }
        
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 20px; padding-top: calc(80px + var(--safe-top)); padding-bottom: calc(100px + var(--safe-bottom)); overflow-y: auto; opacity: 0; pointer-events: none; transform: scale(0.98); transition: opacity 0.3s, transform 0.3s; } 
        .screen.active { opacity: 1; pointer-events: auto; transform: scale(1); z-index: 1; }
        
        .game-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-color); z-index: 9999; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1); touch-action: none; overflow: hidden; } 
        .game-overlay.visible { transform: translateY(0); }
        
        /* MONOPOLY STYLES */
        .mono-container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 50px; position: relative; width: 100%; overflow: hidden; }
        
        .mono-board { 
            display: grid; 
            grid-template-columns: 1.4fr repeat(9, 1fr) 1.4fr; 
            grid-template-rows: 1.4fr repeat(9, 1fr) 1.4fr; 
            width: 95vw; height: 95vw; 
            max-width: 500px; max-height: 500px; 
            background: #fdfdfd; border: 2px solid #222; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.3); font-size: 7px; 
            position: relative; margin-bottom: 20px; 
        }

        .m-cell { border: 0.5px solid #ccc; position: relative; display: flex; justify-content: center; align-items: center; text-align: center; background: #fff; overflow: hidden; }
        .m-cell .name { font-weight: 700; color: #000; z-index: 2; line-height: 1; padding: 2px; }
        .m-cell .price { position: absolute; font-size: 6px; color: #555; z-index: 2; }
        .m-corner { background: #eee; font-weight: 900; font-size: 9px; }
        
        /* Color Lines Logic - "Inner Edge" */
        .m-left { flex-direction: row; }
        .m-left .color-stripe { width: 6px; height: 100%; order: 2; margin-left: auto; border-left: 1px solid rgba(0,0,0,0.1); }
        .m-left .name { width: 100%; }
        .m-left .price { bottom: 2px; left: 2px; }

        .m-top { flex-direction: column; }
        .m-top .color-stripe { width: 100%; height: 6px; order: 2; margin-top: auto; border-top: 1px solid rgba(0,0,0,0.1); }
        .m-top .name { height: 100%; display: flex; align-items: center; }
        .m-top .price { top: 2px; right: 2px; }

        .m-right { flex-direction: row; }
        .m-right .color-stripe { width: 6px; height: 100%; order: -1; margin-right: auto; border-right: 1px solid rgba(0,0,0,0.1); }
        .m-right .name { width: 100%; }
        .m-right .price { top: 2px; right: 2px; }

        .m-bottom { flex-direction: column; }
        .m-bottom .color-stripe { width: 100%; height: 6px; order: -1; margin-bottom: auto; border-bottom: 1px solid rgba(0,0,0,0.1); }
        .m-bottom .name { height: 100%; display: flex; align-items: center; }
        .m-bottom .price { bottom: 2px; right: 2px; }
        
        .m-center { grid-column: 2 / 11; grid-row: 2 / 11; background: #fafafa; display: flex; flex-direction: column; align-items: center; justify-content: center; border: 1px solid #ddd; }
        .turn-indicator { font-size: 20px; font-weight: 800; text-align: center; color: #ccc; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 1px; }
        
        /* 3D DICE CSS */
        .dice-stage { width: 120px; height: 60px; display: flex; justify-content: center; gap: 30px; perspective: 600px; margin-top: 10px; }
        .cube { width: 40px; height: 40px; position: relative; transform-style: preserve-3d; transform: rotateX(-30deg) rotateY(-45deg); transition: transform 1s cubic-bezier(0.1, 1.5, 0.2, 1); }
        .face { position: absolute; width: 40px; height: 40px; background: white; border: 1px solid #ccc; border-radius: 6px; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: bold; color: #333; box-shadow: inset 0 0 10px rgba(0,0,0,0.1); }
        .face:nth-child(1) { transform: rotateY(0deg) translateZ(20px); }
        .face:nth-child(2) { transform: rotateY(90deg) translateZ(20px); }
        .face:nth-child(3) { transform: rotateY(180deg) translateZ(20px); }
        .face:nth-child(4) { transform: rotateY(-90deg) translateZ(20px); }
        .face:nth-child(5) { transform: rotateX(90deg) translateZ(20px); }
        .face:nth-child(6) { transform: rotateX(-90deg) translateZ(20px); }
        
        .mono-controls { width: 100%; padding: 20px; display: flex; flex-direction: column; gap: 10px; z-index: 100; background: var(--bg-color); border-top: 1px solid var(--glass-border); }
        .player-cards-scroll { display: flex; overflow-x: auto; gap: 8px; padding-bottom: 10px; margin-bottom: 10px; min-height: 60px; }
        .prop-card-mini { min-width: 50px; height: 70px; border-radius: 6px; background: #fff; border: 1px solid #ccc; display: flex; flex-direction: column; align-items: center; font-size: 6px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); animation: popIn 0.4s; }
        .prop-head { width: 100%; height: 15px; border-radius: 6px 6px 0 0; }
        
        .mono-token { width: 16px; height: 16px; border-radius: 50%; border: 2px solid #fff; position: absolute; box-shadow: 0 3px 6px rgba(0,0,0,0.4); z-index: 20; transition: top 0.3s linear, left 0.3s linear; }

        .buy-popup { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0); background: var(--glass-bg); backdrop-filter: blur(20px); border: 1px solid var(--glass-border); padding: 20px; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); z-index: 200; text-align: center; width: 280px; transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); pointer-events: none; opacity: 0; }
        .buy-popup.active { transform: translate(-50%, -50%) scale(1); pointer-events: auto; opacity: 1; }
        .card-preview { width: 120px; height: 160px; border: 2px solid #333; margin: 0 auto 15px; border-radius: 10px; background: white; overflow: hidden; display: flex; flex-direction: column; }
        .cp-header { width: 100%; height: 35px; border-bottom: 2px solid #333; }
        .cp-body { flex: 1; padding: 10px; font-size: 11px; display: flex; flex-direction: column; justify-content: center; font-weight: 600; }

        /* GENERAL UI */
        .card { background: var(--glass-bg); backdrop-filter: blur(20px); border-radius: 20px; border: 1px solid var(--glass-border); padding: 20px; margin-bottom: 15px; box-shadow: var(--shadow); display: flex; align-items: center; gap: 15px; cursor: pointer; transition: transform 0.1s; } .card:active { transform: scale(0.97); }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; margin-top: 10px; } .app-title { font-size: 28px; font-weight: 800; }
        .btn-main { background: var(--accent); color: white; border: none; padding: 14px; width: 100%; border-radius: 14px; font-size: 17px; font-weight: 600; cursor: pointer; }
        .input-glass { width: 100%; background: var(--toggle-bg); border: none; padding: 12px; border-radius: 12px; font-size: 16px; margin-bottom: 10px; text-align: center; }
        .modal-overlay { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.4); backdrop-filter: blur(5px); display: flex; align-items: center; justify-content: center; z-index: 10000; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal { background: var(--bg-color); width: 90%; max-width: 320px; padding: 20px; border-radius: 24px; text-align: center; max-height: 85vh; overflow-y: auto; }
        .back-btn { color: var(--accent); font-size: 17px; font-weight: 500; display: flex; align-items: center; gap: 4px; cursor: pointer; } 
        .game-top-bar { padding: 15px 20px; padding-top: calc(110px + var(--safe-top)); display: flex; justify-content: space-between; align-items: center; background: var(--bg-color); } 
        
        /* CHECKERS CSS */
        .checkers-board { display: flex; flex-wrap: wrap; width: 90vw; height: 90vw; max-width: 350px; max-height: 350px; background: #fff; border: 4px solid #000; border-radius: 4px; margin: 0 auto; } 
        .ch-cell { width: 12.5%; height: 12.5%; display: flex; justify-content: center; align-items: center; position: relative; } .ch-cell.light { background: #fff !important; } .ch-cell.dark { background: #222 !important; } .ch-cell.highlight::after { content:''; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,122,255,0.5); pointer-events:none; } .checker { width: 80%; height: 80%; border-radius: 50%; position: relative; transition: transform 0.2s; z-index: 2; box-shadow: 0 3px 6px rgba(0,0,0,0.5); } .checker.white { background: #f0f0f0; border: 3px solid #ccc; } .checker.black { background: #444; border: 3px solid #777; } .checker.king::before { content:''; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:40%; height:40%; border-radius:50%; border:3px solid #ff3b30; } .checker.selected { transform: scale(1.15); border-color: var(--accent); z-index: 10; box-shadow: 0 0 15px rgba(0,122,255,0.8); }
        
        /* OTHER GAMES CSS */
        .segment-control { position: relative; background: var(--toggle-bg); border-radius: 30px; padding: 0; display: flex; width: 100%; margin-top: 15px; overflow: hidden; height: 46px; border: none; }
        .segment-glider { position: absolute; top: 0; left: 0; width: 50%; height: 100%; background: var(--accent); border-radius: 30px; z-index: 1; transition: transform 0.4s; }
        .segment-item { position: relative; flex: 1; text-align: center; font-size: 15px; font-weight: 600; color: var(--text-color); cursor: pointer; z-index: 2; transition: color 0.2s; display: flex; align-items: center; justify-content: center; opacity: 0.6; }
        .segment-item.active { color: white; opacity: 1; }
        .loader { border: 4px solid rgba(255,255,255,0.3); border-radius: 50%; border-top: 4px solid var(--accent); width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .game-icon-box { width: 48px; height: 48px; border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; }
        .panel-hidden { display: none; } .panel-visible { display: block; animation: fadeInSlide 0.3s ease forwards; } @keyframes fadeInSlide { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }
        /* Add BB, Saper, Sudoku styles briefly */
        .bb-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; width: 90vw; height: 90vw; max-width: 350px; background: var(--bb-grid); padding: 4px; border-radius: 12px; margin: 0 auto; } 
        .bb-cell { background: var(--bb-cell); border-radius: 6px; } .bb-cell.filled { box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1); }
        .sudo-board { display: grid; grid-template-columns: repeat(9, 1fr); width: 90vw; height: 90vw; max-width: 350px; background: var(--bg-color); border: 2px solid var(--sudoku-thick); margin: 0 auto; }
        .sudo-cell { border: 0.5px solid var(--sudoku-border); display: flex; justify-content: center; align-items: center; font-size: 20px; font-weight: 500; }
        .grid { display: grid; gap: 5px; padding: 10px; background: var(--glass-bg); border-radius: 16px; margin: 0 auto; }
        .cell { width: 38px; height: 38px; background: rgba(255,255,255,0.6); border-radius: 8px; display: flex; justify-content: center; align-items: center; font-weight: 700; }
        .cell.revealed { background: rgba(220,220,220,0.5); }
    </style>
</head>
<body>

    <div id="view-games" class="screen active"> 
        <div class="header"> <div class="app-title">Игры</div> </div> 
        
        <div class="card" onclick="openMonopolyMenu()"> 
            <div class="game-icon-box" style="background: linear-gradient(135deg, #8E44AD, #9B59B6);"> 
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg> 
            </div> 
            <div style="flex:1;"> 
                <h3 style="margin:0; font-size:17px;">Монополия</h3> 
                <div style="font-size:10px; color:#ff9500; font-weight:700; margin-top:2px;">BETA • КЛАССИКА</div>
            </div> 
            <div style="color:var(--accent); font-weight:600;">Play</div> 
        </div>

        <div class="card" onclick="openGameModal('saper')"> <div class="game-icon-box" style="background: linear-gradient(135deg, #007aff, #5ac8fa);"> <svg viewBox="0 0 24 24" fill="currentColor" style="width:26px;height:26px;"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M12 7a5 5 0 1 0 5 5 5 5 0 0 0-5-5z"/></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Сапёр</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
        <div class="card" onclick="openGameModal('checkers')"> <div class="game-icon-box" style="background: linear-gradient(135deg, #ff3b30, #ff9500);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Шашки</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
        <div class="card" onclick="startBlockBlastCheck()"> <div class="game-icon-box" style="background: linear-gradient(135deg, #34c759, #30b0c7);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="9" height="9" rx="2"></rect><rect x="13" y="2" width="9" height="9" rx="2"></rect><rect x="2" y="13" width="9" height="9" rx="2"></rect></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Block Blast</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
        <div class="card" onclick="startSudokuCheck()"> <div class="game-icon-box" style="background: linear-gradient(135deg, #5856d6, #af52de);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Судоку</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
    </div>
    
    <div id="view-profile" class="screen"> 
        <div class="header"><div class="app-title">Профиль</div></div> 
        <div style="display:flex; flex-direction:column; align-items:center;"> 
            <img id="user-avatar" src="" alt="" class="avatar" style="width:100px;height:100px;border-radius:50%;margin-bottom:15px;"> 
            <h2 id="user-name" style="margin:0;">Loading...</h2> 
            <p id="user-id" style="color:#8e8e93; margin:5px 0 20px;">@username</p> 
            <div class="settings-group" style="width:100%; background:var(--glass-bg); padding:15px; border-radius:15px;">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                    <span>Темная тема</span>
                    <div class="theme-switch" id="themeToggle" onclick="toggleTheme()" style="width:50px;height:30px;background:var(--toggle-bg);border-radius:20px;position:relative;"><div style="width:26px;height:26px;background:white;border-radius:50%;position:absolute;top:2px;left:2px;"></div></div>
                </div>
            </div>
            <div style="width:100%; display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top: 10px;"> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-saper-games" style="font-size:20px; font-weight:800; color:var(--accent);">0</div> <div style="font-size:12px; color:#8e8e93;">Сапёр Игр</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-saper-best" style="font-size:20px; font-weight:800; color:var(--success);">--</div> <div style="font-size:12px; color:#8e8e93;">Сапёр Рекорд</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-checkers-games" style="font-size:20px; font-weight:800; color:#ff3b30;">0</div> <div style="font-size:12px; color:#8e8e93;">Шашки Игр</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-checkers-wins" style="font-size:20px; font-weight:800; color:#ff9500;">0</div> <div style="font-size:12px; color:#8e8e93;">Побед над Ботом</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-bb-games" style="font-size:20px; font-weight:800; color:#34c759;">0</div> <div style="font-size:12px; color:#8e8e93;">Block Игр</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-bb-best" style="font-size:20px; font-weight:800; color:#30b0c7;">0</div> <div style="font-size:12px; color:#8e8e93;">Block Рекорд</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center; grid-column: span 2;"> <div id="stat-sudoku-wins" style="font-size:20px; font-weight:800; color:#5856d6;">0</div> <div style="font-size:12px; color:#8e8e93;">Судоку Побед</div> </div> 
            </div>
        </div> 
    </div>

    <div class="tab-bar" style="position:fixed; bottom:0; width:100%; height:80px; background:var(--tab-bg); display:flex; justify-content:space-around; align-items:center; z-index:50; border-top:0.5px solid rgba(0,0,0,0.1);"> 
        <div class="tab-item active" onclick="switchTab('games', this)" style="text-align:center; flex:1;">Games</div> 
        <div class="tab-item" onclick="switchTab('profile', this)" style="text-align:center; flex:1;">Profile</div> 
    </div>

    <div id="saper-screen" class="game-overlay"> 
        <div class="game-top-bar"> 
            <div class="back-btn" onclick="closeGame('saper')">Меню</div> 
            <div style="display:flex; gap:15px; font-weight:600;"> <span id="saperFlags">0</span> <span id="saperTimer">000.00</span> </div> 
        </div> 
        <div style="flex:1; display:flex; justify-content:center; align-items:center;"><div class="grid" id="saperGrid"></div></div> 
        <div style="position:fixed; bottom:120px; left:50%; transform:translateX(-50%); width:200px;">
            <div class="segment-control"><div class="segment-glider" id="saperGlider"></div><div class="segment-item active" onclick="setSaperMode('dig', this, 0)">Копать</div><div class="segment-item" onclick="setSaperMode('flag', this, 1)">Флаг</div></div>
        </div> 
    </div>
    
    <div id="checkers-screen" class="game-overlay"> <div class="game-top-bar"> <div class="back-btn" onclick="closeGame('checkers')">Меню</div> <div id="checkersStatus">Ход Белых</div> </div> <div style="flex:1; display:flex; justify-content:center; align-items:center;"><div id="checkersBoard" class="checkers-board"></div></div> </div>
    <div id="bb-screen" class="game-overlay"> <div class="game-top-bar"> <div class="back-btn" onclick="closeGame('bb')">Меню</div> <div>Best: <span id="bbBestScore">0</span></div> </div> <div class="bb-game-container" style="display:flex; flex-direction:column; align-items:center;"> <div id="bbScore" style="font-size:40px; font-weight:800; color:var(--accent); margin-bottom:20px;">0</div> <div id="bbGrid" class="bb-grid"></div> <div class="bb-footer" style="display:flex; justify-content:space-around; width:100%; margin-top:20px;"> <div id="shape0"></div> <div id="shape1"></div> <div id="shape2"></div> </div> </div> </div>
    <div id="sudoku-screen" class="game-overlay"> <div class="game-top-bar"> <div class="back-btn" onclick="closeGame('sudoku')">Меню</div> <div id="sudokuLives" style="color:var(--danger);">0/3</div> </div> <div style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center;"> <div id="sudokuBoard" class="sudo-board"></div> <div class="numpad" style="display:flex; gap:5px; margin-top:20px;"> <div class="num-btn" id="nb1" onclick="activateDigit(1,this)" style="padding:10px; background:white; border-radius:5px;">1</div><div class="num-btn" id="nb2" onclick="activateDigit(2,this)" style="padding:10px; background:white; border-radius:5px;">2</div><div class="num-btn" id="nb3" onclick="activateDigit(3,this)" style="padding:10px; background:white; border-radius:5px;">3</div><div class="num-btn" id="nb4" onclick="activateDigit(4,this)" style="padding:10px; background:white; border-radius:5px;">4</div><div class="num-btn" id="nb5" onclick="activateDigit(5,this)" style="padding:10px; background:white; border-radius:5px;">5</div><div class="num-btn" id="nb6" onclick="activateDigit(6,this)" style="padding:10px; background:white; border-radius:5px;">6</div><div class="num-btn" id="nb7" onclick="activateDigit(7,this)" style="padding:10px; background:white; border-radius:5px;">7</div><div class="num-btn" id="nb8" onclick="activateDigit(8,this)" style="padding:10px; background:white; border-radius:5px;">8</div><div class="num-btn" id="nb9" onclick="activateDigit(9,this)" style="padding:10px; background:white; border-radius:5px;">9</div> </div> </div> </div>

    <div id="monopoly-screen" class="game-overlay">
        <div class="game-top-bar" style="background: var(--bg-color); z-index:101;">
            <div class="back-btn" onclick="closeGame('monopoly')">Выйти</div>
            <div style="font-weight:700;">Баланс: <span id="myMoney" style="color:var(--success); transition: transform 0.2s;">200 000</span></div>
        </div>
        
        <div class="mono-container">
            <div id="monoBoard" class="mono-board">
                <div class="m-center">
                    <div id="turnText" class="turn-indicator">ВАШ ХОД</div>
                    <div class="dice-stage">
                        <div class="cube" id="cube1"><div class="face">1</div><div class="face">2</div><div class="face">3</div><div class="face">4</div><div class="face">5</div><div class="face">6</div></div>
                        <div class="cube" id="cube2"><div class="face">1</div><div class="face">2</div><div class="face">3</div><div class="face">4</div><div class="face">5</div><div class="face">6</div></div>
                    </div>
                </div>
            </div>
            
            <div id="buyPopup" class="buy-popup">
                <div class="card-preview" id="buyCardPrev">
                    <div class="cp-header" id="buyCardColor"></div>
                    <div class="cp-body" id="buyCardName">Название</div>
                </div>
                <div style="font-size:18px; font-weight:700; margin-bottom:15px;" id="buyCardPrice">20 000</div>
                <button class="btn-main" onclick="buyPropertyAction()">Купить</button>
                <button style="margin-top:10px; background:none; border:none; color:var(--danger);" onclick="closeBuyPopup()">Аукцион</button>
            </div>
        </div>

        <div class="mono-controls">
            <div style="font-size:12px; color:#8e8e93; margin-bottom:5px;">Ваши предприятия:</div>
            <div class="player-cards-scroll" id="myPropsList"><div style="color:#ccc; font-size:12px; padding:10px;">Пусто</div></div>
            <button class="btn-main" id="btnRoll" onclick="rollDice()">Бросить кубики</button>
        </div>
    </div>

    <div class="modal-overlay" id="modalSaper"><div class="modal"><h2>Сапёр</h2><div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;"><div class="diff-btn" onclick="setSaperDiff(6,6,5,this)">6x6</div><div class="diff-btn selected" onclick="setSaperDiff(8,8,10,this)">8x8</div><div class="diff-btn" onclick="setSaperDiff(10,10,15,this)">10x10</div><div class="diff-btn" onclick="setSaperDiff(15,15,30,this)">15x15</div></div><button class="btn-main" onclick="launchSaper()">Начать</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93;" onclick="document.getElementById('modalSaper').classList.remove('visible')">Отмена</button></div></div>
    <div class="modal-overlay" id="modalCheckers"><div class="modal"><h2>Шашки</h2>
        <div class="segment-control"><div class="segment-glider" id="checkersMainGlider"></div><div class="segment-item active" onclick="setCheckersMainMode('offline', this, 0)">Offline</div><div class="segment-item" onclick="setCheckersMainMode('online', this, 1)">Online</div></div>
        <div id="ch-offline-panel" class="panel-visible"><p style="color:#8e8e93;">Режим</p><div class="segment-control"><div class="segment-glider" id="checkersGlider"></div><div class="segment-item active" onclick="setCheckersMode(false, this, 0)">2 Игрока</div><div class="segment-item" onclick="setCheckersMode(true, this, 1)">Робот</div></div><button class="btn-main" onclick="launchCheckers()">Играть</button></div>
        <div id="ch-online-panel" class="panel-hidden"><button class="btn-main" onclick="joinGame()">Поиск (Скоро)</button><div style="display:flex; gap:5px; margin-top:10px;"><input type="text" id="joinCodeInput" class="input-glass" placeholder="Код"><button class="btn-main" style="width:auto;" onclick="joinGameByCode()">OK</button></div><button class="btn-main" style="background:var(--toggle-bg); color:black; margin-top:10px;" onclick="createGame()">Создать</button></div>
        <button style="margin-top:10px; background:none; border:none; color:#8e8e93;" onclick="document.getElementById('modalCheckers').classList.remove('visible')">Отмена</button>
    </div></div>
    <div class="modal-overlay" id="modalWaitOpponent"><div class="modal"><h2>Код: <span id="displayRoomCode" style="letter-spacing:2px; color:var(--accent);"></span></h2><p>Ожидание...</p><button style="color:var(--danger); background:none; border:none;" onclick="cancelOnlineWait()">Отмена</button></div></div>
    <div class="modal-overlay" id="modalBBResume"><div class="modal"><h2>Block Blast</h2><button class="btn-main" onclick="resumeBB()">Продолжить</button><button class="btn-main" style="background:var(--danger); margin-top:10px;" onclick="newGameBB()">Новая</button></div></div>
    <div class="modal-overlay" id="modalResult"><div class="modal" id="modalResultContent"><h2 id="resTitle"></h2><p id="resText"></p><button class="btn-main" id="resBtn" onclick="closeResult()">OK</button></div></div>
    <div class="modal-overlay" id="modalBBGameOver"><div class="modal" id="bbGameOverContent"></div></div>
    <div class="modal-overlay" id="modalLoading"><div class="loader"></div></div>
    <div class="modal-overlay" id="modalSudoku"><div class="modal"><h2>Судоку</h2><div class="segment-control"><div class="segment-glider" id="sudokuGlider"></div><div class="segment-item" onclick="selectSudokuDiff(30,this,0)">Easy</div><div class="segment-item active" onclick="selectSudokuDiff(40,this,1)">Med</div><div class="segment-item" onclick="selectSudokuDiff(50,this,2)">Hard</div></div><button class="btn-main" onclick="startSudoku()">Играть</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93;" onclick="document.getElementById('modalSudoku').classList.remove('visible')">Отмена</button></div></div>
    <div class="modal-overlay" id="modalSudokuResume"><div class="modal"><h2>Судоку</h2><button class="btn-main" onclick="resumeSudoku()">Продолжить</button><button class="btn-main" style="background:var(--danger); margin-top:10px;" onclick="document.getElementById('modalSudokuResume').classList.remove('visible'); document.getElementById('modalSudoku').classList.add('visible');">Новая</button></div></div>
    
    <div class="modal-overlay" id="modalMonopolyMenu">
        <div class="modal">
            <h2>Монополия</h2>
            <p style="color:#8e8e93;">Классическая версия</p>
            <button class="btn-main" onclick="createMonopolyGame()">Создать комнату</button>
            <input type="text" id="monoJoinCode" class="input-glass" placeholder="Код комнаты" style="margin-top:10px;">
            <button class="btn-main" style="background:var(--toggle-bg); color:var(--text-color);" onclick="joinMonopolyGame()">Войти</button>
            <button style="margin-top:15px; border:none; background:none; color:#8e8e93;" onclick="document.getElementById('modalMonopolyMenu').classList.remove('visible')">Отмена</button>
        </div>
    </div>
    
    <div class="modal-overlay" id="modalMonopolyLobby">
        <div class="modal">
            <h2>Комната <span id="monoLobbyCode" style="color:var(--accent);">---</span></h2>
            <div id="monoLobbyList" style="text-align:left; margin:15px 0;"></div>
            <button class="btn-main" id="monoStartBtn" style="display:none;" onclick="startMonopolyGame()">Начать игру</button>
            <button style="margin-top:10px; border:none; background:none; color:var(--danger);" onclick="location.reload()">Выйти</button>
        </div>
    </div>
    <script>
        const tg = window.Telegram.WebApp; 
        tg.expand();
        // Отключаем свайпы и зум
        if (tg.isVerticalSwipesEnabled !== undefined) tg.isVerticalSwipesEnabled = false;
        if (tg.requestFullscreen) tg.requestFullscreen();
        tg.enableClosingConfirmation();

        let isDark = tg.colorScheme === 'dark';
        let isLiteMode = localStorage.getItem('lite_mode') === 'true'; 
        
        // --- SOCKET.IO INIT ---
        const API_BASE_URL = 'https://glass-api-kh3s.onrender.com';
        const socket = io(API_BASE_URL);
        
        let onlineRoomCode = null;
        let onlineMyColor = null; // Для шашек
        let isOnlineGame = false;
        
        // --- ASSETS ---
        const ICON_MINE = `<svg class="saper-mine" viewBox="0 0 24 24"><path d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2zm0 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm0-13a5 5 0 1 1 0 10 5 5 0 0 1 0-10z"/></svg>`;
        const ICON_FLAG = `<svg class="saper-flag" viewBox="0 0 24 24" style="fill:#ff3b30; stroke:none;"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/></svg>`;
        const ICON_CROWN = `<svg class="crown-icon" viewBox="0 0 24 24"><path d="M5 16L3 5l5.5 5L12 4l3.5 6L21 5l-2 11H5zm14 3c0 .6-.4 1-1 1H6c-.6 0-1-.4-1-1v-1h14v1z"/></svg>`;
        const COLOR_MAP = { 'bb-c-1':'#ff3b30', 'bb-c-2':'#ff9500', 'bb-c-3':'#ffcc00', 'bb-c-4':'#34c759', 'bb-c-5':'#007aff', 'bb-c-6':'#5856d6', 'bb-c-7':'#af52de' };

        // --- КАРТА МОНОПОЛИИ (СССР / Питер) ---
        // Индексы: 0 (Низ-Лево) -> По часовой -> 1-9 (Лево) -> 10 (Верх-Лево) ...
        const LOCAL_MONOPOLY_MAP = [
            { id: 0, type: 'start', name: 'СТАРТ' },
            // ЛЕВАЯ СТОРОНА (Снизу Вверх)
            { id: 1, type: 'prop', name: 'Ф-ка ПОБЕДА', price: 5000, group: 'yellow' },
            { id: 2, type: 'prop', name: 'Ф-ка ВОЛОДАР', price: 6000, group: 'yellow' },
            { id: 3, type: 'prop', name: 'Ф-ка БОЛЬШЕВ', price: 7000, group: 'yellow' },
            { id: 4, type: 'prop', name: 'СКК ЮБИЛЕЙ', price: 9000, group: 'orange' },
            { id: 5, type: 'util', name: 'Транспорт', price: 15000 },
            { id: 6, type: 'prop', name: 'СКК ЛЕНИНА', price: 10000, group: 'orange' },
            { id: 7, type: 'prop', name: 'Стад. КИРОВА', price: 11000, group: 'orange' },
            { id: 8, type: 'chance', name: 'ШАНС', price: 0 },
            { id: 9, type: 'prop', name: 'ТРОЛЛЕЙБУС', price: 13000, group: 'peach' },
            // ВЕРХНИЙ ЛЕВЫЙ УГОЛ
            { id: 10, type: 'jail', name: 'ТЮРЬМА' },
            // ВЕРХНЯЯ СТОРОНА (Слева Направо)
            { id: 11, type: 'prop', name: 'МЕТРО', price: 14000, group: 'peach' },
            { id: 12, type: 'prop', name: 'БМП', price: 15000, group: 'peach' },
            { id: 13, type: 'prop', name: 'К-тр КОЛИЗЕЙ', price: 17000, group: 'red' },
            { id: 14, type: 'chance', name: 'ШАНС', price: 0 },
            { id: 15, type: 'prop', name: 'К-тр ЛЕНИНГР', price: 18000, group: 'red' },
            { id: 16, type: 'prop', name: 'Театр КИРОВА', price: 19000, group: 'red' },
            { id: 17, type: 'prop', name: 'Р-н УНИВЕРС', price: 21000, group: 'pale-green' },
            { id: 18, type: 'prop', name: 'Р-н СЕВЕР', price: 22000, group: 'pale-green' },
            { id: 19, type: 'prop', name: 'Р-н МЕТРОП', price: 23000, group: 'pale-green' },
            // ВЕРХНИЙ ПРАВЫЙ УГОЛ
            { id: 20, type: 'parking', name: 'СТОЯНКА' },
            // ПРАВАЯ СТОРОНА (Сверху Вниз)
            { id: 21, type: 'prop', name: 'Гос ЛЕНИНГР', price: 25000, group: 'dark-green' },
            { id: 22, type: 'chance', name: 'ШАНС', price: 0 },
            { id: 23, type: 'prop', name: 'Гос АСТОРИЯ', price: 26000, group: 'dark-green' },
            { id: 24, type: 'prop', name: 'Гос ПРИБАЛТ', price: 27000, group: 'dark-green' },
            { id: 25, type: 'util', name: 'Электро', price: 15000 },
            { id: 26, type: 'prop', name: 'Ун-г ЮБИЛЕЙ', price: 29000, group: 'blue' },
            { id: 27, type: 'prop', name: 'Т-Ф ДЛТ', price: 30000, group: 'blue' },
            { id: 28, type: 'prop', name: 'ГОСТ. ДВОР', price: 31000, group: 'blue' },
            { id: 29, type: 'chance', name: 'ШАНС', price: 0 },
            // НИЖНИЙ ПРАВЫЙ УГОЛ
            { id: 30, type: 'gotojail', name: 'АРЕСТ' },
            // НИЖНЯЯ СТОРОНА (Справа Налево)
            { id: 31, type: 'prop', name: 'Об. КИРОВСК', price: 33000, group: 'violet' },
            { id: 32, type: 'tax', name: 'НАЛОГ', price: 10000 },
            { id: 33, type: 'prop', name: 'Об. ЛОМО', price: 34000, group: 'violet' },
            { id: 34, type: 'chance', name: 'ШАНС', price: 0 },
            { id: 35, type: 'prop', name: 'ЭЛЕКТРОСИЛ', price: 35000, group: 'violet' },
            { id: 36, type: 'chance', name: '?', price: 0 },
            { id: 37, type: 'tax', name: 'Налог', price: 20000 },
            { id: 38, type: 'chance', name: '?', price: 0 },
            { id: 39, type: 'chance', name: '?', price: 0 }
        ];
        
        // ! Исправляем массив, чтобы ровно 40 полей легло в сетку 11x11
        // (Остальные поля пустые/заглушки, если массив < 40, но у нас 40).

        function initApp() {
            applyTheme();
            applyLiteMode();
            loadProfile();
            setTimeout(syncLocalStatsToServer, 2000);
            
            // --- SOCKET LISTENERS ---

            // 1. ШАШКИ
            socket.on('game_created', (data) => {
                document.getElementById('modalLoading').classList.remove('visible');
                onlineRoomCode = data.roomCode;
                onlineMyColor = data.color;
                document.getElementById('displayRoomCode').innerText = onlineRoomCode;
                document.getElementById('modalWaitOpponent').classList.add('visible');
            });
            
            socket.on('start_game', (data) => {
                // ВАЖНО: Ставим флаг онлайн игры, чтобы отключить бота
                isOnlineGame = true; 
                document.getElementById('modalWaitOpponent').classList.remove('visible');
                document.getElementById('modalCheckers').classList.remove('visible');
                if (data.color) onlineMyColor = data.color;
                document.getElementById('checkers-screen').classList.add('visible');
                initCheckers(); 
                const boardEl = document.getElementById('checkersBoard');
                boardEl.classList.remove('rotated'); 
                if (onlineMyColor === 'black') boardEl.classList.add('rotated');
                tg.HapticFeedback.notificationOccurred('success');
                showResult(`Игра началась!`, `Ваш цвет: ${onlineMyColor === 'white' ? 'Белые' : 'Чёрные'}\nСоперник: ${data.opponent.name}`, "Погнали", () => { document.getElementById('modalResult').classList.remove('visible'); });
            });
            
            socket.on('opponent_move', (move) => { executeMove(move, false); });
            socket.on('opponent_disconnected', () => { showResult("Победа!", "Соперник отключился", "В меню", () => { closeResult(); closeGame('checkers'); }); });
            
            // 2. МОНОПОЛИЯ
            socket.on('monopoly_created', (data) => {
                document.getElementById('modalLoading').classList.remove('visible');
                document.getElementById('modalMonopolyMenu').classList.remove('visible');
                enterLobby(data.roomCode, true);
            });

            socket.on('monopoly_player_update', (data) => { updateLobby(data.players); });

            socket.on('monopoly_game_started', (data) => {
                document.getElementById('modalMonopolyLobby').classList.remove('visible');
                document.getElementById('monopoly-screen').classList.add('visible');
                initMonoBoard(data.players);
            });
            
            socket.on('monopoly_roll_result', (data) => {
                animateDice3D(data.d1, data.d2);
                setTimeout(() => {
                    moveTokenSmoothly(data.playerIndex, data.oldPos, data.newPos);
                    if(data.playerIndex === myPlayerIndex) {
                        const moneyEl = document.getElementById('myMoney');
                        moneyEl.innerText = data.playerMoney.toLocaleString();
                        moneyEl.style.transform = "scale(1.2)";
                        setTimeout(() => moneyEl.style.transform = "scale(1)", 200);
                    }
                }, 1500);
            });

            socket.on('monopoly_turn', (data) => {
                const btn = document.getElementById('btnRoll');
                const txt = document.getElementById('turnText');
                if(data.playerIndex === myPlayerIndex) {
                    btn.disabled = false; btn.style.opacity = 1; btn.innerText = "Бросить кубики";
                    txt.innerText = "ВАШ ХОД"; txt.style.color = "var(--accent)";
                    tg.HapticFeedback.notificationOccurred('success');
                } else {
                    btn.disabled = true; btn.style.opacity = 0.5; btn.innerText = "Ожидание...";
                    const name = monoPlayers[data.playerIndex] ? monoPlayers[data.playerIndex].name : "Игрок";
                    txt.innerText = "ХОДИТ " + name; txt.style.color = "#ccc";
                }
            });

            socket.on('error_message', (msg) => { alert(msg); document.getElementById('modalLoading').classList.remove('visible'); });
        }

        // --- COMMON UI FUNCTIONS ---
        function applyTheme() { document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light'); if(tg.headerColor) tg.headerColor = isDark ? '#000000' : '#f2f2f7'; if(tg.backgroundColor) tg.backgroundColor = isDark ? '#000000' : '#f2f2f7'; }
        function toggleTheme() { isDark = !isDark; applyTheme(); tg.HapticFeedback.selectionChanged(); }
        function applyLiteMode() { const el = document.getElementById('liteToggle'); if(isLiteMode) el.classList.add('active'); else el.classList.remove('active'); }
        function toggleLiteMode() { isLiteMode = !isLiteMode; localStorage.setItem('lite_mode', isLiteMode); applyLiteMode(); tg.HapticFeedback.selectionChanged(); }
        function switchTab(t, el) { document.querySelectorAll('.screen').forEach(s => s.classList.remove('active')); document.querySelectorAll('.tab-item').forEach(b => b.classList.remove('active')); if(t==='games') document.getElementById('view-games').classList.add('active'); else if(t==='leaderboard') document.getElementById('view-leaderboard').classList.add('active'); else { document.getElementById('view-profile').classList.add('active'); loadProfile(); } if(el) el.classList.add('active'); tg.HapticFeedback.selectionChanged(); }
        
        function openGameModal(game) { 
            if(game==='saper') document.getElementById('modalSaper').classList.add('visible'); 
            if(game==='checkers') document.getElementById('modalCheckers').classList.add('visible'); 
            tg.HapticFeedback.impactOccurred('light'); 
        }
        function closeGame(game) { document.getElementById(game+'-screen').classList.remove('visible'); if(game==='saper') clearInterval(sTimerInt); if(game==='bb') saveBBState(); if(game==='sudoku') saveSudokuState(); }
        function closeResult() { document.getElementById('modalResult').classList.remove('visible'); document.getElementById('modalBBGameOver').classList.remove('visible'); document.querySelectorAll('.game-overlay').forEach(el => el.classList.remove('visible')); }
        
        function loadProfile() { 
            const user = tg.initDataUnsafe.user || { first_name: "Player", username: "user" }; 
            document.getElementById('user-name').innerText = user.first_name; 
            document.getElementById('user-id').innerText = user.username ? '@'+user.username : ''; 
            const ava = document.getElementById('user-avatar'); 
            if(user.photo_url) ava.src = user.photo_url; 
            else ava.src = `https://ui-avatars.com/api/?name=${user.first_name}&background=007aff&color=fff`; 
            
            document.getElementById('stat-saper-games').innerText = localStorage.getItem('saper_total') || 0; 
            document.getElementById('stat-saper-best').innerText = localStorage.getItem('saper_best_8') || '--'; 
            document.getElementById('stat-checkers-games').innerText = localStorage.getItem('checkers_total') || 0; 
            document.getElementById('stat-checkers-wins').innerText = localStorage.getItem('checkers_wins_pve') || 0; 
            document.getElementById('stat-bb-games').innerText = localStorage.getItem('bb_total_games') || 0; 
            document.getElementById('stat-bb-best').innerText = localStorage.getItem('bb_best_score') || 0; 
            document.getElementById('stat-sudoku-wins').innerText = localStorage.getItem('sudoku_wins') || 0;
            if(document.getElementById('bbBestScore')) document.getElementById('bbBestScore').innerText = localStorage.getItem('bb_best_score') || 0; 
        }
        
        function saveStatToCloud(key, value) { localStorage.setItem(key, value); loadProfile(); }
        async function sendStatToBackend(game_type, score) {
            const user = tg.initDataUnsafe.user; if (!user) return;
            const url = `${API_BASE_URL}/save-stat`;
            const payload = { user_id: user.id.toString(), username: (user.first_name + ' ' + (user.last_name||'')).trim(), photo_url: user.photo_url || "", game_type: game_type, score: score };
            try { await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); } catch (error) { console.error(error); }
        }
        function syncLocalStatsToServer() {
            const bbBest = parseInt(localStorage.getItem('bb_best_score') || 0); if(bbBest > 0) sendStatToBackend('bb_best_score', bbBest);
        }

        // --- MONOPOLY LOGIC ---
        let monoPlayers = [];
        let myPlayerIndex = -1;
        let currentBuyCell = null;

        function openMonopolyMenu() { document.getElementById('modalMonopolyMenu').classList.add('visible'); }
        function createMonopolyGame() {
            document.getElementById('modalLoading').classList.add('visible');
            const user = tg.initDataUnsafe.user || { first_name: "Player" };
            socket.emit('create_game', { username: user.first_name, photo_url: user.photo_url, gameType: 'monopoly' });
        }
        function joinMonopolyGame() {
            const code = document.getElementById('monoJoinCode').value;
            if(code.length < 5) return tg.HapticFeedback.notificationOccurred('error');
            const user = tg.initDataUnsafe.user || { first_name: "Player" };
            socket.emit('join_game', { roomCode: code, userData: { username: user.first_name, photo_url: user.photo_url } });
            document.getElementById('modalMonopolyMenu').classList.remove('visible');
            enterLobby(code, false);
        }
        function enterLobby(code, isCreator) {
            onlineRoomCode = code;
            document.getElementById('modalMonopolyLobby').classList.add('visible');
            document.getElementById('monoLobbyCode').innerText = code;
            document.getElementById('monoStartBtn').style.display = isCreator ? 'block' : 'none';
        }
        function updateLobby(players) {
            const list = document.getElementById('monoLobbyList');
            list.innerHTML = '';
            const user = tg.initDataUnsafe.user || { first_name: "Player" };
            players.forEach((p, i) => {
                if(p.name === user.first_name) myPlayerIndex = i;
                const row = document.createElement('div');
                row.style.cssText = "display:flex; align-items:center; margin-bottom:10px; border-bottom:1px solid rgba(0,0,0,0.1); padding-bottom:5px;";
                const ava = p.avatar || `https://ui-avatars.com/api/?name=${p.name}&background=random`;
                row.innerHTML = `<img src="${ava}" style="width:30px;height:30px;border-radius:50%;margin-right:10px;"><b>${p.name}</b>`;
                list.appendChild(row);
            });
            monoPlayers = players;
        }
        function startMonopolyGame() { socket.emit('monopoly_start', { roomCode: onlineRoomCode }); }

        function initMonoBoard(players) {
            monoPlayers = players;
            const board = document.getElementById('monoBoard');
            const center = board.querySelector('.m-center');
            board.innerHTML = ''; board.appendChild(center);

            LOCAL_MONOPOLY_MAP.forEach(cell => {
                const el = document.createElement('div');
                el.className = 'm-cell';
                el.id = `cell-${cell.id}`;
                
                const pos = getGridPos(cell.id);
                el.style.gridRow = pos.r;
                el.style.gridColumn = pos.c;

                if (cell.id > 0 && cell.id < 10) el.classList.add('m-left');
                else if (cell.id > 10 && cell.id < 20) el.classList.add('m-top');
                else if (cell.id > 20 && cell.id < 30) el.classList.add('m-right');
                else if (cell.id > 30) el.classList.add('m-bottom');
                else el.classList.add('m-corner');

                if(cell.type === 'prop' || cell.type === 'util') {
                    if(cell.group) {
                         const colorLine = document.createElement('div');
                         colorLine.className = 'color-stripe';
                         colorLine.style.backgroundColor = `var(--mono-line-${cell.group})`;
                         el.appendChild(colorLine);
                    }
                    el.innerHTML += `<div class="name">${cell.name}</div><div class="price">${cell.price/1000}k</div>`;
                } else if (cell.type === 'station') {
                     el.innerHTML += `<div class="name">${cell.name}</div><div class="price">200k</div>`;
                } else {
                    el.innerHTML += `<div class="name">${cell.name}</div>`;
                }
                board.appendChild(el);
            });

            // Фишки
            players.forEach((p, i) => {
                const t = document.createElement('div');
                t.className = 'mono-token';
                const colors = ['#ff3b30', '#007aff', '#34c759', '#ffcc00'];
                t.style.backgroundColor = colors[i%4];
                t.id = `token-${i}`;
                board.appendChild(t);
                updateTokenPos(i, 0);
            });
        }

        // --- ГЛАВНАЯ ЛОГИКА СЕТКИ (11x11, Старт СЛЕВА СНИЗУ) ---
        function getGridPos(id) {
            // 0 = Start (Row 11, Col 1)
            if(id === 0) return { r: 11, c: 1 };
            // 1-9 = Левая сторона (вверх) -> Row 10..2, Col 1
            if(id > 0 && id < 10) return { r: 11 - id, c: 1 };
            // 10 = Тюрьма (Верх Лево) -> Row 1, Col 1
            if(id === 10) return { r: 1, c: 1 };
            // 11-19 = Верхняя сторона (вправо) -> Row 1, Col 2..10
            if(id > 10 && id < 20) return { r: 1, c: id - 9 };
            // 20 = Парковка (Верх Право) -> Row 1, Col 11
            if(id === 20) return { r: 1, c: 11 };
            // 21-29 = Правая сторона (вниз) -> Row 2..10, Col 11
            if(id > 20 && id < 30) return { r: id - 19, c: 11 };
            // 30 = Арест (Низ Право) -> Row 11, Col 11
            if(id === 30) return { r: 11, c: 11 };
            // 31-39 = Нижняя сторона (влево) -> Row 11, Col 10..2
            if(id > 30) return { r: 11, c: 11 - (id - 30) };
            
            return { r: 11, c: 1 };
        }

        function updateTokenPos(playerIdx, cellId) {
            const token = document.getElementById(`token-${playerIdx}`);
            const cell = document.getElementById(`cell-${cellId}`);
            if(!token || !cell) return;
            const cellRect = cell.getBoundingClientRect();
            const boardRect = document.getElementById('monoBoard').getBoundingClientRect();
            const offsetMap = [{x: -3, y: -3}, {x: 3, y: -3}, {x: -3, y: 3}, {x: 3, y: 3}];
            const off = offsetMap[playerIdx % 4];
            const top = cellRect.top - boardRect.top + (cellRect.height/2) - 8 + off.y;
            const left = cellRect.left - boardRect.left + (cellRect.width/2) - 8 + off.x;
            token.style.top = top + 'px';
            token.style.left = left + 'px';
        }

        function moveTokenSmoothly(playerIdx, startPos, endPos) {
            let current = startPos;
            function step() {
                if (current === endPos) { checkLanding(playerIdx, endPos); return; }
                current++; if(current > 39) current = 0;
                updateTokenPos(playerIdx, current); tg.HapticFeedback.impactOccurred('light');
                setTimeout(step, 150);
            }
            step();
        }

        function rollDice() { document.getElementById('btnRoll').disabled = true; socket.emit('monopoly_roll', { roomCode: onlineRoomCode }); }

        function animateDice3D(d1, d2) {
            const c1 = document.getElementById('cube1'); const c2 = document.getElementById('cube2');
            const r1x = 720 + (Math.random() * 360); const r1y = 720 + (Math.random() * 360);
            c1.style.transition = "transform 0.8s ease-in"; c1.style.transform = `rotateX(${r1x}deg) rotateY(${r1y}deg)`;
            const r2x = 720 + (Math.random() * 360); const r2y = 720 + (Math.random() * 360);
            c2.style.transition = "transform 0.8s ease-in"; c2.style.transform = `rotateX(${r2x}deg) rotateY(${r2y}deg)`;
            setTimeout(() => {
                c1.style.transition = "transform 0.2s cubic-bezier(0.1, 1.5, 0.2, 1)";
                c2.style.transition = "transform 0.2s cubic-bezier(0.1, 1.5, 0.2, 1)";
                setCubeFace(c1, d1); setCubeFace(c2, d2);
            }, 800);
        }

        function setCubeFace(el, num) {
            let rx=0, ry=0;
            switch(num) {
                case 1: rx=0; ry=0; break; case 2: rx=0; ry=-90; break; case 3: rx=0; ry=180; break;
                case 4: rx=0; ry=90; break; case 5: rx=-90; ry=0; break; case 6: rx=90; ry=0; break;
            }
            el.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg)`;
        }

        function checkLanding(pIdx, pos) {
            if(pIdx !== myPlayerIndex) return;
            const cell = LOCAL_MONOPOLY_MAP.find(c => c.id === pos);
            if(cell && (cell.type === 'prop' || cell.type === 'util' || cell.type === 'station')) showBuyPopup(cell);
        }
        function showBuyPopup(cell) {
            currentBuyCell = cell;
            document.getElementById('buyCardName').innerText = cell.name;
            document.getElementById('buyCardPrice').innerText = cell.price.toLocaleString() + " sc";
            const header = document.getElementById('buyCardColor');
            header.style.background = cell.group ? `var(--mono-line-${cell.group})` : '#333';
            document.getElementById('buyPopup').classList.add('active');
            tg.HapticFeedback.notificationOccurred('warning');
        }
        function closeBuyPopup() { document.getElementById('buyPopup').classList.remove('active'); currentBuyCell = null; }
        function buyPropertyAction() {
            if(!currentBuyCell) return;
            const list = document.getElementById('myPropsList');
            if(list.innerText.includes("Пусто")) list.innerHTML = '';
            const card = document.createElement('div'); card.className = 'prop-card-mini';
            const color = currentBuyCell.group ? `var(--mono-line-${currentBuyCell.group})` : '#333';
            card.innerHTML = `<div class="prop-head" style="background:${color}"></div><div style="margin-top:5px;text-align:center;">${currentBuyCell.name}</div>`;
            list.appendChild(card);
            const cellEl = document.getElementById(`cell-${currentBuyCell.id}`);
            cellEl.style.border = "2px solid var(--accent)";
            tg.HapticFeedback.notificationOccurred('success');
            closeBuyPopup();
        }

        /* --- SAPER LOGIC --- */
        let sRows=8, sCols=8, sMines=10, sMode='dig', sGrid=[], sTimer=0, sTimerInt, sFlags=0, sFirst=true, sOver=false, sStartTime=0;
        function setSaperDiff(r,c,m,btn) { sRows=r; sCols=c; sMines=m; document.querySelectorAll('#modalSaper .diff-btn').forEach(b=>b.classList.remove('selected')); btn.classList.add('selected'); tg.HapticFeedback.selectionChanged(); }
        function launchSaper() { document.getElementById('modalSaper').classList.remove('visible'); document.getElementById('saper-screen').classList.add('visible'); setSaperMode('dig', document.querySelector('#saperGlider').nextElementSibling, 0); initSaper(); }
        function setSaperMode(m, btn, index) { sMode = m; const glider = document.getElementById('saperGlider'); if(glider) glider.style.transform = `translateX(${index * 100}%)`; const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active'); tg.HapticFeedback.selectionChanged(); }
        function initSaper() { sGrid=[]; sOver=false; sFirst=true; sFlags=sMines; sTimer=0; document.getElementById('saperFlags').innerText=sFlags; document.getElementById('saperTimer').innerText='000.00'; clearInterval(sTimerInt); const el=document.getElementById('saperGrid'); el.innerHTML=''; el.style.gridTemplateColumns=`repeat(${sCols}, 38px)`; const w=window.innerWidth-20, rw=sCols*43; el.style.transform=rw>w?`scale(${w/rw})`:`scale(1)`; for(let r=0;r<sRows;r++){const row=[];for(let c=0;c<sCols;c++){const cell=document.createElement('div');cell.className='cell';cell.onclick=()=>onSaperClick(r,c);cell.oncontextmenu=(e)=>{e.preventDefault();onSaperFlag(r,c);};let pt;cell.addEventListener('touchstart',()=>{if(!sOver)pt=setTimeout(()=>{onSaperFlag(r,c);tg.HapticFeedback.impactOccurred('medium');},500);});cell.addEventListener('touchend',()=>clearTimeout(pt));el.appendChild(cell);row.push({isMine:false,revealed:false,flagged:false,neighbor:0,el:cell});}sGrid.push(row);} }
        function onSaperClick(r,c){const cell=sGrid[r][c];if(sOver||cell.revealed)return;if(sMode==='flag'){onSaperFlag(r,c);return;}if(cell.flagged)return;if(sFirst){sFirst=false;placeMinesSafe(r,c); sStartTime = Date.now(); sTimerInt=setInterval(()=>{ let now = Date.now(); let diff = (now - sStartTime)/1000; sTimer = diff; document.getElementById('saperTimer').innerText= diff.toFixed(2);},3);}if(cell.isMine)loseSaper(cell);else{revealSaper(r,c);checkSaperWin();tg.HapticFeedback.selectionChanged();}}
        function onSaperFlag(r,c){const cell=sGrid[r][c];if(sOver||cell.revealed)return;if(!cell.flagged&&sFlags>0){cell.flagged=true;cell.el.innerHTML=ICON_FLAG;sFlags--;}else if(cell.flagged){cell.flagged=false;cell.el.innerHTML='';sFlags++;}document.getElementById('saperFlags').innerText=sFlags;}
        function placeMinesSafe(exR,exC){let placed=0;while(placed<sMines){let rr=Math.floor(Math.random()*sRows),cc=Math.floor(Math.random()*sCols);if(Math.abs(rr-exR)<=1&&Math.abs(cc-exC)<=1)continue;if(!sGrid[rr][cc].isMine){sGrid[rr][cc].isMine=true;placed++;}}for(let r=0;r<sRows;r++)for(let c=0;c<sCols;c++){if(sGrid[r][c].isMine)continue;let cnt=0;for(let i=-1;i<=1;i++)for(let j=-1;j<=1;j++)if(r+i>=0&&r+i<sRows&&c+j>=0&&c+j<sCols&&sGrid[r+i][c+j].isMine)cnt++;sGrid[r][c].neighbor=cnt;}}
        function revealSaper(r,c){const cell=sGrid[r][c];if(cell.revealed||cell.flagged)return;cell.revealed=true;cell.el.classList.add('revealed');if(cell.neighbor>0){cell.el.innerText=cell.neighbor;cell.el.classList.add('c-'+cell.neighbor);}else{for(let i=-1;i<=1;i++)for(let j=-1;j<=1;j++)if(r+i>=0&&r+i<sRows&&c+j>=0&&c+j<sCols)revealSaper(r+i,c+j);}}
        function loseSaper(cell){sOver=true;clearInterval(sTimerInt);tg.HapticFeedback.notificationOccurred('error');cell.el.style.background='var(--danger)';sGrid.forEach(r=>r.forEach(c=>{if(c.isMine)c.el.innerHTML=ICON_MINE;}));let t=parseInt(localStorage.getItem('saper_total')||0)+1;saveStatToCloud('saper_total',t);showResult('Бум!','Не повезло', 'Закрыть');}
        function checkSaperWin(){ let rev=0;sGrid.forEach(r=>r.forEach(c=>{if(c.revealed)rev++})); if(rev===sRows*sCols-sMines){ sOver=true;clearInterval(sTimerInt);tg.HapticFeedback.notificationOccurred('success'); confetti({particleCount:150,spread:70,origin:{y:0.6},zIndex:2147483647}); let t=parseInt(localStorage.getItem('saper_total')||0)+1; saveStatToCloud('saper_total',t); let w=parseInt(localStorage.getItem('saper_wins')||0)+1; saveStatToCloud('saper_wins', w); const key = `saper_best_${sRows}`; let b=parseFloat(localStorage.getItem(key)||9999); if(sTimer<b) saveStatToCloud(key, sTimer); sendStatToBackend(`saper_best_${sRows}`, sTimer); sendStatToBackend('saper_wins', w); showResult('Победа!',`Время: ${sTimer.toFixed(2)} с`, 'Круто'); } }

        /* --- CHECKERS LOGIC --- */
        const BOARD_SIZE=8; let board=[], turn='white', selectedPiece=null, isPvE=false, forcedPiece=null;
        function setCheckersMainMode(mode, btn, index) { const glider = document.getElementById('checkersMainGlider'); glider.style.transform = `translateX(${index * 100}%)`; const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active'); const offline = document.getElementById('ch-offline-panel'); const online = document.getElementById('ch-online-panel'); if(mode === 'online') { offline.classList.replace('panel-visible', 'panel-hidden'); online.classList.replace('panel-hidden', 'panel-visible'); } else { online.classList.replace('panel-visible', 'panel-hidden'); offline.classList.replace('panel-hidden', 'panel-visible'); } tg.HapticFeedback.selectionChanged(); }
        function createGame() { document.getElementById('modalLoading').classList.add('visible'); const user = tg.initDataUnsafe.user || { first_name: "Player" }; const displayName = (user.first_name + ' ' + (user.last_name || '')).trim(); socket.emit('create_game', { username: displayName, photo_url: user.photo_url || '', gameType: 'checkers' }); }
        function joinGame() { tg.HapticFeedback.notificationOccurred('warning'); alert('Скоро: Поиск случайного соперника'); }
        function joinGameByCode() { const code = document.getElementById('joinCodeInput').value; if (code.length < 5) { tg.HapticFeedback.notificationOccurred('error'); return; } onlineRoomCode = code; const user = tg.initDataUnsafe.user || { first_name: "Player" }; const displayName = (user.first_name + ' ' + (user.last_name || '')).trim(); socket.emit('join_game', { roomCode: code, userData: { username: displayName, photo_url: user.photo_url || '' } }); }
        function cancelOnlineWait() { document.getElementById('modalWaitOpponent').classList.remove('visible'); onlineRoomCode = null; }
        function setCheckersMode(pve, btn, index){ isPvE = pve; isOnlineGame = false; const glider = document.getElementById('checkersGlider'); glider.style.transform = `translateX(${index * 100}%)`; const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active'); tg.HapticFeedback.selectionChanged(); }
        function startLocalCheckers() { isPvE = true; isOnlineGame = false; document.getElementById('modalCheckers').classList.remove('visible'); document.getElementById('checkers-screen').classList.add('visible'); setTimeout(initCheckers, 50); }
        function launchCheckers(){document.getElementById('modalCheckers').classList.remove('visible');document.getElementById('checkers-screen').classList.add('visible');setTimeout(initCheckers,50);}
        function initCheckers(){turn='white';selectedPiece=null;forcedPiece=null;document.getElementById('checkersStatus').innerText="Ход Белых";const el=document.getElementById('checkersBoard');el.innerHTML='';board=[];for(let r=0;r<BOARD_SIZE;r++){const row=[];for(let c=0;c<BOARD_SIZE;c++){const cell=document.createElement('div');const isDark=(r+c)%2!==0;cell.className=`ch-cell ${isDark?'dark':'light'}`;cell.onclick=()=>onBoardClick(r,c);el.appendChild(cell);let p=null;if(isDark){if(r<3)p={color:'black',isKing:false};if(r>4)p={color:'white',isKing:false};}row.push({piece:p,el:cell});if(p){const d=document.createElement('div');d.className=`checker ${p.color}`;cell.appendChild(d);}}board.push(row);}}
        function onBoardClick(r,c){ if (isOnlineGame) { if (turn !== onlineMyColor) return; } else { if(isPvE && turn==='black') return; } const cell=board[r][c]; if(cell.piece&&cell.piece.color===turn){if(forcedPiece&&(forcedPiece.r!==r||forcedPiece.c!==c))return;if(selectedPiece){const p=board[selectedPiece.r][selectedPiece.c].el.querySelector('.checker');if(p)p.classList.remove('selected');board.forEach(row=>row.forEach(cl=>cl.el.classList.remove('highlight')));}selectedPiece={r,c};cell.el.querySelector('.checker').classList.add('selected');highlightMoves(r,c);tg.HapticFeedback.selectionChanged();return;}if(!cell.piece&&selectedPiece){const moves=getValidMoves(selectedPiece.r,selectedPiece.c,board);const move=moves.find(m=>m.toR===r&&m.toC===c);if(move)executeMove(move, true);} }
        function highlightMoves(r,c){const moves=getValidMoves(r,c,board);moves.forEach(m=>board[m.toR][m.toC].el.classList.add('highlight'));}
        function getValidMoves(r,c,b){const p=b[r][c].piece;if(!p)return[];const moves=[],dirs=[[-1,-1],[-1,1],[1,-1],[1,1]];dirs.forEach(d=>{let dist=1;while(true){let nr=r+d[0]*dist,nc=c+d[1]*dist;if(nr<0||nr>=8||nc<0||nc>=8)break;if(!b[nr][nc].piece){if(!p.isKing){const fwd=(p.color==='white'&&d[0]===-1)||(p.color==='black'&&d[0]===1);if(fwd&&dist===1&&!forcedPiece)moves.push({fromR:r,fromC:c,toR:nr,toC:nc,isCapture:false});break;}else{if(!forcedPiece)moves.push({fromR:r,fromC:c,toR:nr,toC:nc,isCapture:false});}}else{if(b[nr][nc].piece.color===p.color)break;let jr=nr+d[0],jc=nc+d[1];if(jr>=0&&jr<8&&jc>=0&&jc<8&&!b[jr][jc].piece){if(p.isKing){let fd=1;while(true){let fr=nr+d[0]*fd,fc=nc+d[1]*fd;if(fr<0||fr>=8||fc<0||fc>=8||b[fr][fc].piece)break;moves.push({fromR:r,fromC:c,toR:fr,toC:fc,isCapture:true,midR:nr,midC:nc});fd++;}}else{moves.push({fromR:r,fromC:c,toR:jr,toC:jc,isCapture:true,midR:nr,midC:nc});}}break;}dist++;if(!p.isKing)break;}});const caps=moves.filter(m=>m.isCapture);return caps.length>0?caps:moves;}
        function executeMove(m, isLocal = true){ const p=board[m.fromR][m.fromC].piece; if(isOnlineGame && isLocal) { socket.emit('move', { roomCode: onlineRoomCode, move: m }); } board[m.toR][m.toC].piece=p;board[m.fromR][m.fromC].piece=null;board[m.fromR][m.fromC].el.innerHTML='';const pd=document.createElement('div');pd.className=`checker ${p.color} ${p.isKing?'king':''}`;board[m.toR][m.toC].el.appendChild(pd);if(m.isCapture){board[m.midR][m.midC].piece=null;board[m.midR][m.midC].el.innerHTML='';tg.HapticFeedback.notificationOccurred('warning');let prom=false;if(!p.isKing&&((p.color==='white'&&m.toR===0)||(p.color==='black'&&m.toR===7))){p.isKing=true;pd.classList.add('king');prom=true;}if(!prom){const next=getValidMoves(m.toR,m.toC,board);if(next.some(nm=>nm.isCapture)){forcedPiece={r:m.toR,c:m.toC};selectedPiece={r:m.toR,c:m.toC};pd.classList.add('selected');highlightMoves(m.toR,m.toC);if(isPvE&&turn==='black')setTimeout(aiMove,500);return;}}}else{tg.HapticFeedback.selectionChanged();if(!p.isKing&&((p.color==='white'&&m.toR===0)||(p.color==='black'&&m.toR===7))){p.isKing=true;pd.classList.add('king');tg.HapticFeedback.notificationOccurred('success');}}board.forEach(row=>row.forEach(cl=>cl.el.classList.remove('highlight')));selectedPiece=null;forcedPiece=null; checkWin(); turn=turn==='white'?'black':'white'; document.getElementById('checkersStatus').innerText=turn==='white'?"Ход Белых":"Ход Чёрных"; if (!hasAnyMoves(turn)) { const winner = turn === 'white' ? 'black' : 'white'; endGame(winner); return; } if(!isOnlineGame && isPvE && turn==='black') setTimeout(aiMove, 600); }
        function aiMove(){ if(isOnlineGame) return; const pcs=[];for(let r=0;r<8;r++)for(let c=0;c<8;c++)if(board[r][c].piece&&board[r][c].piece.color==='black')pcs.push({r,c});if(forcedPiece){const ms=getValidMoves(forcedPiece.r,forcedPiece.c,board);if(ms.length>0)executeMove(ms[0]);return;}let all=[];pcs.forEach(p=>{const ms=getValidMoves(p.r,p.c,board);ms.forEach(m=>{let s=0;if(m.isCapture)s+=10;if(m.toR===7)s+=5;if(m.toR>p.r)s+=1;all.push({m,s:s+Math.random()});});});if(all.length>0){all.sort((a,b)=>b.s-a.s);executeMove(all[0].m);}else endGame('white'); }
        function hasAnyMoves(color) { for(let r=0; r<8; r++) { for(let c=0; c<8; c++) { const cell = board[r][c]; if (cell.piece && cell.piece.color === color) { const moves = getValidMoves(r, c, board); if (moves.length > 0) return true; } } } return false; }
        function checkWin(){let wc=0,bc=0;board.forEach(r=>r.forEach(c=>{if(c.piece)c.piece.color==='white'?wc++:bc++}));if(bc===0)endGame('white');else if(wc===0)endGame('black');}
        function endGame(w){ const tit=document.getElementById('resText'); tit.innerText = w==='white'?"Белые победили!":"Чёрные победили!"; document.getElementById('modalResult').classList.add('visible'); if(isOnlineGame) socket.emit('game_over', { roomCode: onlineRoomCode, winner: w }); }

        /* --- BLOCK BLAST (RESTORED) --- */
        const BB_ROWS=8, BB_COLS=8; let bbGrid=[], bbScore=0, bbDisplayedScore=0, bbShapes=[], bbState=null, bbCombo=0, bbComboBuffer=0, bbIsAnimating=false; 
        const SHAPES = [[[1]],[[1,1]],[[1],[1]],[[1,1,1]],[[1],[1],[1]],[[1,1,1,1]],[[1],[1],[1],[1]],[[1,1,1,1,1]],[[1],[1],[1],[1],[1]],[[1,1],[1,1]],[[1,1,1],[1,1,1]],[[1,1],[1,1],[1,1]],[[1,1,1],[1,1,1],[1,1,1]],[[1,0],[1,0],[1,1]],[[1,1,1],[1,0,0]],[[1,1],[0,1],[0,1]],[[0,0,1],[1,1,1]],[[0,1],[0,1],[1,1]],[[1,0,0],[1,1,1]],[[1,1],[1,0],[1,0]],[[1,1,1],[0,0,1]],[[1,0],[1,1]],[[1,1],[1,0]],[[1,1],[0,1]],[[0,1],[1,1]],[[1,1,1],[0,1,0]],[[0,1,0],[1,1,1]],[[1,0],[1,1],[1,0]],[[0,1],[1,1],[0,1]]];
        const COLORS = ['bb-c-1','bb-c-2','bb-c-3','bb-c-4','bb-c-5','bb-c-6','bb-c-7'];
        const DRAG_LIFT_Y = 150; 
        function startBlockBlastCheck() { if(localStorage.getItem('bb_state')) document.getElementById('modalBBResume').classList.add('visible'); else newGameBB(); }
        function resumeBB() { document.getElementById('modalBBResume').classList.remove('visible'); document.getElementById('bb-screen').classList.add('visible'); restoreBBState(); }
        function newGameBB() { document.getElementById('modalBBResume').classList.remove('visible'); document.getElementById('bb-screen').classList.add('visible'); initBB(); }
        function initBB() { bbGrid = Array(BB_ROWS).fill().map(() => Array(BB_COLS).fill(0)); bbScore = 0; bbDisplayedScore = 0; bbCombo=0; bbComboBuffer=0; bbIsAnimating=false; updateBBScoreUI(); document.getElementById('bbBestScore').innerText = localStorage.getItem('bb_best_score') || 0; renderBBGrid(); spawnShapes(); saveBBState(); }
        function renderBBGrid() { const el = document.getElementById('bbGrid'); el.innerHTML = ''; for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { const cell = document.createElement('div'); cell.className = 'bb-cell'; cell.dataset.r = r; cell.dataset.c = c; if(bbGrid[r][c] !== 0) { cell.classList.add('filled', bbGrid[r][c]); } el.appendChild(cell); } } }
        function countFreeCells() { let free = 0; for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { if(bbGrid[r][c] === 0) free++; } } return free; }
        function spawnShapes() { bbShapes = []; const freeCells = countFreeCells(); let availableIndices = []; for(let i=0; i<SHAPES.length; i++) { const matrix = SHAPES[i]; const size = matrix.reduce((acc, row) => acc + row.reduce((a,b)=>a+b, 0), 0); if (freeCells < 25) { if (size <= 4) availableIndices.push(i); } else { availableIndices.push(i); } } for(let i=0; i<3; i++) { const rand = Math.floor(Math.random() * availableIndices.length); const shapeIdx = availableIndices[rand]; const color = COLORS[Math.floor(Math.random() * COLORS.length)]; bbShapes.push({ matrix: SHAPES[shapeIdx], color: color, id: i }); renderShapePreview(i, SHAPES[shapeIdx], color); } }
        function renderShapePreview(slotId, matrix, color) { const container = document.getElementById(`shape${slotId}`); container.innerHTML = ''; if(!matrix) return; const preview = document.createElement('div'); preview.className = 'bb-shape-preview'; preview.style.gridTemplateColumns = `repeat(${matrix[0].length}, 18px)`; matrix.forEach((row, ri) => { row.forEach((val, ci) => { const b = document.createElement('div'); if(val) { b.className = `bb-block ${color}`; b.dataset.ri = ri; b.dataset.ci = ci; } else { b.style.opacity = 0; } preview.appendChild(b); }); }); container.appendChild(preview); container.ontouchstart = (e) => startDrag(e, slotId, matrix, color); container.onmousedown = (e) => startDrag(e, slotId, matrix, color); }
        let draggedElement = null; let dragGhost = null; let dragData = null; let touchOffsetX = 0, touchOffsetY = 0;
        function hexToRgba(hex, alpha) { const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }
        function startDrag(e, slotId, matrix, color) { 
            if(bbIsAnimating) return; e.preventDefault(); const touch = e.touches ? e.touches[0] : e; const gridRect = document.getElementById('bbGrid').getBoundingClientRect(); const cellFullSize = gridRect.width / 8; dragData = { slotId, matrix, color }; dragGhost = document.createElement('div'); dragGhost.className = 'drag-ghost'; dragGhost.style.gridTemplateColumns = `repeat(${matrix[0].length}, ${cellFullSize}px)`; dragGhost.style.gridTemplateRows = `repeat(${matrix.length}, ${cellFullSize}px)`; dragGhost.style.gap = '4px'; dragGhost.style.display = 'grid'; const shapePixelW = matrix[0].length * cellFullSize; 
            matrix.forEach((row, ri) => { row.forEach((val, ci) => { const b = document.createElement('div'); if(val) { b.className = `bb-block ${color}`; b.dataset.ri = ri; b.dataset.ci = ci; } else { b.style.opacity = 0; } dragGhost.appendChild(b); }); }); 
            document.body.appendChild(dragGhost); touchOffsetX = (shapePixelW / 2); touchOffsetY = (shapePixelW / 2); moveGhost(touch.clientX, touch.clientY); const preview = document.querySelector(`#shape${slotId} .bb-shape-preview`); if(preview) preview.style.opacity = 0; document.addEventListener('touchmove', onTouchMove, {passive: false}); document.addEventListener('touchend', onTouchEnd); document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onTouchEnd); 
        }
        function onTouchMove(e) { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }
        function onMouseMove(e) { e.preventDefault(); handleMove(e.clientX, e.clientY); }
        function handleMove(x, y) { const ghostX = x - touchOffsetX; const ghostY = y - touchOffsetY - DRAG_LIFT_Y; if(dragGhost) { dragGhost.style.left = ghostX + 'px'; dragGhost.style.top = ghostY + 'px'; } const gridRect = document.getElementById('bbGrid').getBoundingClientRect(); const cellFullSize = gridRect.width / 8; const relX = ghostX - gridRect.left; const relY = ghostY - gridRect.top; const col = Math.round(relX / cellFullSize); const row = Math.round(relY / cellFullSize); checkPlacement(row, col); }
        function moveGhost(x, y) { const ghostX = x - touchOffsetX; const ghostY = y - touchOffsetY - DRAG_LIFT_Y; if(dragGhost) { dragGhost.style.left = ghostX + 'px'; dragGhost.style.top = ghostY + 'px'; } }
        function checkPlacement(r, c) { document.querySelectorAll('.bb-cell.bb-shadow').forEach(c => c.classList.remove('bb-shadow', 'bb-c-1','bb-c-2','bb-c-3','bb-c-4','bb-c-5','bb-c-6','bb-c-7')); document.querySelectorAll('.bb-cell.pre-clear').forEach(c => { c.classList.remove('pre-clear'); c.style.backgroundColor = ''; }); if(canPlace(dragData.matrix, r, c)) { drawShadow(dragData.matrix, r, c, dragData.color); dragData.validPos = { r: r, c: c }; let tempGrid = bbGrid.map(row => [...row]); let rowsToClear = [], colsToClear = []; for(let i=0; i<dragData.matrix.length; i++) { for(let j=0; j<dragData.matrix[0].length; j++) { if(dragData.matrix[i][j] === 1) tempGrid[r+i][c+j] = 1; } } for(let rr=0; rr<BB_ROWS; rr++) if(tempGrid[rr].every(val => val !== 0)) rowsToClear.push(rr); for(let cc=0; cc<BB_COLS; cc++) { let full = true; for(let rr=0; rr<BB_ROWS; rr++) if(tempGrid[rr][cc] === 0) full = false; if(full) colsToClear.push(cc); } rowsToClear.forEach(rr => { for(let cc=0; cc<BB_COLS; cc++) highlightPreClear(rr, cc, dragData.color); }); colsToClear.forEach(cc => { for(let rr=0; rr<BB_ROWS; rr++) highlightPreClear(rr, cc, dragData.color); }); } else { dragData.validPos = null; } }
        function highlightPreClear(r, c, colorClass) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); if(cell) { cell.classList.add('pre-clear'); const hex = COLOR_MAP[colorClass] || '#007aff'; cell.style.backgroundColor = hexToRgba(hex, 0.4); } }
        function canPlace(matrix, r, c) { for(let i=0; i<matrix.length; i++) { for(let j=0; j<matrix[0].length; j++) { if(matrix[i][j] === 1) { let nr = r + i; let nc = c + j; if(nr < 0 || nr >= BB_ROWS || nc < 0 || nc >= BB_COLS || bbGrid[nr][nc] !== 0) return false; } } } return true; }
        function drawShadow(matrix, r, c, color) { for(let i=0; i<matrix.length; i++) { for(let j=0; j<matrix[0].length; j++) { if(matrix[i][j] === 1) { const cell = document.querySelector(`.bb-cell[data-r="${r+i}"][data-c="${c+j}"]`); if(cell) cell.classList.add('bb-shadow', color); } } } }
        function onTouchEnd(e) { document.removeEventListener('touchmove', onTouchMove); document.removeEventListener('touchend', onTouchEnd); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onTouchEnd); if(dragGhost) dragGhost.remove(); document.querySelectorAll('.bb-cell.pre-clear').forEach(c => { c.classList.remove('pre-clear'); c.style.backgroundColor = ''; }); document.querySelectorAll('.bb-cell.bb-shadow').forEach(c => c.classList.remove('bb-shadow', 'bb-c-1','bb-c-2','bb-c-3','bb-c-4','bb-c-5','bb-c-6','bb-c-7')); const original = document.querySelector(`#shape${dragData.slotId} .bb-shape-preview`); if(original) original.style.opacity = 1; if(dragData.validPos) { placeShape(dragData.matrix, dragData.validPos.r, dragData.validPos.c, dragData.color); document.getElementById(`shape${dragData.slotId}`).innerHTML = ''; const container = document.getElementById(`shape${dragData.slotId}`); container.ontouchstart = null; container.onmousedown = null; bbShapes[dragData.slotId] = null; const linesCleared = checkLines(dragData.color); if(linesCleared === 0) { if (bbCombo > 0) { bbComboBuffer--; if(bbComboBuffer <= 0) { bbCombo = 0; updateBBScoreUI(); } } if(bbShapes.every(s => s === null)) spawnShapes(); checkGameOver(); saveBBState(); } else { if(bbShapes.every(s => s === null)) spawnShapes(); } } }
        function placeShape(matrix, r, c, color) { tg.HapticFeedback.impactOccurred('light'); let placedCount = 0; for(let i=0; i<matrix.length; i++) { for(let j=0; j<matrix[0].length; j++) { if(matrix[i][j] === 1) { bbGrid[r+i][c+j] = color; const cell = document.querySelector(`.bb-cell[data-r="${r+i}"][data-c="${c+j}"]`); cell.classList.add('no-transition'); cell.classList.add('filled', color); cell.style.backgroundColor = ''; setTimeout(() => cell.classList.remove('no-transition'), 50); placedCount++; } } } addScore(placedCount); }
        function checkLines(triggerColor) { let linesCleared = 0; const rowsToClear = []; const colsToClear = []; for(let r=0; r<BB_ROWS; r++) { if(bbGrid[r].every(val => val !== 0)) rowsToClear.push(r); } for(let c=0; c<BB_COLS; c++) { let full = true; for(let r=0; r<BB_ROWS; r++) if(bbGrid[r][c] === 0) full = false; if(full) colsToClear.push(c); } const totalCleared = rowsToClear.length + colsToClear.length; if(totalCleared > 0) { bbCombo++; bbComboBuffer = 3; updateBBScoreUI(); tg.HapticFeedback.notificationOccurred('success'); if(!isLiteMode) document.querySelector('.bb-game-container').classList.add('shake-screen'); rowsToClear.forEach(r => { if(!isLiteMode) fireNeonParticles(r, -1, triggerColor); for(let c=0; c<BB_COLS; c++) { bbGrid[r][c] = 0; animateClear(r, c, triggerColor); } }); colsToClear.forEach(c => { if(!isLiteMode) fireNeonParticles(-1, c, triggerColor); for(let r=0; r<BB_ROWS; r++) { bbGrid[r][c] = 0; animateClear(r, c, triggerColor); } }); setTimeout(() => { document.querySelector('.bb-game-container').classList.remove('shake-screen'); let points = totalCleared * 10; if (totalCleared >= 2) { points = points * totalCleared; showComboPopup(`X${totalCleared} MULTIPLIER!`); } else if(bbCombo > 1) { points += bbCombo * 10; showComboPopup(`COMBO x${bbCombo}!`); } addScore(points); saveBBState(); setTimeout(checkAllClear, 50); checkGameOver(); }, 350); return totalCleared; } return 0; }
        function fireNeonParticles(row, col, colorClass) { const hex = COLOR_MAP[colorClass] || '#ffffff'; const gridRect = document.getElementById('bbGrid').getBoundingClientRect(); const cellW = gridRect.width / 8; const cellH = gridRect.height / 8; let xOrigin, yOrigin; if (row !== -1) { xOrigin = (gridRect.left + gridRect.width / 2) / window.innerWidth; yOrigin = (gridRect.top + (row * cellH) + (cellH/2)) / window.innerHeight; } else { xOrigin = (gridRect.left + (col * cellW) + (cellW/2)) / window.innerWidth; yOrigin = (gridRect.top + gridRect.height / 2) / window.innerHeight; } confetti({ particleCount: 40, startVelocity: 35, spread: 360, origin: { x: xOrigin, y: yOrigin }, colors: [hex, '#ffffff'], shapes: ['square'], scalar: 0.5, drift: 0, ticks: 50, gravity: 0.5, zIndex: 11000, disableForReducedMotion: true }); }
        function showComboPopup(text) { const p = document.createElement('div'); p.className = 'combo-popup'; p.innerText = text; document.querySelector('.bb-game-container').appendChild(p); setTimeout(() => p.remove(), 1000); }
        function animateClear(r, c, color) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); if(cell) { cell.className = 'bb-cell'; cell.style.backgroundColor = ''; cell.style.boxShadow = ''; cell.classList.add('appear-gray'); setTimeout(() => { cell.classList.remove('appear-gray'); }, 400); } }
        function addScore(points) { bbScore += points; const target = bbScore; const step = Math.ceil((target - bbDisplayedScore) / 10); const int = setInterval(() => { bbDisplayedScore += step; if(bbDisplayedScore >= target) { bbDisplayedScore = target; clearInterval(int); } updateBBScoreUI(); }, 30); }
        function updateBBScoreUI() { const el = document.getElementById('bbScore'); el.innerText = bbDisplayedScore; if(bbCombo > 0) el.classList.add('active-combo'); else el.classList.remove('active-combo'); }
        function checkAllClear() { if(bbIsAnimating) return; const free = countFreeCells(); if(free === BB_ROWS * BB_COLS) { bbIsAnimating = true; tg.HapticFeedback.notificationOccurred('success'); const bonus = 500 * (bbCombo > 0 ? bbCombo : 1); let delay = 0; for(let r=BB_ROWS-1; r>=0; r--) { setTimeout(() => { for(let c=0; c<BB_COLS; c++) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); const randColor = COLORS[Math.floor(Math.random()*COLORS.length)]; cell.className = `bb-cell filled ${randColor}`; } tg.HapticFeedback.impactOccurred('light'); }, delay); delay += 50; } setTimeout(() => { for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); cell.className = 'bb-cell clearing'; } } setTimeout(() => { renderBBGrid(); }, 200); const container = document.querySelector('.bb-game-container'); const pop = document.createElement('div'); pop.className = 'all-clear-popup'; pop.innerHTML = `<div class="ac-text">UNBELIEVABLE</div><div class="ac-score">+${bonus}</div>`; container.appendChild(pop); confetti({ particleCount: 150, spread: 100, origin: { y: 0.5 }, zIndex: 11000 }); addScore(bonus); setTimeout(() => { pop.remove(); bbIsAnimating = false; saveBBState(); }, 2000); }, delay + 200); } }
        async function checkGameOver() { if(bbIsAnimating) return; const shapesLeft = bbShapes.filter(s => s !== null); if(shapesLeft.length === 0) return; const canMove = shapesLeft.some(s => { for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { if(canPlace(s.matrix, r, c)) return true; } } return false; }); if(!canMove) { tg.HapticFeedback.notificationOccurred('error'); await animateGameOverFill(); const currentBest = parseInt(localStorage.getItem('bb_best_score') || 0); const isRecord = bbScore > currentBest; if(isRecord) { saveStatToCloud('bb_best_score', bbScore); sendStatToBackend('bb_best_score', bbScore); } localStorage.removeItem('bb_state'); let t = parseInt(localStorage.getItem('bb_total_games')||0)+1; saveStatToCloud('bb_total_games', t); sendStatToBackend('bb_total_games', t); showBBGameOverModal(isRecord, bbScore, currentBest); } }
        function animateGameOverFill() { return new Promise(resolve => { const emptyCells = []; for(let r=BB_ROWS-1; r>=0; r--) { for(let c=0; c<BB_COLS; c++) { if(bbGrid[r][c] === 0) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); emptyCells.push(cell); } } } let i = 0; const int = setInterval(() => { if(i >= emptyCells.length) { clearInterval(int); setTimeout(resolve, 300); return; } const cell = emptyCells[i]; const color = COLORS[Math.floor(Math.random() * COLORS.length)]; if(cell) cell.classList.add('filled', color); i++; }, 10); }); }
        function showBBGameOverModal(isRecord, score, oldBest) { const modal = document.getElementById('bbGameOverContent'); const overlay = document.getElementById('modalBBGameOver'); modal.innerHTML = ''; if(isRecord) { confetti({ particleCount: 200, spread: 100, origin: { y: 0.6 }, zIndex: 22000 }); modal.innerHTML = `${ICON_CROWN}<h2 style="margin:0 0 10px 0; font-size:24px;">Новый Рекорд!</h2><div style="font-size:48px; font-weight:800; color:var(--accent); margin:10px 0;" id="recCounter">0</div><button class="btn-main" onclick="closeResult(); newGameBB();">Играть снова</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="closeResult()">Выйти</button>`; let s = oldBest; const step = Math.ceil((score - oldBest) / 30); const counter = document.getElementById('recCounter'); const int = setInterval(() => { s += step; if(s >= score) { s = score; clearInterval(int); } counter.innerText = s; }, 30); } else { modal.innerHTML = `<h2 style="margin:0 0 5px 0;">Рекорд не побит</h2><p style="color:#8e8e93; margin:0 0 20px 0;">Попробуйте еще раз!</p><div style="font-size:32px; font-weight:700;">${score}</div><div style="font-size:14px; color:#8e8e93; margin-bottom:20px;">Лучший: ${oldBest}</div><button class="btn-main" onclick="closeResult(); newGameBB();">Новая игра</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="closeResult()">Выйти</button>`; } overlay.classList.add('visible'); }
        function saveBBState() { if(bbShapes.every(s=>s===null)) return; const state = { grid: bbGrid, score: bbScore, shapes: bbShapes, combo: bbCombo, buffer: bbComboBuffer }; localStorage.setItem('bb_state', JSON.stringify(state)); }
        function restoreBBState() { const data = JSON.parse(localStorage.getItem('bb_state')); if(!data) { initBB(); return; } bbGrid = data.grid; bbScore = data.score; bbCombo = data.combo || 0; bbComboBuffer = data.buffer || 0; bbDisplayedScore = bbScore; bbShapes = data.shapes; updateBBScoreUI(); document.getElementById('bbBestScore').innerText = localStorage.getItem('bb_best_score') || 0; renderBBGrid(); for(let i=0; i<3; i++) { if(bbShapes[i]) renderShapePreview(i, bbShapes[i].matrix, bbShapes[i].color); else document.getElementById(`shape${i}`).innerHTML = ''; } }
        function showResult(title, text, btnText="Закрыть", action=null) { document.getElementById('resTitle').innerText=title; document.getElementById('resText').innerText=text; const btn=document.getElementById('resBtn'); btn.innerText=btnText; btn.onclick=action?action:closeResult; document.getElementById('modalResult').classList.add('visible'); }

        /* --- SUDOKU LOGIC (RESTORED) --- */
        let sudoBoard = [], sudoSolution = [], activeDigit = null, sudoLives = 3, sudoFilled = 0; let selectedSudoDiff = 40; let currentSudoMode = 1;
        function startSudokuCheck() { if(localStorage.getItem('sudo_state')) document.getElementById('modalSudokuResume').classList.add('visible'); else document.getElementById('modalSudoku').classList.add('visible'); }
        function resumeSudoku() { document.getElementById('modalSudokuResume').classList.remove('visible'); document.getElementById('sudoku-screen').classList.add('visible'); restoreSudokuState(); }
        function selectSudokuDiff(diff, btn, index) { selectedSudoDiff = diff; const glider = document.getElementById('sudokuGlider'); glider.style.transform = `translateY(${index * 100}%)`; const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active'); tg.HapticFeedback.selectionChanged(); }
        function startSudoku() { document.getElementById('modalSudoku').classList.remove('visible'); document.getElementById('sudoku-screen').classList.add('visible'); generateSudoku(selectedSudoDiff); }
        function generateSudoku(holes) {
            if (holes === 30) currentSudoMode = 1; else if (holes === 40) currentSudoMode = 2; else currentSudoMode = 3;
            sudoBoard = Array(81).fill(0); sudoSolution = Array(81).fill(0); sudoLives = 3; sudoFilled = 0; activeDigit = null; document.querySelectorAll('.num-btn').forEach(b => { b.classList.remove('active-digit', 'disabled'); });
            document.getElementById('sudokuLives').innerText = "0/3"; document.getElementById('sudokuLives').style.color = "var(--text-color)";
            fillSudo(0, 0); sudoSolution = [...sudoBoard]; let removed = 0; while (removed < holes) { let idx = Math.floor(Math.random() * 81); if (sudoBoard[idx] !== 0) { sudoBoard[idx] = 0; removed++; } }
            renderSudoku(); checkNumberCompletion(); saveSudokuState();
        }
        function fillSudo(row, col) { if (col === 9) { row++; col = 0; } if (row === 9) return true; const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5); for (let num of nums) { if (isValidSudo(sudoBoard, row, col, num)) { sudoBoard[row * 9 + col] = num; if (fillSudo(row, col + 1)) return true; sudoBoard[row * 9 + col] = 0; } } return false; }
        function isValidSudo(board, row, col, num) { for (let x = 0; x < 9; x++) if (board[row * 9 + x] === num) return false; for (let x = 0; x < 9; x++) if (board[x * 9 + col] === num) return false; let startRow = Math.floor(row / 3) * 3, startCol = Math.floor(col / 3) * 3; for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) if (board[(startRow + i) * 9 + (startCol + j)] === num) return false; return true; }
        function renderSudoku() { const el = document.getElementById('sudokuBoard'); el.innerHTML = ''; sudoFilled = 0; for (let i = 0; i < 81; i++) { const cell = document.createElement('div'); cell.className = 'sudo-cell'; if (sudoBoard[i] !== 0) { cell.innerText = sudoBoard[i]; cell.classList.add('given'); sudoFilled++; } cell.onclick = () => onCellClick(i, cell); cell.dataset.idx = i; el.appendChild(cell); } }
        function activateDigit(num, btn) { if (btn.classList.contains('disabled')) return; if (activeDigit === num) { activeDigit = null; btn.classList.remove('active-digit'); highlightSameNumbers(null); tg.HapticFeedback.selectionChanged(); return; } activeDigit = num; document.querySelectorAll('.num-btn').forEach(b => b.classList.remove('active-digit')); btn.classList.add('active-digit'); highlightSameNumbers(num); tg.HapticFeedback.selectionChanged(); }
        function highlightSameNumbers(num) { const cells = document.querySelectorAll('.sudo-cell'); cells.forEach(c => c.classList.remove('same-num')); if (num === null) return; cells.forEach(cell => { if (parseInt(cell.innerText) === num) cell.classList.add('same-num'); }); }
        function checkNumberCompletion() { for(let i=1; i<=9; i++) { let count = 0; for(let j=0; j<81; j++) if(sudoBoard[j] === i) count++; const btn = document.getElementById(`nb${i}`); if(count >= 9) { btn.classList.add('disabled'); btn.classList.remove('active-digit'); if(activeDigit === i) { activeDigit = null; highlightSameNumbers(null); } } else { btn.classList.remove('disabled'); } } }
        function onCellClick(idx, cell) { if (activeDigit === null) return; if (sudoBoard[idx] !== 0) return; const correctVal = sudoSolution[idx]; if (activeDigit === correctVal) { cell.innerText = activeDigit; cell.classList.add('user-val', 'correct', 'same-num'); sudoBoard[idx] = activeDigit; sudoFilled++; tg.HapticFeedback.notificationOccurred('success'); cell.animate([{ transform: 'scale(0.5)' }, { transform: 'scale(1.2)' }, { transform: 'scale(1)' }], { duration: 300 }); checkNumberCompletion(); saveSudokuState(); checkSudokuWin(); } else { cell.innerText = activeDigit; cell.classList.add('error'); tg.HapticFeedback.notificationOccurred('error'); sudoLives--; document.getElementById('sudokuLives').innerText = `${3-sudoLives}/3`; document.getElementById('sudokuLives').style.color = "var(--danger)"; setTimeout(() => { cell.innerText = ''; cell.classList.remove('error'); }, 400); saveSudokuState(); if (sudoLives <= 0) { localStorage.removeItem('sudo_state'); setTimeout(() => showResult('Поражение', 'Слишком много ошибок'), 500); } } }
        function checkSudokuWin() { if (sudoFilled === 81) { confetti({particleCount:150,spread:70,origin:{y:0.6},zIndex:2147483647}); let points = currentSudoMode; let w = parseInt(localStorage.getItem('sudoku_wins')||0) + points; saveStatToCloud('sudoku_wins', w); sendStatToBackend('sudoku_wins', w); localStorage.removeItem('sudo_state'); showResult('Победа!', `Судоку решено! (+${points})`); } }
        function saveSudokuState() { if(sudoFilled === 81 || sudoLives <= 0) return; const state = { board: sudoBoard, sol: sudoSolution, lives: sudoLives, mode: currentSudoMode }; localStorage.setItem('sudo_state', JSON.stringify(state)); }
        function restoreSudokuState() { const data = JSON.parse(localStorage.getItem('sudo_state')); if(!data) { generateSudoku(40); return; } sudoBoard = data.board; sudoSolution = data.sol; sudoLives = data.lives; currentSudoMode = data.mode; document.getElementById('sudokuLives').innerText = `${3-sudoLives}/3`; if(sudoLives < 3) document.getElementById('sudokuLives').style.color = "var(--danger)"; renderSudoku(); checkNumberCompletion(); }

        // Start App
        initApp();
    </script>
</body>
</html>
