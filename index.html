<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Glass App v36.0 Tower Update</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script> 
    <style>
        :root { 
            --bg-color: #f2f2f7; 
            --text-color: #000000; 
            --glass-bg: rgba(255, 255, 255, 0.75); 
            --glass-border: rgba(255, 255, 255, 0.5); 
            --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.07); 
            --accent: #007aff; 
            --danger: #ff3b30; 
            --success: #34c759; 
            --tab-bg: rgba(255,255,255,0.95); 
            --toggle-bg: #e9e9ea; 
            --toggle-circle: #ffffff; 
            --icon-color: #3a3a3c; 
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            
            /* Game Specific Vars */
            --bb-grid: rgba(0,0,0,0.05); --bb-cell: rgba(255,255,255,0.5); 
            --sudoku-border: rgba(0,0,0,0.1); --sudoku-thick: #000000; 
            --sudoku-sel: rgba(0,122,255,0.25); --sudoku-same: rgba(0,122,255,0.2); --sudoku-err: rgba(255, 59, 48, 0.2);
            --rank-gold: #ffd700; --rank-silver: #c0c0c0; --rank-bronze: #cd7f32;
            
            /* Block Blast Colors */
            --bb-c-1: #ff3b30; --bb-c-2: #ff9500; --bb-c-3: #ffcc00; --bb-c-4: #34c759; --bb-c-5: #007aff; --bb-c-6: #5856d6; --bb-c-7: #af52de;
        }
        [data-theme="dark"] { 
            --bg-color: #000000; --text-color: #ffffff; 
            --glass-bg: rgba(30, 30, 30, 0.8); --glass-border: rgba(255, 255, 255, 0.15); 
            --shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5); 
            --tab-bg: rgba(30,30,30, 0.95); --toggle-bg: #2c2c2e; --toggle-circle: #636366; 
            --icon-color: #aeaeb2; --accent: #0a84ff; 
            --bb-grid: rgba(255,255,255,0.05); --bb-cell: rgba(255,255,255,0.1); 
            --sudoku-border: rgba(255,255,255,0.15); --sudoku-thick: #ffffff; 
            --sudoku-sel: rgba(10, 132, 255, 0.4); --sudoku-same: rgba(10, 132, 255, 0.25); --sudoku-err: rgba(255, 69, 58, 0.3); 
        }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; width: 100%; height: 100dvh; overflow: hidden; overscroll-behavior: none; touch-action: none; transition: background 0.4s; }
        
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 20px; padding-top: calc(80px + var(--safe-top)); padding-bottom: calc(100px + var(--safe-bottom)); overflow-y: auto; opacity: 0; pointer-events: none; transform: scale(0.98); transition: opacity 0.3s, transform 0.3s; } 
        .screen.active { opacity: 1; pointer-events: auto; transform: scale(1); z-index: 1; }
        
        .game-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-color); z-index: 9999; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1); touch-action: none; overflow: hidden; } 
        .game-overlay.visible { transform: translateY(0); }
        
        /* GENERAL UI */
        .card { background: var(--glass-bg); backdrop-filter: blur(20px); border-radius: 20px; border: 1px solid var(--glass-border); padding: 20px; margin-bottom: 15px; box-shadow: var(--shadow); display: flex; align-items: center; gap: 15px; cursor: pointer; transition: transform 0.1s; } .card:active { transform: scale(0.97); }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; margin-top: 10px; } .app-title { font-size: 28px; font-weight: 800; }
        .btn-main { background: var(--accent); color: white; border: none; padding: 14px; width: 100%; border-radius: 14px; font-size: 17px; font-weight: 600; cursor: pointer; }
        .input-glass { width: 100%; background: var(--toggle-bg); border: none; padding: 12px; border-radius: 12px; font-size: 16px; margin-bottom: 10px; text-align: center; }
        .modal-overlay { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.4); backdrop-filter: blur(5px); display: flex; align-items: center; justify-content: center; z-index: 10000; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal { background: var(--bg-color); width: 90%; max-width: 320px; padding: 20px; border-radius: 24px; text-align: center; max-height: 85vh; overflow-y: auto; }
        .back-btn { color: var(--accent); font-size: 17px; font-weight: 500; display: flex; align-items: center; gap: 4px; cursor: pointer; } 
        .game-top-bar { padding: 15px 20px; padding-top: calc(50px + var(--safe-top)); display: flex; justify-content: space-between; align-items: center; background: var(--bg-color); } 
        
        /* CHECKERS CSS */
        .checkers-board { display: flex; flex-wrap: wrap; width: 90vw; height: 90vw; max-width: 350px; max-height: 350px; background: #fff; border: 4px solid #000; border-radius: 4px; margin: 0 auto; transition: transform 0.5s; } .checkers-board.rotated { transform: rotate(180deg); }
        .ch-cell { width: 12.5%; height: 12.5%; display: flex; justify-content: center; align-items: center; position: relative; } .ch-cell.light { background: #fff !important; } .ch-cell.dark { background: #222 !important; } .ch-cell.highlight::after { content:''; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,122,255,0.5); pointer-events:none; } .checker { width: 80%; height: 80%; border-radius: 50%; position: relative; transition: transform 0.2s; z-index: 2; box-shadow: 0 3px 6px rgba(0,0,0,0.5); } .checker.white { background: #f0f0f0; border: 3px solid #ccc; } .checker.black { background: #444; border: 3px solid #777; } .checker.king::before { content:''; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:40%; height:40%; border-radius:50%; border:3px solid #ff3b30; } .checker.selected { transform: scale(1.15); border-color: var(--accent); z-index: 10; box-shadow: 0 0 15px rgba(0,122,255,0.8); }
        
        /* OTHER GAMES CSS */
        .segment-control { position: relative; background: var(--toggle-bg); border-radius: 30px; padding: 0; display: flex; width: 100%; margin-top: 15px; overflow: hidden; height: 46px; border: none; }
        .segment-glider { position: absolute; top: 0; left: 0; width: 50%; height: 100%; background: var(--accent); border-radius: 30px; z-index: 1; transition: transform 0.4s; }
        .segment-item { position: relative; flex: 1; text-align: center; font-size: 15px; font-weight: 600; color: var(--text-color); cursor: pointer; z-index: 2; transition: color 0.2s; display: flex; align-items: center; justify-content: center; opacity: 0.6; }
        .segment-item.active { color: white; opacity: 1; }
        .loader { border: 4px solid rgba(255,255,255,0.3); border-radius: 50%; border-top: 4px solid var(--accent); width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .game-icon-box { width: 48px; height: 48px; border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; }
        .panel-hidden { display: none; } .panel-visible { display: block; animation: fadeInSlide 0.3s ease forwards; } @keyframes fadeInSlide { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }
        
        .bb-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; width: 90vw; height: 90vw; max-width: 350px; background: var(--bb-grid); padding: 4px; border-radius: 12px; margin: 0 auto; } 
        .bb-cell { background: var(--bb-cell); border-radius: 6px; position:relative; overflow:hidden; } .bb-cell.filled { box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1); }
        .bb-shape-preview { display: grid; gap: 2px; transform: scale(0.8); pointer-events: none; }
        .bb-block { width: 18px; height: 18px; border-radius: 4px; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1); }
        .bb-block.bb-c-1 { background: var(--bb-c-1); } .bb-block.bb-c-2 { background: var(--bb-c-2); } .bb-block.bb-c-3 { background: var(--bb-c-3); } .bb-block.bb-c-4 { background: var(--bb-c-4); } .bb-block.bb-c-5 { background: var(--bb-c-5); } .bb-block.bb-c-6 { background: var(--bb-c-6); } .bb-block.bb-c-7 { background: var(--bb-c-7); }
        .bb-cell.bb-c-1 { background: var(--bb-c-1); } .bb-cell.bb-c-2 { background: var(--bb-c-2); } .bb-cell.bb-c-3 { background: var(--bb-c-3); } .bb-cell.bb-c-4 { background: var(--bb-c-4); } .bb-cell.bb-c-5 { background: var(--bb-c-5); } .bb-cell.bb-c-6 { background: var(--bb-c-6); } .bb-cell.bb-c-7 { background: var(--bb-c-7); }
        .drag-ghost { position: fixed; pointer-events: none; z-index: 1000; transform: translate(-50%, -50%); opacity: 0.9; }

        .sudo-board { display: grid; grid-template-columns: repeat(9, 1fr); width: 90vw; height: 90vw; max-width: 350px; background: var(--bg-color); border: 2px solid var(--sudoku-thick); margin: 0 auto; }
        .sudo-cell { border: 0.5px solid var(--sudoku-border); display: flex; justify-content: center; align-items: center; font-size: 20px; font-weight: 500; }
        .sudo-cell:nth-child(3n) { border-right: 2px solid var(--sudoku-thick); } .sudo-cell:nth-child(9n) { border-right: none; }
        .sudo-cell:nth-child(n+19):nth-child(-n+27), .sudo-cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid var(--sudoku-thick); }
        .sudo-cell.given { font-weight: 800; color: var(--text-color); } .sudo-cell.user-val { color: var(--accent); } .sudo-cell.active-digit { background: var(--sudoku-sel); } .sudo-cell.same-num { background: var(--sudoku-same); } .sudo-cell.error { background: var(--sudoku-err); animation: shake 0.3s; }

        .grid { display: grid; gap: 5px; padding: 10px; background: var(--glass-bg); border-radius: 16px; margin: 0 auto; }
        .cell { width: 38px; height: 38px; background: rgba(255,255,255,0.6); border-radius: 8px; display: flex; justify-content: center; align-items: center; font-weight: 700; cursor: pointer; }
        .cell.revealed { background: rgba(220,220,220,0.5); }
        .cell.c-1{color:#007aff;} .cell.c-2{color:#34c759;} .cell.c-3{color:#ff3b30;}
        
        /* TOWER GAME STYLE */
        #tower-screen { background: #222; overflow: hidden; }
        
    </style>
</head>
<body>

    <div id="view-games" class="screen active"> 
        <div class="header"> <div class="app-title">Игры</div> </div> 
        
        <div class="card" onclick="openGameModal('tower')"> 
            <div class="game-icon-box" style="background: linear-gradient(135deg, #FF2E93, #FF8C00);"> 
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg> 
            </div> 
            <div style="flex:1;"> 
                <h3 style="margin:0; font-size:17px;">Башня</h3> 
                <div style="font-size:10px; color:#ff3b30; font-weight:700; margin-top:2px;">ХИТ • РЕАКЦИЯ</div>
            </div> 
            <div style="color:var(--accent); font-weight:600;">Play</div> 
        </div>

        <div class="card" onclick="openGameModal('saper')"> <div class="game-icon-box" style="background: linear-gradient(135deg, #007aff, #5ac8fa);"> <svg viewBox="0 0 24 24" fill="currentColor" style="width:26px;height:26px;"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M12 7a5 5 0 1 0 5 5 5 5 0 0 0-5-5z"/></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Сапёр</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
        <div class="card" onclick="openGameModal('checkers')"> <div class="game-icon-box" style="background: linear-gradient(135deg, #ff3b30, #ff9500);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Шашки</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
        <div class="card" onclick="startBlockBlastCheck()"> <div class="game-icon-box" style="background: linear-gradient(135deg, #34c759, #30b0c7);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="9" height="9" rx="2"></rect><rect x="13" y="2" width="9" height="9" rx="2"></rect><rect x="2" y="13" width="9" height="9" rx="2"></rect></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Block Blast</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
        <div class="card" onclick="startSudokuCheck()"> <div class="game-icon-box" style="background: linear-gradient(135deg, #5856d6, #af52de);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></svg> </div> <div style="flex:1;"> <h3 style="margin:0; font-size:17px;">Судоку</h3> </div> <div style="color:var(--accent); font-weight:600;">Play</div> </div> 
    </div>
    
    <div id="view-profile" class="screen"> 
        <div class="header"><div class="app-title">Профиль</div></div> 
        <div style="display:flex; flex-direction:column; align-items:center;"> 
            <img id="user-avatar" src="" alt="" class="avatar" style="width:100px;height:100px;border-radius:50%;margin-bottom:15px;"> 
            <h2 id="user-name" style="margin:0;">Loading...</h2> 
            <p id="user-id" style="color:#8e8e93; margin:5px 0 20px;">@username</p> 
            <div class="settings-group" style="width:100%; background:var(--glass-bg); padding:15px; border-radius:15px;">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                    <span>Темная тема</span>
                    <div class="theme-switch" id="themeToggle" onclick="toggleTheme()" style="width:50px;height:30px;background:var(--toggle-bg);border-radius:20px;position:relative;"><div style="width:26px;height:26px;background:white;border-radius:50%;position:absolute;top:2px;left:2px;"></div></div>
                </div>
            </div>
            <div style="width:100%; display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top: 10px;"> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-saper-games" style="font-size:20px; font-weight:800; color:var(--accent);">0</div> <div style="font-size:12px; color:#8e8e93;">Сапёр Игр</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-saper-best" style="font-size:20px; font-weight:800; color:var(--success);">--</div> <div style="font-size:12px; color:#8e8e93;">Сапёр Рекорд</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-checkers-games" style="font-size:20px; font-weight:800; color:#ff3b30;">0</div> <div style="font-size:12px; color:#8e8e93;">Шашки Игр</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-checkers-wins" style="font-size:20px; font-weight:800; color:#ff9500;">0</div> <div style="font-size:12px; color:#8e8e93;">Побед над Ботом</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-bb-games" style="font-size:20px; font-weight:800; color:#34c759;">0</div> <div style="font-size:12px; color:#8e8e93;">Block Игр</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-bb-best" style="font-size:20px; font-weight:800; color:#30b0c7;">0</div> <div style="font-size:12px; color:#8e8e93;">Block Рекорд</div> </div> 
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-sudoku-wins" style="font-size:20px; font-weight:800; color:#5856d6;">0</div> <div style="font-size:12px; color:#8e8e93;">Судоку Побед</div> </div>
                <div style="background:var(--glass-bg); padding:15px; border-radius:15px; text-align:center;"> <div id="stat-tower-best" style="font-size:20px; font-weight:800; color:#FF2E93;">0</div> <div style="font-size:12px; color:#8e8e93;">Башня Рекорд</div> </div> 
            </div>
        </div> 
    </div>

    <div id="view-leaderboard" class="screen">
        <div class="header"><div class="app-title">Топы</div></div>
        <div class="card" onclick="openLeaderboardDetail('tower')">
            <div class="game-icon-box" style="background: linear-gradient(135deg, #FF2E93, #FF8C00);"> 
                 <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
            </div>
            <div style="flex:1;"><h3 style="margin:0; font-size:17px;">Топы Башни</h3></div>
            <div style="color:#8e8e93;">></div>
        </div>

        <div class="card" onclick="openLeaderboardDetail('saper')">
            <div class="game-icon-box" style="background: linear-gradient(135deg, #007aff, #5ac8fa);"> <svg viewBox="0 0 24 24" fill="currentColor" style="width:26px;height:26px;"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><path d="M12 7a5 5 0 1 0 5 5 5 5 0 0 0-5-5z"/></svg> </div>
            <div style="flex:1;"><h3 style="margin:0; font-size:17px;">Топы Сапёра</h3></div>
            <div style="color:#8e8e93;">></div>
        </div>
        <div class="card" onclick="openLeaderboardDetail('checkers')">
            <div class="game-icon-box" style="background: linear-gradient(135deg, #ff3b30, #ff9500);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle></svg> </div>
            <div style="flex:1;"><h3 style="margin:0; font-size:17px;">Топы Шашек</h3></div>
            <div style="color:#8e8e93;">></div>
        </div>
        <div class="card" onclick="openLeaderboardDetail('bb')">
            <div class="game-icon-box" style="background: linear-gradient(135deg, #34c759, #30b0c7);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="9" height="9" rx="2"></rect><rect x="13" y="2" width="9" height="9" rx="2"></rect><rect x="2" y="13" width="9" height="9" rx="2"></rect></svg> </div>
            <div style="flex:1;"><h3 style="margin:0; font-size:17px;">Топы Block Blast</h3></div>
            <div style="color:#8e8e93;">></div>
        </div>
        <div class="card" onclick="openLeaderboardDetail('sudoku')">
            <div class="game-icon-box" style="background: linear-gradient(135deg, #5856d6, #af52de);"> <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></svg> </div>
            <div style="flex:1;"><h3 style="margin:0; font-size:17px;">Топы Судоку</h3></div>
            <div style="color:#8e8e93;">></div>
        </div>
    </div>

    <div class="tab-bar" style="position:fixed; bottom:0; width:100%; height:80px; background:var(--tab-bg); display:flex; justify-content:space-around; align-items:center; z-index:50; border-top:0.5px solid rgba(0,0,0,0.1);"> 
        <div class="tab-item active" onclick="switchTab('games', this)" style="text-align:center; flex:1;">Games</div> 
        <div class="tab-item" onclick="switchTab('leaderboard', this)" style="text-align:center; flex:1;">Tops</div>
        <div class="tab-item" onclick="switchTab('profile', this)" style="text-align:center; flex:1;">Profile</div> 
    </div>

    <div id="view-leaderboard-detail" class="screen" style="z-index: 200; background: var(--bg-color);">
        <div class="header">
            <div class="back-btn" onclick="closeLeaderboardDetail()" style="font-size: 17px;">Назад</div>
        </div>
        <div class="lb-title-lg" id="lbGameTitle" style="font-size: 32px; font-weight: 800; margin-bottom: 20px;">Title</div>
        <div class="lb-selector" id="lbSelector" onclick="toggleDropdown()" style="background: var(--glass-bg); padding: 10px 15px; border-radius: 12px; font-weight: 600; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border: 1px solid var(--glass-border); margin-bottom: 15px;">
            <span id="lbCurrentCat">Category</span>
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>
        </div>
        <div class="dropdown-menu" id="dropdownMenu" style="position: absolute; top: 160px; left: 20px; right: 20px; background: var(--glass-bg); backdrop-filter: blur(40px); border-radius: 16px; padding: 10px; z-index: 23000; border: 1px solid var(--glass-border); display:none;"></div>
        <div class="lb-list" id="lbList"></div>
    </div>

    <div id="tower-screen" class="game-overlay">
        <div class="game-top-bar" style="background: transparent; position:absolute; top:0; left:0; width:100%; z-index:10; padding-top: calc(50px + var(--safe-top));">
            <div class="back-btn" onclick="closeGame('tower')" style="color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5);">Выйти</div>
            <div style="font-weight:800; color:white; font-size:32px; text-shadow: 0 1px 5px rgba(0,0,0,0.5);" id="towerScore">0</div>
        </div>
        <canvas id="towerCanvas" style="display:block; width:100%; height:100%;"></canvas>
        <div id="towerStartMsg" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); text-align:center; color:white; pointer-events:none; transition:opacity 0.3s;">
            <div style="font-size:18px; font-weight:600; text-shadow:0 2px 10px rgba(0,0,0,0.5);">Нажми, чтобы поставить блок</div>
        </div>
    </div>

    <div id="saper-screen" class="game-overlay"> 
        <div class="game-top-bar"> 
            <div class="back-btn" onclick="closeGame('saper')">Меню</div> 
            <div style="display:flex; gap:15px; font-weight:600;"> <span id="saperFlags">0</span> <span id="saperTimer">000.00</span> </div> 
        </div> 
        <div style="flex:1; display:flex; justify-content:center; align-items:center;"><div class="grid" id="saperGrid"></div></div> 
        <div style="position:fixed; bottom:120px; left:50%; transform:translateX(-50%); width:200px;">
            <div class="segment-control"><div class="segment-glider" id="saperGlider"></div><div class="segment-item active" onclick="setSaperMode('dig', this, 0)">Копать</div><div class="segment-item" onclick="setSaperMode('flag', this, 1)">Флаг</div></div>
        </div> 
    </div>
    
    <div id="checkers-screen" class="game-overlay"> <div class="game-top-bar"> <div class="back-btn" onclick="closeGame('checkers')">Меню</div> <div id="checkersStatus">Ход Белых</div> </div> <div style="flex:1; display:flex; justify-content:center; align-items:center;"><div id="checkersBoard" class="checkers-board"></div></div> </div>
    
    <div id="bb-screen" class="game-overlay"> <div class="game-top-bar"> <div class="back-btn" onclick="closeGame('bb')">Меню</div> <div>Best: <span id="bbBestScore">0</span></div> </div> <div class="bb-game-container" style="display:flex; flex-direction:column; align-items:center;"> <div id="bbScore" style="font-size:40px; font-weight:800; color:var(--accent); margin-bottom:20px;">0</div> <div id="bbGrid" class="bb-grid"></div> <div class="bb-footer" style="display:flex; justify-content:space-around; width:100%; margin-top:20px;"> <div id="shape0"></div> <div id="shape1"></div> <div id="shape2"></div> </div> </div> </div>
    
    <div id="sudoku-screen" class="game-overlay"> <div class="game-top-bar"> <div class="back-btn" onclick="closeGame('sudoku')">Меню</div> <div id="sudokuLives" style="color:var(--danger);">0/3</div> </div> <div style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center;"> <div id="sudokuBoard" class="sudo-board"></div> <div class="numpad" style="display:flex; gap:5px; margin-top:20px;"> <div class="num-btn" id="nb1" onclick="activateDigit(1,this)" style="padding:10px; background:white; border-radius:5px;">1</div><div class="num-btn" id="nb2" onclick="activateDigit(2,this)" style="padding:10px; background:white; border-radius:5px;">2</div><div class="num-btn" id="nb3" onclick="activateDigit(3,this)" style="padding:10px; background:white; border-radius:5px;">3</div><div class="num-btn" id="nb4" onclick="activateDigit(4,this)" style="padding:10px; background:white; border-radius:5px;">4</div><div class="num-btn" id="nb5" onclick="activateDigit(5,this)" style="padding:10px; background:white; border-radius:5px;">5</div><div class="num-btn" id="nb6" onclick="activateDigit(6,this)" style="padding:10px; background:white; border-radius:5px;">6</div><div class="num-btn" id="nb7" onclick="activateDigit(7,this)" style="padding:10px; background:white; border-radius:5px;">7</div><div class="num-btn" id="nb8" onclick="activateDigit(8,this)" style="padding:10px; background:white; border-radius:5px;">8</div><div class="num-btn" id="nb9" onclick="activateDigit(9,this)" style="padding:10px; background:white; border-radius:5px;">9</div> </div> </div> </div>

    <div class="modal-overlay" id="modalTower">
        <div class="modal">
            <h2>Башня</h2>
            <p style="color:#8e8e93;">Строй выше, бей рекорды!</p>
            <div style="margin: 15px 0; font-size:14px;">Рекорд: <span id="towerBestScore" style="font-weight:bold; color:var(--accent);">0</span></div>
            <button class="btn-main" onclick="startTowerGame()">Начать</button>
            <button style="margin-top:10px; background:none; border:none; color:#8e8e93;" onclick="document.getElementById('modalTower').classList.remove('visible')">Отмена</button>
        </div>
    </div>

    <div class="modal-overlay" id="modalSaper"><div class="modal"><h2>Сапёр</h2><div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;"><div class="diff-btn" onclick="setSaperDiff(6,6,5,this)">6x6</div><div class="diff-btn selected" onclick="setSaperDiff(8,8,10,this)">8x8</div><div class="diff-btn" onclick="setSaperDiff(10,10,15,this)">10x10</div><div class="diff-btn" onclick="setSaperDiff(15,15,30,this)">15x15</div></div><button class="btn-main" onclick="launchSaper()">Начать</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93;" onclick="document.getElementById('modalSaper').classList.remove('visible')">Отмена</button></div></div>
    
    <div class="modal-overlay" id="modalCheckers"><div class="modal"><h2>Шашки</h2>
        <div class="segment-control"><div class="segment-glider" id="checkersMainGlider"></div><div class="segment-item active" onclick="setCheckersMainMode('offline', this, 0)">Offline</div><div class="segment-item" onclick="setCheckersMainMode('online', this, 1)">Online</div></div>
        <div id="ch-offline-panel" class="panel-visible"><p style="color:#8e8e93;">Режим</p><div class="segment-control"><div class="segment-glider" id="checkersGlider"></div><div class="segment-item active" onclick="setCheckersMode(false, this, 0)">2 Игрока</div><div class="segment-item" onclick="setCheckersMode(true, this, 1)">Робот</div></div><button class="btn-main" onclick="launchCheckers()">Играть</button></div>
        <div id="ch-online-panel" class="panel-hidden"><button class="btn-main" onclick="joinGame()">Поиск (Скоро)</button><div style="display:flex; gap:5px; margin-top:10px;"><input type="text" id="joinCodeInput" class="input-glass" placeholder="Код"><button class="btn-main" style="width:auto;" onclick="joinGameByCode()">OK</button></div><button class="btn-main" style="background:var(--toggle-bg); color:black; margin-top:10px;" onclick="createGame()">Создать</button></div>
        <button style="margin-top:10px; background:none; border:none; color:#8e8e93;" onclick="document.getElementById('modalCheckers').classList.remove('visible')">Отмена</button>
    </div></div>
    <div class="modal-overlay" id="modalWaitOpponent"><div class="modal"><h2>Код: <span id="displayRoomCode" style="letter-spacing:2px; color:var(--accent);"></span></h2><p>Ожидание...</p><button style="color:var(--danger); background:none; border:none;" onclick="cancelOnlineWait()">Отмена</button></div></div>
    
    <div class="modal-overlay" id="modalBBResume"><div class="modal"><h2>Block Blast</h2><button class="btn-main" onclick="resumeBB()">Продолжить</button><button class="btn-main" style="background:var(--danger); margin-top:10px;" onclick="newGameBB()">Новая</button></div></div>
    <div class="modal-overlay" id="modalResult"><div class="modal" id="modalResultContent"><h2 id="resTitle"></h2><p id="resText"></p><button class="btn-main" id="resBtn" onclick="closeResult()">OK</button></div></div>
    <div class="modal-overlay" id="modalBBGameOver"><div class="modal" id="bbGameOverContent"></div></div>
    <div class="modal-overlay" id="modalLoading"><div class="loader"></div></div>
    <div class="modal-overlay" id="modalSudoku"><div class="modal"><h2>Судоку</h2><div class="segment-control"><div class="segment-glider" id="sudokuGlider"></div><div class="segment-item" onclick="selectSudokuDiff(30,this,0)">Easy</div><div class="segment-item active" onclick="selectSudokuDiff(40,this,1)">Med</div><div class="segment-item" onclick="selectSudokuDiff(50,this,2)">Hard</div></div><button class="btn-main" onclick="startSudoku()">Играть</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93;" onclick="document.getElementById('modalSudoku').classList.remove('visible')">Отмена</button></div></div>
    <div class="modal-overlay" id="modalSudokuResume"><div class="modal"><h2>Судоку</h2><button class="btn-main" onclick="resumeSudoku()">Продолжить</button><button class="btn-main" style="background:var(--danger); margin-top:10px;" onclick="document.getElementById('modalSudokuResume').classList.remove('visible'); document.getElementById('modalSudoku').classList.add('visible');">Новая</button></div></div>
    
    <script>
        const tg = window.Telegram.WebApp; 
        tg.expand();
        if (tg.isVerticalSwipesEnabled !== undefined) tg.isVerticalSwipesEnabled = false;
        tg.enableClosingConfirmation();

        let isDark = tg.colorScheme === 'dark';
        let isLiteMode = localStorage.getItem('lite_mode') === 'true'; 
        
        const API_BASE_URL = 'https://glass-api-kh3s.onrender.com';
        const socket = io(API_BASE_URL);
        
        let onlineRoomCode = null;
        let onlineMyColor = null; 
        let isOnlineGame = false;
        
        const ICON_MINE = `<svg class="saper-mine" viewBox="0 0 24 24"><path d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2zm0 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm0-13a5 5 0 1 1 0 10 5 5 0 0 1 0-10z"/></svg>`;
        const ICON_FLAG = `<svg class="saper-flag" viewBox="0 0 24 24" style="fill:#ff3b30; stroke:none;"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"/></svg>`;
        const ICON_CROWN = `<svg class="crown-icon" viewBox="0 0 24 24"><path d="M5 16L3 5l5.5 5L12 4l3.5 6L21 5l-2 11H5zm14 3c0 .6-.4 1-1 1H6c-.6 0-1-.4-1-1v-1h14v1z"/></svg>`;
        const COLOR_MAP = { 'bb-c-1':'#ff3b30', 'bb-c-2':'#ff9500', 'bb-c-3':'#ffcc00', 'bb-c-4':'#34c759', 'bb-c-5':'#007aff', 'bb-c-6':'#5856d6', 'bb-c-7':'#af52de' };

        function initApp() {
            applyTheme();
            applyLiteMode();
            loadProfile();
            setTimeout(syncLocalStatsToServer, 2000);
            
            // --- SOCKET LISTENERS ---
            socket.on('game_created', (data) => {
                document.getElementById('modalLoading').classList.remove('visible');
                onlineRoomCode = data.roomCode;
                onlineMyColor = data.color;
                document.getElementById('displayRoomCode').innerText = onlineRoomCode;
                document.getElementById('modalWaitOpponent').classList.add('visible');
            });
            
            socket.on('start_game', (data) => {
                isOnlineGame = true; // IMPORTANT
                document.getElementById('modalWaitOpponent').classList.remove('visible');
                document.getElementById('modalCheckers').classList.remove('visible');
                if (data.color) onlineMyColor = data.color;
                document.getElementById('checkers-screen').classList.add('visible');
                initCheckers(); 
                const boardEl = document.getElementById('checkersBoard');
                boardEl.classList.remove('rotated'); 
                if (onlineMyColor === 'black') boardEl.classList.add('rotated');
                tg.HapticFeedback.notificationOccurred('success');
                showResult(`Игра началась!`, `Ваш цвет: ${onlineMyColor === 'white' ? 'Белые' : 'Чёрные'}\nСоперник: ${data.opponent.name}`, "Погнали", () => { document.getElementById('modalResult').classList.remove('visible'); });
            });
            
            socket.on('opponent_move', (move) => { executeMove(move, false); });
            socket.on('opponent_disconnected', () => { showResult("Победа!", "Соперник отключился", "В меню", () => { closeResult(); closeGame('checkers'); }); });
            
            socket.on('error_message', (msg) => { alert(msg); document.getElementById('modalLoading').classList.remove('visible'); });
        }

        function applyTheme() { document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light'); if(tg.headerColor) tg.headerColor = isDark ? '#000000' : '#f2f2f7'; if(tg.backgroundColor) tg.backgroundColor = isDark ? '#000000' : '#f2f2f7'; }
        function toggleTheme() { isDark = !isDark; applyTheme(); tg.HapticFeedback.selectionChanged(); }
        function applyLiteMode() { const el = document.getElementById('liteToggle'); if(isLiteMode) el.classList.add('active'); else el.classList.remove('active'); }
        function toggleLiteMode() { isLiteMode = !isLiteMode; localStorage.setItem('lite_mode', isLiteMode); applyLiteMode(); tg.HapticFeedback.selectionChanged(); }
        function switchTab(t, el) { document.querySelectorAll('.screen').forEach(s => s.classList.remove('active')); document.querySelectorAll('.tab-item').forEach(b => b.classList.remove('active')); if(t==='games') document.getElementById('view-games').classList.add('active'); else if(t==='leaderboard') document.getElementById('view-leaderboard').classList.add('active'); else { document.getElementById('view-profile').classList.add('active'); loadProfile(); } if(el) el.classList.add('active'); tg.HapticFeedback.selectionChanged(); }
        
        function openGameModal(game) { 
            if(game==='saper') document.getElementById('modalSaper').classList.add('visible'); 
            if(game==='checkers') document.getElementById('modalCheckers').classList.add('visible');
            if(game==='tower') {
                document.getElementById('towerBestScore').innerText = localStorage.getItem('tower_best') || 0;
                document.getElementById('modalTower').classList.add('visible');
            }
            tg.HapticFeedback.impactOccurred('light'); 
        }
        function closeGame(game) { 
            document.getElementById(game+'-screen').classList.remove('visible'); 
            if(game==='saper') clearInterval(sTimerInt); 
            if(game==='bb') saveBBState(); 
            if(game==='sudoku') saveSudokuState();
            if(game==='tower') tState = 'start';
        }
        function closeResult() { document.getElementById('modalResult').classList.remove('visible'); document.getElementById('modalBBGameOver').classList.remove('visible'); document.getElementById('modalResultContent').classList.remove('rotate-180'); document.querySelectorAll('.game-overlay').forEach(el => el.classList.remove('visible')); }
        
        function loadProfile() { 
            const user = tg.initDataUnsafe.user || { first_name: "Player", username: "user" }; 
            document.getElementById('user-name').innerText = user.first_name; 
            document.getElementById('user-id').innerText = user.username ? '@'+user.username : ''; 
            const ava = document.getElementById('user-avatar'); 
            if(user.photo_url) ava.src = user.photo_url; 
            else ava.src = "https://ui-avatars.com/api/?name="+user.first_name+"&background=007aff&color=fff"; 
            
            document.getElementById('stat-saper-games').innerText = localStorage.getItem('saper_total') || 0; 
            document.getElementById('stat-saper-best').innerText = localStorage.getItem('saper_best_8') || '--'; 
            document.getElementById('stat-checkers-games').innerText = localStorage.getItem('checkers_total') || 0; 
            document.getElementById('stat-checkers-wins').innerText = localStorage.getItem('checkers_wins_pve') || 0; 
            document.getElementById('stat-bb-games').innerText = localStorage.getItem('bb_total_games') || 0; 
            document.getElementById('stat-bb-best').innerText = localStorage.getItem('bb_best_score') || 0; 
            document.getElementById('stat-sudoku-wins').innerText = localStorage.getItem('sudoku_wins') || 0;
            document.getElementById('stat-tower-best').innerText = localStorage.getItem('tower_best') || 0;
            if(document.getElementById('bbBestScore')) document.getElementById('bbBestScore').innerText = localStorage.getItem('bb_best_score') || 0; 
        }
        
        function saveStatToCloud(key, value) { localStorage.setItem(key, value); loadProfile(); }
        async function sendStatToBackend(game_type, score) {
            const user = tg.initDataUnsafe.user; if (!user) return;
            const url = `${API_BASE_URL}/save-stat`;
            const payload = { user_id: user.id.toString(), username: (user.first_name + ' ' + (user.last_name||'')).trim(), photo_url: user.photo_url || "", game_type: game_type, score: score };
            try { await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); } catch (error) { console.error(error); }
        }
        function syncLocalStatsToServer() {
            const bbBest = parseInt(localStorage.getItem('bb_best_score') || 0); if(bbBest > 0) sendStatToBackend('bb_best_score', bbBest);
            const towBest = parseInt(localStorage.getItem('tower_best') || 0); if(towBest > 0) sendStatToBackend('tower_best', towBest);
        }

        /* --- TOWER STACK GAME LOGIC --- */
        let tCanvas, tCtx, tReqAnim;
        let tScore = 0;
        let tState = 'start'; 
        let tBlocks = [];
        let tDebris = [];
        let tCurrentBlock = null;
        let tCameraY = 0;
        let tBaseWidth = 150; 
        let tHeight = 25; 
        let tSpeed = 3; 
        let tHue = 0; 

        function startTowerGame() {
            document.getElementById('modalTower').classList.remove('visible');
            document.getElementById('tower-screen').classList.add('visible');
            tCanvas = document.getElementById('towerCanvas');
            tCtx = tCanvas.getContext('2d');
            tCanvas.width = window.innerWidth;
            tCanvas.height = window.innerHeight;
            resetTower();
            tState = 'playing';
            document.getElementById('towerStartMsg').style.opacity = '0';
            tCanvas.onpointerdown = (e) => { e.preventDefault(); placeBlock(); };
            if(tReqAnim) cancelAnimationFrame(tReqAnim);
            loopTower();
        }

        function resetTower() {
            tScore = 0; tBlocks = []; tDebris = []; tCameraY = 0; tHue = Math.random() * 360; tSpeed = 3;
            document.getElementById('towerScore').innerText = tScore;
            const centerX = tCanvas.width / 2; const startY = tCanvas.height - 100;
            tBlocks.push({ x: centerX - tBaseWidth/2, y: startY, w: tBaseWidth, h: tHeight, color: `hsl(${tHue}, 70%, 50%)` });
            spawnNextBlock();
        }

        function spawnNextBlock() {
            const prev = tBlocks[tBlocks.length - 1];
            tHue += 5; 
            tCurrentBlock = {
                x: -200, y: prev.y - tHeight, w: prev.w, h: tHeight, color: `hsl(${tHue}, 70%, 50%)`,
                dir: Math.random() > 0.5 ? 1 : -1, speed: tSpeed + (tScore * 0.05)
            };
            if(tCurrentBlock.dir === -1) { tCurrentBlock.x = tCanvas.width + 100; } else { tCurrentBlock.x = -150; }
        }

        function placeBlock() {
            if(tState !== 'playing') { if(tState === 'gameover') startTowerGame(); return; }
            const prev = tBlocks[tBlocks.length - 1]; const curr = tCurrentBlock;
            let overlap = 0; let diff = curr.x - prev.x;
            
            if (Math.abs(diff) >= prev.w) { gameOverTower(); return; }
            if (Math.abs(diff) < 3) { curr.x = prev.x; diff = 0; tg.HapticFeedback.notificationOccurred('success'); createPerfectEffect(curr.x + curr.w/2, curr.y + curr.h/2); } 
            else { tg.HapticFeedback.impactOccurred('light'); }

            if (diff > 0) {
                overlap = prev.w - diff; curr.w = overlap;
                addDebris(curr.x + curr.w, curr.y, diff, curr.h, curr.color);
            } else {
                overlap = prev.w + diff; curr.w = overlap; curr.x = prev.x;
                addDebris(curr.x - Math.abs(diff), curr.y, Math.abs(diff), curr.h, curr.color);
            }
            tBlocks.push(curr); tScore++; document.getElementById('towerScore').innerText = tScore; spawnNextBlock();
        }

        function addDebris(x, y, w, h, c) { tDebris.push({ x: x, y: y, w: w, h: h, color: c, vy: 0, opacity: 1 }); }
        function createPerfectEffect(x, y) { tDebris.push({ type: 'ring', x: x, y: y, r: 10, opacity: 1, color: 'white' }); }

        function gameOverTower() {
            tState = 'gameover'; tg.HapticFeedback.notificationOccurred('error');
            addDebris(tCurrentBlock.x, tCurrentBlock.y, tCurrentBlock.w, tCurrentBlock.h, tCurrentBlock.color); tCurrentBlock = null;
            const best = parseInt(localStorage.getItem('tower_best') || 0);
            if(tScore > best) {
                localStorage.setItem('tower_best', tScore); sendStatToBackend('tower_best', tScore);
                showResult("Новый рекорд!", `Высота: ${tScore}`, "Ещё раз", () => startTowerGame());
                confetti({particleCount:100, zIndex:22000});
            } else { showResult("Башня упала", `Высота: ${tScore}`, "Ещё раз", () => startTowerGame()); }
        }

        function loopTower() {
            if(!document.getElementById('tower-screen').classList.contains('visible')) return;
            tReqAnim = requestAnimationFrame(loopTower);
            const grad = tCtx.createLinearGradient(0, 0, 0, tCanvas.height); grad.addColorStop(0, '#1a1a2e'); grad.addColorStop(1, '#16213e');
            tCtx.fillStyle = grad; tCtx.fillRect(0, 0, tCanvas.width, tCanvas.height);
            
            if(tState === 'playing' && tCurrentBlock) {
                tCurrentBlock.x += tCurrentBlock.speed * tCurrentBlock.dir;
                if(tCurrentBlock.x > tCanvas.width && tCurrentBlock.dir === 1) tCurrentBlock.dir = -1;
                if(tCurrentBlock.x + tCurrentBlock.w < 0 && tCurrentBlock.dir === -1) tCurrentBlock.dir = 1;
            }

            let targetCamY = 0;
            if(tBlocks.length > 5) { const topBlock = tBlocks[tBlocks.length-1]; targetCamY = (tCanvas.height / 2) - topBlock.y; }
            tCameraY += (targetCamY - tCameraY) * 0.1;

            tCtx.save(); tCtx.translate(0, tCameraY);
            tBlocks.forEach(b => { tCtx.fillStyle = b.color; tCtx.fillRect(b.x, b.y, b.w, b.h); tCtx.fillStyle = "rgba(255,255,255,0.2)"; tCtx.fillRect(b.x, b.y, b.w, 5); });
            if(tCurrentBlock) { tCtx.fillStyle = tCurrentBlock.color; tCtx.fillRect(tCurrentBlock.x, tCurrentBlock.y, tCurrentBlock.w, tCurrentBlock.h); tCtx.fillStyle = "rgba(255,255,255,0.2)"; tCtx.fillRect(tCurrentBlock.x, tCurrentBlock.y, tCurrentBlock.w, 5); }

            for(let i = tDebris.length - 1; i >= 0; i--) {
                const p = tDebris[i];
                if(p.type === 'ring') {
                    p.r += 2; p.opacity -= 0.05; tCtx.strokeStyle = `rgba(255,255,255,${p.opacity})`; tCtx.lineWidth = 2; tCtx.beginPath(); tCtx.arc(p.x, p.y, p.r, 0, Math.PI*2); tCtx.stroke();
                } else {
                    p.y += p.vy; p.vy += 0.5; p.opacity -= 0.01;
                    tCtx.globalAlpha = p.opacity; tCtx.fillStyle = p.color; tCtx.fillRect(p.x, p.y, p.w, p.h); tCtx.globalAlpha = 1;
                }
                if(p.opacity <= 0 || p.y > tCanvas.height - tCameraY + 100) { tDebris.splice(i, 1); }
            }
            tCtx.restore();
        }

        /* --- LEADERBOARD LOGIC --- */
        let currentLbGame = 'saper';
        let currentLbCat = { id: 'saper_wins', name: 'Количество побед' };
        
        const SAPER_CATS = [{ id: 'saper_wins', name: 'Количество побед' },{ id: 'saper_best_6', name: 'Лучшее время 6x6', isTime: true },{ id: 'saper_best_8', name: 'Лучшее время 8x8', isTime: true }];
        const CHECKERS_CATS = [{ id: 'checkers_total', name: 'Всего игр' },{ id: 'checkers_wins_pve', name: 'Побед над роботом' }];
        const BB_CATS = [{ id: 'bb_best_score', name: 'Рекорд очков' },{ id: 'bb_total_games', name: 'Всего игр' }];
        const SUDOKU_CATS = [{ id: 'sudoku_wins', name: 'Количество побед' }];
        const TOWER_CATS = [{ id: 'tower_best', name: 'Максимальная высота' }];

        function openLeaderboardDetail(game) {
            currentLbGame = game;
            if(game === 'saper') { document.getElementById('lbGameTitle').innerText = 'Топы Сапёра'; loadLeaderboardData(SAPER_CATS[0]); } 
            else if (game === 'checkers') { document.getElementById('lbGameTitle').innerText = 'Топы Шашек'; loadLeaderboardData(CHECKERS_CATS[0]); } 
            else if (game === 'bb') { document.getElementById('lbGameTitle').innerText = 'Топы Block Blast'; loadLeaderboardData(BB_CATS[0]); } 
            else if (game === 'sudoku') { document.getElementById('lbGameTitle').innerText = 'Топы Судоку'; loadLeaderboardData(SUDOKU_CATS[0]); }
            else if (game === 'tower') { document.getElementById('lbGameTitle').innerText = 'Топы Башни'; loadLeaderboardData(TOWER_CATS[0]); }
            document.getElementById('view-leaderboard-detail').classList.add('active');
        }
        function closeLeaderboardDetail() { document.getElementById('view-leaderboard-detail').classList.remove('active'); document.getElementById('dropdownMenu').style.display = 'none'; }
        
        function toggleDropdown() {
            const menu = document.getElementById('dropdownMenu');
            if(menu.style.display === 'block') { menu.style.display = 'none'; return; }
            menu.innerHTML = ''; let cats = [];
            if(currentLbGame === 'saper') cats = SAPER_CATS; else if(currentLbGame === 'checkers') cats = CHECKERS_CATS; else if(currentLbGame === 'bb') cats = BB_CATS; else if(currentLbGame === 'sudoku') cats = SUDOKU_CATS; else if(currentLbGame === 'tower') cats = TOWER_CATS;
            cats.forEach(cat => { 
                const el = document.createElement('div'); 
                el.style.padding = "12px"; el.style.borderBottom="1px solid rgba(0,0,0,0.05)";
                el.innerText = cat.name; 
                el.onclick = () => { loadLeaderboardData(cat); menu.style.display='none'; }; 
                menu.appendChild(el); 
            });
            menu.style.display = 'block';
        }

        async function loadLeaderboardData(category) {
            currentLbCat = category; document.getElementById('lbCurrentCat').innerText = category.name; const listEl = document.getElementById('lbList'); listEl.innerHTML = '<div style="padding:20px; text-align:center; color:#8e8e93;">Загрузка...</div>';
            try {
                const url = `${API_BASE_URL}/leaderboard?game=${currentLbGame}&category=${category.id}`;
                const response = await fetch(url); const data = await response.json();
                listEl.innerHTML = '';
                data.slice(0, 50).forEach((u, index) => {
                    const item = document.createElement('div'); 
                    item.style.cssText = "display:flex; align-items:center; padding:12px; background:var(--glass-bg); margin-bottom:8px; border-radius:14px; border:1px solid var(--glass-border);";
                    let displayVal = u.score; if(category.isTime) displayVal = u.score + 'с';
                    item.innerHTML = `<div style="font-weight:bold; width:30px;">#${index+1}</div><div><b>${u.username}</b></div><div style="margin-left:auto; font-weight:bold;">${displayVal}</div>`;
                    listEl.appendChild(item);
                });
            } catch (error) { listEl.innerHTML = `<div style="padding:20px; text-align:center; color:var(--danger);">Ошибка сети.</div>`; }
        }

        /* --- RESTORED GAMES LOGIC (SAPER, CHECKERS, BB, SUDOKU) --- */
        
        /* SAPER */
        let sRows=8, sCols=8, sMines=10, sMode='dig', sGrid=[], sTimer=0, sTimerInt, sFlags=0, sFirst=true, sOver=false, sStartTime=0;
        function setSaperDiff(r,c,m,btn) { sRows=r; sCols=c; sMines=m; document.querySelectorAll('#modalSaper .diff-btn').forEach(b=>b.classList.remove('selected')); btn.classList.add('selected'); tg.HapticFeedback.selectionChanged(); }
        function launchSaper() { document.getElementById('modalSaper').classList.remove('visible'); document.getElementById('saper-screen').classList.add('visible'); setSaperMode('dig', document.querySelector('#saperGlider').nextElementSibling, 0); initSaper(); }
        function setSaperMode(m, btn, index) { sMode = m; const glider = document.getElementById('saperGlider'); if(glider) glider.style.transform = `translateX(${index * 100}%)`; const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active'); tg.HapticFeedback.selectionChanged(); }
        function initSaper() { sGrid=[]; sOver=false; sFirst=true; sFlags=sMines; sTimer=0; document.getElementById('saperFlags').innerText=sFlags; document.getElementById('saperTimer').innerText='000.00'; clearInterval(sTimerInt); const el=document.getElementById('saperGrid'); el.innerHTML=''; el.style.gridTemplateColumns=`repeat(${sCols}, 38px)`; const w=window.innerWidth-20, rw=sCols*43; el.style.transform=rw>w?`scale(${w/rw})`:`scale(1)`; for(let r=0;r<sRows;r++){const row=[];for(let c=0;c<sCols;c++){const cell=document.createElement('div');cell.className='cell';cell.onclick=()=>onSaperClick(r,c);cell.oncontextmenu=(e)=>{e.preventDefault();onSaperFlag(r,c);};let pt;cell.addEventListener('touchstart',()=>{if(!sOver)pt=setTimeout(()=>{onSaperFlag(r,c);tg.HapticFeedback.impactOccurred('medium');},500);});cell.addEventListener('touchend',()=>clearTimeout(pt));el.appendChild(cell);row.push({isMine:false,revealed:false,flagged:false,neighbor:0,el:cell});}sGrid.push(row);} }
        function onSaperClick(r,c){const cell=sGrid[r][c];if(sOver||cell.revealed)return;if(sMode==='flag'){onSaperFlag(r,c);return;}if(cell.flagged)return;if(sFirst){sFirst=false;placeMinesSafe(r,c); sStartTime = Date.now(); sTimerInt=setInterval(()=>{ let now = Date.now(); let diff = (now - sStartTime)/1000; sTimer = diff; document.getElementById('saperTimer').innerText= diff.toFixed(2);},3);}if(cell.isMine)loseSaper(cell);else{revealSaper(r,c);checkSaperWin();tg.HapticFeedback.selectionChanged();}}
        function onSaperFlag(r,c){const cell=sGrid[r][c];if(sOver||cell.revealed)return;if(!cell.flagged&&sFlags>0){cell.flagged=true;cell.el.innerHTML=ICON_FLAG;sFlags--;}else if(cell.flagged){cell.flagged=false;cell.el.innerHTML='';sFlags++;}document.getElementById('saperFlags').innerText=sFlags;}
        function placeMinesSafe(exR,exC){let placed=0;while(placed<sMines){let rr=Math.floor(Math.random()*sRows),cc=Math.floor(Math.random()*sCols);if(Math.abs(rr-exR)<=1&&Math.abs(cc-exC)<=1)continue;if(!sGrid[rr][cc].isMine){sGrid[rr][cc].isMine=true;placed++;}}for(let r=0;r<sRows;r++)for(let c=0;c<sCols;c++){if(sGrid[r][c].isMine)continue;let cnt=0;for(let i=-1;i<=1;i++)for(let j=-1;j<=1;j++)if(r+i>=0&&r+i<sRows&&c+j>=0&&c+j<sCols&&sGrid[r+i][c+j].isMine)cnt++;sGrid[r][c].neighbor=cnt;}}
        function revealSaper(r,c){const cell=sGrid[r][c];if(cell.revealed||cell.flagged)return;cell.revealed=true;cell.el.classList.add('revealed');if(cell.neighbor>0){cell.el.innerText=cell.neighbor;cell.el.classList.add('c-'+cell.neighbor);}else{for(let i=-1;i<=1;i++)for(let j=-1;j<=1;j++)if(r+i>=0&&r+i<sRows&&c+j>=0&&c+j<sCols)revealSaper(r+i,c+j);}}
        function loseSaper(cell){sOver=true;clearInterval(sTimerInt);tg.HapticFeedback.notificationOccurred('error');cell.el.style.background='var(--danger)';sGrid.forEach(r=>r.forEach(c=>{if(c.isMine)c.el.innerHTML=ICON_MINE;}));let t=parseInt(localStorage.getItem('saper_total')||0)+1;saveStatToCloud('saper_total',t);showResult('Бум!','Не повезло', 'Закрыть');}
        function checkSaperWin(){ let rev=0;sGrid.forEach(r=>r.forEach(c=>{if(c.revealed)rev++})); if(rev===sRows*sCols-sMines){ sOver=true;clearInterval(sTimerInt);tg.HapticFeedback.notificationOccurred('success'); confetti({particleCount:150,spread:70,origin:{y:0.6},zIndex:2147483647}); let t=parseInt(localStorage.getItem('saper_total')||0)+1; saveStatToCloud('saper_total',t); let w=parseInt(localStorage.getItem('saper_wins')||0)+1; saveStatToCloud('saper_wins', w); const key = `saper_best_${sRows}`; let b=parseFloat(localStorage.getItem(key)||9999); if(sTimer<b) saveStatToCloud(key, sTimer); sendStatToBackend(`saper_best_${sRows}`, sTimer); sendStatToBackend('saper_wins', w); showResult('Победа!',`Время: ${sTimer.toFixed(2)} с`, 'Круто'); } }

        /* CHECKERS */
        const BOARD_SIZE=8; let board=[], turn='white', selectedPiece=null, isPvE=false, forcedPiece=null;
        function setCheckersMainMode(mode, btn, index) { const glider = document.getElementById('checkersMainGlider'); glider.style.transform = `translateX(${index * 100}%)`; const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active'); const offline = document.getElementById('ch-offline-panel'); const online = document.getElementById('ch-online-panel'); if(mode === 'online') { offline.classList.replace('panel-visible', 'panel-hidden'); online.classList.replace('panel-hidden', 'panel-visible'); } else { online.classList.replace('panel-visible', 'panel-hidden'); offline.classList.replace('panel-hidden', 'panel-visible'); } tg.HapticFeedback.selectionChanged(); }
        function createGame() { document.getElementById('modalLoading').classList.add('visible'); const user = tg.initDataUnsafe.user || { first_name: "Player" }; const displayName = (user.first_name + ' ' + (user.last_name || '')).trim(); socket.emit('create_game', { username: displayName, photo_url: user.photo_url || '', gameType: 'checkers' }); }
        function joinGame() { tg.HapticFeedback.notificationOccurred('warning'); alert('Скоро: Поиск случайного соперника'); }
        function joinGameByCode() { const code = document.getElementById('joinCodeInput').value; if (code.length < 5) { tg.HapticFeedback.notificationOccurred('error'); return; } onlineRoomCode = code; const user = tg.initDataUnsafe.user || { first_name: "Player" }; const displayName = (user.first_name + ' ' + (user.last_name || '')).trim(); socket.emit('join_game', { roomCode: code, userData: { username: displayName, photo_url: user.photo_url || '' } }); }
        function cancelOnlineWait() { document.getElementById('modalWaitOpponent').classList.remove('visible'); onlineRoomCode = null; }
        function setCheckersMode(pve, btn, index){ isPvE = pve; isOnlineGame = false; const glider = document.getElementById('checkersGlider'); glider.style.transform = `translateX(${index * 100}%)`; const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active'); tg.HapticFeedback.selectionChanged(); }
        function launchCheckers(){document.getElementById('modalCheckers').classList.remove('visible');document.getElementById('checkers-screen').classList.add('visible');setTimeout(initCheckers,50);}
        function initCheckers(){turn='white';selectedPiece=null;forcedPiece=null;document.getElementById('checkersStatus').innerText="Ход Белых";const el=document.getElementById('checkersBoard');el.innerHTML='';board=[];for(let r=0;r<BOARD_SIZE;r++){const row=[];for(let c=0;c<BOARD_SIZE;c++){const cell=document.createElement('div');const isDark=(r+c)%2!==0;cell.className=`ch-cell ${isDark?'dark':'light'}`;cell.onclick=()=>onBoardClick(r,c);el.appendChild(cell);let p=null;if(isDark){if(r<3)p={color:'black',isKing:false};if(r>4)p={color:'white',isKing:false};}row.push({piece:p,el:cell});if(p){const d=document.createElement('div');d.className=`checker ${p.color}`;cell.appendChild(d);}}board.push(row);}}
        function onBoardClick(r,c){ if (isOnlineGame) { if (turn !== onlineMyColor) return; } else { if(isPvE && turn==='black') return; } const cell=board[r][c]; if(cell.piece&&cell.piece.color===turn){if(forcedPiece&&(forcedPiece.r!==r||forcedPiece.c!==c))return;if(selectedPiece){const p=board[selectedPiece.r][selectedPiece.c].el.querySelector('.checker');if(p)p.classList.remove('selected');board.forEach(row=>row.forEach(cl=>cl.el.classList.remove('highlight')));}selectedPiece={r,c};cell.el.querySelector('.checker').classList.add('selected');highlightMoves(r,c);tg.HapticFeedback.selectionChanged();return;}if(!cell.piece&&selectedPiece){const moves=getValidMoves(selectedPiece.r,selectedPiece.c,board);const move=moves.find(m=>m.toR===r&&m.toC===c);if(move)executeMove(move, true);} }
        function highlightMoves(r,c){const moves=getValidMoves(r,c,board);moves.forEach(m=>board[m.toR][m.toC].el.classList.add('highlight'));}
        function getValidMoves(r,c,b){const p=b[r][c].piece;if(!p)return[];const moves=[],dirs=[[-1,-1],[-1,1],[1,-1],[1,1]];dirs.forEach(d=>{let dist=1;while(true){let nr=r+d[0]*dist,nc=c+d[1]*dist;if(nr<0||nr>=8||nc<0||nc>=8)break;if(!b[nr][nc].piece){if(!p.isKing){const fwd=(p.color==='white'&&d[0]===-1)||(p.color==='black'&&d[0]===1);if(fwd&&dist===1&&!forcedPiece)moves.push({fromR:r,fromC:c,toR:nr,toC:nc,isCapture:false});break;}else{if(!forcedPiece)moves.push({fromR:r,fromC:c,toR:nr,toC:nc,isCapture:false});}}else{if(b[nr][nc].piece.color===p.color)break;let jr=nr+d[0],jc=nc+d[1];if(jr>=0&&jr<8&&jc>=0&&jc<8&&!b[jr][jc].piece){if(p.isKing){let fd=1;while(true){let fr=nr+d[0]*fd,fc=nc+d[1]*fd;if(fr<0||fr>=8||fc<0||fc>=8||b[fr][fc].piece)break;moves.push({fromR:r,fromC:c,toR:fr,toC:fc,isCapture:true,midR:nr,midC:nc});fd++;}}else{moves.push({fromR:r,fromC:c,toR:jr,toC:jc,isCapture:true,midR:nr,midC:nc});}}break;}dist++;if(!p.isKing)break;}});const caps=moves.filter(m=>m.isCapture);return caps.length>0?caps:moves;}
        function executeMove(m, isLocal = true){ const p=board[m.fromR][m.fromC].piece; if(isOnlineGame && isLocal) { socket.emit('move', { roomCode: onlineRoomCode, move: m }); } board[m.toR][m.toC].piece=p;board[m.fromR][m.fromC].piece=null;board[m.fromR][m.fromC].el.innerHTML='';const pd=document.createElement('div');pd.className=`checker ${p.color} ${p.isKing?'king':''}`;board[m.toR][m.toC].el.appendChild(pd);if(m.isCapture){board[m.midR][m.midC].piece=null;board[m.midR][m.midC].el.innerHTML='';tg.HapticFeedback.notificationOccurred('warning');let prom=false;if(!p.isKing&&((p.color==='white'&&m.toR===0)||(p.color==='black'&&m.toR===7))){p.isKing=true;pd.classList.add('king');prom=true;}if(!prom){const next=getValidMoves(m.toR,m.toC,board);if(next.some(nm=>nm.isCapture)){forcedPiece={r:m.toR,c:m.toC};selectedPiece={r:m.toR,c:m.toC};pd.classList.add('selected');highlightMoves(m.toR,m.toC);if(isPvE&&turn==='black')setTimeout(aiMove,500);return;}}}else{tg.HapticFeedback.selectionChanged();if(!p.isKing&&((p.color==='white'&&m.toR===0)||(p.color==='black'&&m.toR===7))){p.isKing=true;pd.classList.add('king');tg.HapticFeedback.notificationOccurred('success');}}board.forEach(row=>row.forEach(cl=>cl.el.classList.remove('highlight')));selectedPiece=null;forcedPiece=null; checkWin(); turn=turn==='white'?'black':'white'; document.getElementById('checkersStatus').innerText=turn==='white'?"Ход Белых":"Ход Чёрных"; if (!hasAnyMoves(turn)) { const winner = turn === 'white' ? 'black' : 'white'; endGame(winner); return; } if(!isOnlineGame && isPvE && turn==='black') setTimeout(aiMove, 600); }
        function aiMove(){ if(isOnlineGame) return; const pcs=[];for(let r=0;r<8;r++)for(let c=0;c<8;c++)if(board[r][c].piece&&board[r][c].piece.color==='black')pcs.push({r,c});if(forcedPiece){const ms=getValidMoves(forcedPiece.r,forcedPiece.c,board);if(ms.length>0)executeMove(ms[0]);return;}let all=[];pcs.forEach(p=>{const ms=getValidMoves(p.r,p.c,board);ms.forEach(m=>{let s=0;if(m.isCapture)s+=10;if(m.toR===7)s+=5;if(m.toR>p.r)s+=1;all.push({m,s:s+Math.random()});});});if(all.length>0){all.sort((a,b)=>b.s-a.s);executeMove(all[0].m);}else endGame('white'); }
        function hasAnyMoves(color) { for(let r=0; r<8; r++) { for(let c=0; c<8; c++) { const cell = board[r][c]; if (cell.piece && cell.piece.color === color) { const moves = getValidMoves(r, c, board); if (moves.length > 0) return true; } } } return false; }
        function checkWin(){let wc=0,bc=0;board.forEach(r=>r.forEach(c=>{if(c.piece)c.piece.color==='white'?wc++:bc++}));if(bc===0)endGame('white');else if(wc===0)endGame('black');}
        function endGame(w){ const tit=document.getElementById('resText'); tit.innerText = w==='white'?"Белые победили!":"Чёрные победили!"; document.getElementById('modalResult').classList.add('visible'); if(isOnlineGame) socket.emit('game_over', { roomCode: onlineRoomCode, winner: w }); }

        /* BLOCK BLAST */
        const BB_ROWS=8, BB_COLS=8; let bbGrid=[], bbScore=0, bbDisplayedScore=0, bbShapes=[], bbState=null, bbCombo=0, bbComboBuffer=0, bbIsAnimating=false; 
        const SHAPES = [[[1]],[[1,1]],[[1],[1]],[[1,1,1]],[[1],[1],[1]],[[1,1,1,1]],[[1],[1],[1],[1]],[[1,1,1,1,1]],[[1],[1],[1],[1],[1]],[[1,1],[1,1]],[[1,1,1],[1,1,1]],[[1,1],[1,1],[1,1]],[[1,1,1],[1,1,1],[1,1,1]],[[1,0],[1,0],[1,1]],[[1,1,1],[1,0,0]],[[1,1],[0,1],[0,1]],[[0,0,1],[1,1,1]],[[0,1],[0,1],[1,1]],[[1,0,0],[1,1,1]],[[1,1],[1,0],[1,0]],[[1,1,1],[0,0,1]],[[1,0],[1,1]],[[1,1],[1,0]],[[1,1],[0,1]],[[0,1],[1,1]],[[1,1,1],[0,1,0]],[[0,1,0],[1,1,1]],[[1,0],[1,1],[1,0]],[[0,1],[1,1],[0,1]]];
        const COLORS = ['bb-c-1','bb-c-2','bb-c-3','bb-c-4','bb-c-5','bb-c-6','bb-c-7'];
        const DRAG_LIFT_Y = 150; 
        function startBlockBlastCheck() { if(localStorage.getItem('bb_state')) document.getElementById('modalBBResume').classList.add('visible'); else newGameBB(); }
        function resumeBB() { document.getElementById('modalBBResume').classList.remove('visible'); document.getElementById('bb-screen').classList.add('visible'); restoreBBState(); }
        function newGameBB() { document.getElementById('modalBBResume').classList.remove('visible'); document.getElementById('bb-screen').classList.add('visible'); initBB(); }
        function initBB() { bbGrid = Array(BB_ROWS).fill().map(() => Array(BB_COLS).fill(0)); bbScore = 0; bbDisplayedScore = 0; bbCombo=0; bbComboBuffer=0; bbIsAnimating=false; updateBBScoreUI(); document.getElementById('bbBestScore').innerText = localStorage.getItem('bb_best_score') || 0; renderBBGrid(); spawnShapes(); saveBBState(); }
        function renderBBGrid() { const el = document.getElementById('bbGrid'); el.innerHTML = ''; for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { const cell = document.createElement('div'); cell.className = 'bb-cell'; cell.dataset.r = r; cell.dataset.c = c; if(bbGrid[r][c] !== 0) { cell.classList.add('filled', bbGrid[r][c]); } el.appendChild(cell); } } }
        function countFreeCells() { let free = 0; for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { if(bbGrid[r][c] === 0) free++; } } return free; }
        function spawnShapes() { bbShapes = []; const freeCells = countFreeCells(); let availableIndices = []; for(let i=0; i<SHAPES.length; i++) { const matrix = SHAPES[i]; const size = matrix.reduce((acc, row) => acc + row.reduce((a,b)=>a+b, 0), 0); if (freeCells < 25) { if (size <= 4) availableIndices.push(i); } else { availableIndices.push(i); } } for(let i=0; i<3; i++) { const rand = Math.floor(Math.random() * availableIndices.length); const shapeIdx = availableIndices[rand]; const color = COLORS[Math.floor(Math.random() * COLORS.length)]; bbShapes.push({ matrix: SHAPES[shapeIdx], color: color, id: i }); renderShapePreview(i, SHAPES[shapeIdx], color); } }
        function renderShapePreview(slotId, matrix, color) { const container = document.getElementById(`shape${slotId}`); container.innerHTML = ''; if(!matrix) return; const preview = document.createElement('div'); preview.className = 'bb-shape-preview'; preview.style.gridTemplateColumns = `repeat(${matrix[0].length}, 18px)`; matrix.forEach((row, ri) => { row.forEach((val, ci) => { const b = document.createElement('div'); if(val) { b.className = `bb-block ${color}`; b.dataset.ri = ri; b.dataset.ci = ci; } else { b.style.opacity = 0; } preview.appendChild(b); }); }); container.appendChild(preview); container.ontouchstart = (e) => startDrag(e, slotId, matrix, color); container.onmousedown = (e) => startDrag(e, slotId, matrix, color); }
        let draggedElement = null; let dragGhost = null; let dragData = null; let touchOffsetX = 0, touchOffsetY = 0;
        function hexToRgba(hex, alpha) { const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }
        function startDrag(e, slotId, matrix, color) { 
            if(bbIsAnimating) return; e.preventDefault(); const touch = e.touches ? e.touches[0] : e; const gridRect = document.getElementById('bbGrid').getBoundingClientRect(); const cellFullSize = gridRect.width / 8; dragData = { slotId, matrix, color }; dragGhost = document.createElement('div'); dragGhost.className = 'drag-ghost'; dragGhost.style.gridTemplateColumns = `repeat(${matrix[0].length}, ${cellFullSize}px)`; dragGhost.style.gridTemplateRows = `repeat(${matrix.length}, ${cellFullSize}px)`; dragGhost.style.gap = '4px'; dragGhost.style.display = 'grid'; const shapePixelW = matrix[0].length * cellFullSize; 
            matrix.forEach((row, ri) => { row.forEach((val, ci) => { const b = document.createElement('div'); if(val) { b.className = `bb-block ${color}`; b.dataset.ri = ri; b.dataset.ci = ci; } else { b.style.opacity = 0; } dragGhost.appendChild(b); }); }); 
            document.body.appendChild(dragGhost); touchOffsetX = (shapePixelW / 2); touchOffsetY = (shapePixelW / 2); moveGhost(touch.clientX, touch.clientY); const preview = document.querySelector(`#shape${slotId} .bb-shape-preview`); if(preview) preview.style.opacity = 0; document.addEventListener('touchmove', onTouchMove, {passive: false}); document.addEventListener('touchend', onTouchEnd); document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onTouchEnd); 
        }
        function onTouchMove(e) { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }
        function onMouseMove(e) { e.preventDefault(); handleMove(e.clientX, e.clientY); }
        function handleMove(x, y) { const ghostX = x - touchOffsetX; const ghostY = y - touchOffsetY - DRAG_LIFT_Y; if(dragGhost) { dragGhost.style.left = ghostX + 'px'; dragGhost.style.top = ghostY + 'px'; } const gridRect = document.getElementById('bbGrid').getBoundingClientRect(); const cellFullSize = gridRect.width / 8; const relX = ghostX - gridRect.left; const relY = ghostY - gridRect.top; const col = Math.round(relX / cellFullSize); const row = Math.round(relY / cellFullSize); checkPlacement(row, col); }
        function moveGhost(x, y) { const ghostX = x - touchOffsetX; const ghostY = y - touchOffsetY - DRAG_LIFT_Y; if(dragGhost) { dragGhost.style.left = ghostX + 'px'; dragGhost.style.top = ghostY + 'px'; } }
        function checkPlacement(r, c) { document.querySelectorAll('.bb-cell.bb-shadow').forEach(c => c.classList.remove('bb-shadow', 'bb-c-1','bb-c-2','bb-c-3','bb-c-4','bb-c-5','bb-c-6','bb-c-7')); document.querySelectorAll('.bb-cell.pre-clear').forEach(c => { c.classList.remove('pre-clear'); c.style.backgroundColor = ''; }); if(canPlace(dragData.matrix, r, c)) { drawShadow(dragData.matrix, r, c, dragData.color); dragData.validPos = { r: r, c: c }; let tempGrid = bbGrid.map(row => [...row]); let rowsToClear = [], colsToClear = []; for(let i=0; i<dragData.matrix.length; i++) { for(let j=0; j<dragData.matrix[0].length; j++) { if(dragData.matrix[i][j] === 1) tempGrid[r+i][c+j] = 1; } } for(let rr=0; rr<BB_ROWS; rr++) if(tempGrid[rr].every(val => val !== 0)) rowsToClear.push(rr); for(let cc=0; cc<BB_COLS; cc++) { let full = true; for(let rr=0; rr<BB_ROWS; rr++) if(tempGrid[rr][cc] === 0) full = false; if(full) colsToClear.push(cc); } rowsToClear.forEach(rr => { for(let cc=0; cc<BB_COLS; cc++) highlightPreClear(rr, cc, dragData.color); }); colsToClear.forEach(cc => { for(let rr=0; rr<BB_ROWS; rr++) highlightPreClear(rr, cc, dragData.color); }); } else { dragData.validPos = null; } }
        function highlightPreClear(r, c, colorClass) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); if(cell) { cell.classList.add('pre-clear'); const hex = COLOR_MAP[colorClass] || '#007aff'; cell.style.backgroundColor = hexToRgba(hex, 0.4); } }
        function canPlace(matrix, r, c) { for(let i=0; i<matrix.length; i++) { for(let j=0; j<matrix[0].length; j++) { if(matrix[i][j] === 1) { let nr = r + i; let nc = c + j; if(nr < 0 || nr >= BB_ROWS || nc < 0 || nc >= BB_COLS || bbGrid[nr][nc] !== 0) return false; } } } return true; }
        function drawShadow(matrix, r, c, color) { for(let i=0; i<matrix.length; i++) { for(let j=0; j<matrix[0].length; j++) { if(matrix[i][j] === 1) { const cell = document.querySelector(`.bb-cell[data-r="${r+i}"][data-c="${c+j}"]`); if(cell) cell.classList.add('bb-shadow', color); } } } }
        function onTouchEnd(e) { document.removeEventListener('touchmove', onTouchMove); document.removeEventListener('touchend', onTouchEnd); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onTouchEnd); if(dragGhost) dragGhost.remove(); document.querySelectorAll('.bb-cell.pre-clear').forEach(c => { c.classList.remove('pre-clear'); c.style.backgroundColor = ''; }); document.querySelectorAll('.bb-cell.bb-shadow').forEach(c => c.classList.remove('bb-shadow', 'bb-c-1','bb-c-2','bb-c-3','bb-c-4','bb-c-5','bb-c-6','bb-c-7')); const original = document.querySelector(`#shape${dragData.slotId} .bb-shape-preview`); if(original) original.style.opacity = 1; if(dragData.validPos) { placeShape(dragData.matrix, dragData.validPos.r, dragData.validPos.c, dragData.color); document.getElementById(`shape${dragData.slotId}`).innerHTML = ''; const container = document.getElementById(`shape${dragData.slotId}`); container.ontouchstart = null; container.onmousedown = null; bbShapes[dragData.slotId] = null; const linesCleared = checkLines(dragData.color); if(linesCleared === 0) { if (bbCombo > 0) { bbComboBuffer--; if(bbComboBuffer <= 0) { bbCombo = 0; updateBBScoreUI(); } } if(bbShapes.every(s => s === null)) spawnShapes(); checkGameOver(); saveBBState(); } else { if(bbShapes.every(s => s === null)) spawnShapes(); } } }
        function placeShape(matrix, r, c, color) { tg.HapticFeedback.impactOccurred('light'); let placedCount = 0; for(let i=0; i<matrix.length; i++) { for(let j=0; j<matrix[0].length; j++) { if(matrix[i][j] === 1) { bbGrid[r+i][c+j] = color; const cell = document.querySelector(`.bb-cell[data-r="${r+i}"][data-c="${c+j}"]`); cell.classList.add('no-transition'); cell.classList.add('filled', color); cell.style.backgroundColor = ''; setTimeout(() => cell.classList.remove('no-transition'), 50); placedCount++; } } } addScore(placedCount); }
        function checkLines(triggerColor) { let linesCleared = 0; const rowsToClear = []; const colsToClear = []; for(let r=0; r<BB_ROWS; r++) { if(bbGrid[r].every(val => val !== 0)) rowsToClear.push(r); } for(let c=0; c<BB_COLS; c++) { let full = true; for(let r=0; r<BB_ROWS; r++) if(bbGrid[r][c] === 0) full = false; if(full) colsToClear.push(c); } const totalCleared = rowsToClear.length + colsToClear.length; if(totalCleared > 0) { bbCombo++; bbComboBuffer = 3; updateBBScoreUI(); tg.HapticFeedback.notificationOccurred('success'); if(!isLiteMode) document.querySelector('.bb-game-container').classList.add('shake-screen'); rowsToClear.forEach(r => { if(!isLiteMode) fireNeonParticles(r, -1, triggerColor); for(let c=0; c<BB_COLS; c++) { bbGrid[r][c] = 0; animateClear(r, c, triggerColor); } }); colsToClear.forEach(c => { if(!isLiteMode) fireNeonParticles(-1, c, triggerColor); for(let r=0; r<BB_ROWS; r++) { bbGrid[r][c] = 0; animateClear(r, c, triggerColor); } }); setTimeout(() => { document.querySelector('.bb-game-container').classList.remove('shake-screen'); let points = totalCleared * 10; if (totalCleared >= 2) { points = points * totalCleared; showComboPopup(`X${totalCleared} MULTIPLIER!`); } else if(bbCombo > 1) { points += bbCombo * 10; showComboPopup(`COMBO x${bbCombo}!`); } addScore(points); saveBBState(); setTimeout(checkAllClear, 50); checkGameOver(); }, 350); return totalCleared; } return 0; }
        function fireNeonParticles(row, col, colorClass) { const hex = COLOR_MAP[colorClass] || '#ffffff'; const gridRect = document.getElementById('bbGrid').getBoundingClientRect(); const cellW = gridRect.width / 8; const cellH = gridRect.height / 8; let xOrigin, yOrigin; if (row !== -1) { xOrigin = (gridRect.left + gridRect.width / 2) / window.innerWidth; yOrigin = (gridRect.top + (row * cellH) + (cellH/2)) / window.innerHeight; } else { xOrigin = (gridRect.left + (col * cellW) + (cellW/2)) / window.innerWidth; yOrigin = (gridRect.top + gridRect.height / 2) / window.innerHeight; } confetti({ particleCount: 40, startVelocity: 35, spread: 360, origin: { x: xOrigin, y: yOrigin }, colors: [hex, '#ffffff'], shapes: ['square'], scalar: 0.5, drift: 0, ticks: 50, gravity: 0.5, zIndex: 11000, disableForReducedMotion: true }); }
        function showComboPopup(text) { const p = document.createElement('div'); p.className = 'combo-popup'; p.innerText = text; document.querySelector('.bb-game-container').appendChild(p); setTimeout(() => p.remove(), 1000); }
        function animateClear(r, c, color) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); if(cell) { cell.className = 'bb-cell'; cell.style.backgroundColor = ''; cell.style.boxShadow = ''; cell.classList.add('appear-gray'); setTimeout(() => { cell.classList.remove('appear-gray'); }, 400); } }
        function addScore(points) { bbScore += points; const target = bbScore; const step = Math.ceil((target - bbDisplayedScore) / 10); const int = setInterval(() => { bbDisplayedScore += step; if(bbDisplayedScore >= target) { bbDisplayedScore = target; clearInterval(int); } updateBBScoreUI(); }, 30); }
        function updateBBScoreUI() { const el = document.getElementById('bbScore'); el.innerText = bbDisplayedScore; if(bbCombo > 0) el.classList.add('active-combo'); else el.classList.remove('active-combo'); }
        function checkAllClear() { if(bbIsAnimating) return; const free = countFreeCells(); if(free === BB_ROWS * BB_COLS) { bbIsAnimating = true; tg.HapticFeedback.notificationOccurred('success'); const bonus = 500 * (bbCombo > 0 ? bbCombo : 1); let delay = 0; for(let r=BB_ROWS-1; r>=0; r--) { setTimeout(() => { for(let c=0; c<BB_COLS; c++) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); const randColor = COLORS[Math.floor(Math.random()*COLORS.length)]; cell.className = `bb-cell filled ${randColor}`; } tg.HapticFeedback.impactOccurred('light'); }, delay); delay += 50; } setTimeout(() => { for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); cell.className = 'bb-cell clearing'; } } setTimeout(() => { renderBBGrid(); }, 200); const container = document.querySelector('.bb-game-container'); const pop = document.createElement('div'); pop.className = 'all-clear-popup'; pop.innerHTML = `<div class="ac-text">UNBELIEVABLE</div><div class="ac-score">+${bonus}</div>`; container.appendChild(pop); confetti({ particleCount: 150, spread: 100, origin: { y: 0.5 }, zIndex: 11000 }); addScore(bonus); setTimeout(() => { pop.remove(); bbIsAnimating = false; saveBBState(); }, 2000); }, delay + 200); } }
        async function checkGameOver() { if(bbIsAnimating) return; const shapesLeft = bbShapes.filter(s => s !== null); if(shapesLeft.length === 0) return; const canMove = shapesLeft.some(s => { for(let r=0; r<BB_ROWS; r++) { for(let c=0; c<BB_COLS; c++) { if(canPlace(s.matrix, r, c)) return true; } } return false; }); if(!canMove) { tg.HapticFeedback.notificationOccurred('error'); await animateGameOverFill(); const currentBest = parseInt(localStorage.getItem('bb_best_score') || 0); const isRecord = bbScore > currentBest; if(isRecord) { saveStatToCloud('bb_best_score', bbScore); sendStatToBackend('bb_best_score', bbScore); } localStorage.removeItem('bb_state'); let t = parseInt(localStorage.getItem('bb_total_games')||0)+1; saveStatToCloud('bb_total_games', t); sendStatToBackend('bb_total_games', t); showBBGameOverModal(isRecord, bbScore, currentBest); } }
        function animateGameOverFill() { return new Promise(resolve => { const emptyCells = []; for(let r=BB_ROWS-1; r>=0; r--) { for(let c=0; c<BB_COLS; c++) { if(bbGrid[r][c] === 0) { const cell = document.querySelector(`.bb-cell[data-r="${r}"][data-c="${c}"]`); emptyCells.push(cell); } } } let i = 0; const int = setInterval(() => { if(i >= emptyCells.length) { clearInterval(int); setTimeout(resolve, 300); return; } const cell = emptyCells[i]; const color = COLORS[Math.floor(Math.random() * COLORS.length)]; if(cell) cell.classList.add('filled', color); i++; }, 10); }); }
        function showBBGameOverModal(isRecord, score, oldBest) { const modal = document.getElementById('bbGameOverContent'); const overlay = document.getElementById('modalBBGameOver'); modal.innerHTML = ''; if(isRecord) { confetti({ particleCount: 200, spread: 100, origin: { y: 0.6 }, zIndex: 22000 }); modal.innerHTML = `${ICON_CROWN}<h2 style="margin:0 0 10px 0; font-size:24px;">Новый Рекорд!</h2><div style="font-size:48px; font-weight:800; color:var(--accent); margin:10px 0;" id="recCounter">0</div><button class="btn-main" onclick="closeResult(); newGameBB();">Играть снова</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="closeResult()">Выйти</button>`; let s = oldBest; const step = Math.ceil((score - oldBest) / 30); const counter = document.getElementById('recCounter'); const int = setInterval(() => { s += step; if(s >= score) { s = score; clearInterval(int); } counter.innerText = s; }, 30); } else { modal.innerHTML = `<h2 style="margin:0 0 5px 0;">Рекорд не побит</h2><p style="color:#8e8e93; margin:0 0 20px 0;">Попробуйте еще раз!</p><div style="font-size:32px; font-weight:700;">${score}</div><div style="font-size:14px; color:#8e8e93; margin-bottom:20px;">Лучший: ${oldBest}</div><button class="btn-main" onclick="closeResult(); newGameBB();">Новая игра</button><button style="margin-top:10px; background:none; border:none; color:#8e8e93; font-size:16px;" onclick="closeResult()">Выйти</button>`; } overlay.classList.add('visible'); }
        function saveBBState() { if(bbShapes.every(s=>s===null)) return; const state = { grid: bbGrid, score: bbScore, shapes: bbShapes, combo: bbCombo, buffer: bbComboBuffer }; localStorage.setItem('bb_state', JSON.stringify(state)); }
        function restoreBBState() { const data = JSON.parse(localStorage.getItem('bb_state')); if(!data) { initBB(); return; } bbGrid = data.grid; bbScore = data.score; bbCombo = data.combo || 0; bbComboBuffer = data.buffer || 0; bbDisplayedScore = bbScore; bbShapes = data.shapes; updateBBScoreUI(); document.getElementById('bbBestScore').innerText = localStorage.getItem('bb_best_score') || 0; renderBBGrid(); for(let i=0; i<3; i++) { if(bbShapes[i]) renderShapePreview(i, bbShapes[i].matrix, bbShapes[i].color); else document.getElementById(`shape${i}`).innerHTML = ''; } }
        function showResult(title, text, btnText="Закрыть", action=null) { document.getElementById('resTitle').innerText=title; document.getElementById('resText').innerText=text; const btn=document.getElementById('resBtn'); btn.innerText=btnText; btn.onclick=action?action:closeResult; document.getElementById('modalResult').classList.add('visible'); }

        /* SUDOKU */
        let sudoBoard = [], sudoSolution = [], activeDigit = null, sudoLives = 3, sudoFilled = 0; let selectedSudoDiff = 40; let currentSudoMode = 1;
        function startSudokuCheck() { if(localStorage.getItem('sudo_state')) document.getElementById('modalSudokuResume').classList.add('visible'); else document.getElementById('modalSudoku').classList.add('visible'); }
        function resumeSudoku() { document.getElementById('modalSudokuResume').classList.remove('visible'); document.getElementById('sudoku-screen').classList.add('visible'); restoreSudokuState(); }
        function selectSudokuDiff(diff, btn, index) { selectedSudoDiff = diff; const glider = document.getElementById('sudokuGlider'); glider.style.transform = `translateY(${index * 100}%)`; const items = btn.parentNode.querySelectorAll('.segment-item'); items.forEach(i => i.classList.remove('active')); btn.classList.add('active'); tg.HapticFeedback.selectionChanged(); }
        function startSudoku() { document.getElementById('modalSudoku').classList.remove('visible'); document.getElementById('sudoku-screen').classList.add('visible'); generateSudoku(selectedSudoDiff); }
        function generateSudoku(holes) {
            if (holes === 30) currentSudoMode = 1; else if (holes === 40) currentSudoMode = 2; else currentSudoMode = 3;
            sudoBoard = Array(81).fill(0); sudoSolution = Array(81).fill(0); sudoLives = 3; sudoFilled = 0; activeDigit = null; document.querySelectorAll('.num-btn').forEach(b => { b.classList.remove('active-digit', 'disabled'); });
            document.getElementById('sudokuLives').innerText = "0/3"; document.getElementById('sudokuLives').style.color = "var(--text-color)";
            fillSudo(0, 0); sudoSolution = [...sudoBoard]; let removed = 0; while (removed < holes) { let idx = Math.floor(Math.random() * 81); if (sudoBoard[idx] !== 0) { sudoBoard[idx] = 0; removed++; } }
            renderSudoku(); checkNumberCompletion(); saveSudokuState();
        }
        function fillSudo(row, col) { if (col === 9) { row++; col = 0; } if (row === 9) return true; const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5); for (let num of nums) { if (isValidSudo(sudoBoard, row, col, num)) { sudoBoard[row * 9 + col] = num; if (fillSudo(row, col + 1)) return true; sudoBoard[row * 9 + col] = 0; } } return false; }
        function isValidSudo(board, row, col, num) { for (let x = 0; x < 9; x++) if (board[row * 9 + x] === num) return false; for (let x = 0; x < 9; x++) if (board[x * 9 + col] === num) return false; let startRow = Math.floor(row / 3) * 3, startCol = Math.floor(col / 3) * 3; for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) if (board[(startRow + i) * 9 + (startCol + j)] === num) return false; return true; }
        function renderSudoku() { const el = document.getElementById('sudokuBoard'); el.innerHTML = ''; sudoFilled = 0; for (let i = 0; i < 81; i++) { const cell = document.createElement('div'); cell.className = 'sudo-cell'; if (sudoBoard[i] !== 0) { cell.innerText = sudoBoard[i]; cell.classList.add('given'); sudoFilled++; } cell.onclick = () => onCellClick(i, cell); cell.dataset.idx = i; el.appendChild(cell); } }
        function activateDigit(num, btn) { if (btn.classList.contains('disabled')) return; if (activeDigit === num) { activeDigit = null; btn.classList.remove('active-digit'); highlightSameNumbers(null); tg.HapticFeedback.selectionChanged(); return; } activeDigit = num; document.querySelectorAll('.num-btn').forEach(b => b.classList.remove('active-digit')); btn.classList.add('active-digit'); highlightSameNumbers(num); tg.HapticFeedback.selectionChanged(); }
        function highlightSameNumbers(num) { const cells = document.querySelectorAll('.sudo-cell'); cells.forEach(c => c.classList.remove('same-num')); if (num === null) return; cells.forEach(cell => { if (parseInt(cell.innerText) === num) cell.classList.add('same-num'); }); }
        function checkNumberCompletion() { for(let i=1; i<=9; i++) { let count = 0; for(let j=0; j<81; j++) if(sudoBoard[j] === i) count++; const btn = document.getElementById(`nb${i}`); if(count >= 9) { btn.classList.add('disabled'); btn.classList.remove('active-digit'); if(activeDigit === i) { activeDigit = null; highlightSameNumbers(null); } } else { btn.classList.remove('disabled'); } } }
        function onCellClick(idx, cell) { if (activeDigit === null) return; if (sudoBoard[idx] !== 0) return; const correctVal = sudoSolution[idx]; if (activeDigit === correctVal) { cell.innerText = activeDigit; cell.classList.add('user-val', 'correct', 'same-num'); sudoBoard[idx] = activeDigit; sudoFilled++; tg.HapticFeedback.notificationOccurred('success'); cell.animate([{ transform: 'scale(0.5)' }, { transform: 'scale(1.2)' }, { transform: 'scale(1)' }], { duration: 300 }); checkNumberCompletion(); saveSudokuState(); checkSudokuWin(); } else { cell.innerText = activeDigit; cell.classList.add('error'); tg.HapticFeedback.notificationOccurred('error'); sudoLives--; document.getElementById('sudokuLives').innerText = `${3-sudoLives}/3`; document.getElementById('sudokuLives').style.color = "var(--danger)"; setTimeout(() => { cell.innerText = ''; cell.classList.remove('error'); }, 400); saveSudokuState(); if (sudoLives <= 0) { localStorage.removeItem('sudo_state'); setTimeout(() => showResult('Поражение', 'Слишком много ошибок'), 500); } } }
        function checkSudokuWin() { if (sudoFilled === 81) { confetti({particleCount:150,spread:70,origin:{y:0.6},zIndex:2147483647}); let points = currentSudoMode; let w = parseInt(localStorage.getItem('sudoku_wins')||0) + points; saveStatToCloud('sudoku_wins', w); sendStatToBackend('sudoku_wins', w); localStorage.removeItem('sudo_state'); showResult('Победа!', `Судоку решено! (+${points})`); } }
        function saveSudokuState() { if(sudoFilled === 81 || sudoLives <= 0) return; const state = { board: sudoBoard, sol: sudoSolution, lives: sudoLives, mode: currentSudoMode }; localStorage.setItem('sudo_state', JSON.stringify(state)); }
        function restoreSudokuState() { const data = JSON.parse(localStorage.getItem('sudo_state')); if(!data) { generateSudoku(40); return; } sudoBoard = data.board; sudoSolution = data.sol; sudoLives = data.lives; currentSudoMode = data.mode; document.getElementById('sudokuLives').innerText = `${3-sudoLives}/3`; if(sudoLives < 3) document.getElementById('sudokuLives').style.color = "var(--danger)"; renderSudoku(); checkNumberCompletion(); }

        // Start App
        initApp();
    </script>
</body>
</html>
