<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tower Prototype</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root {
            --bg-light: #f2f2f7;
            --bg-dark: #000000;
            --text-light: #000000;
            --text-dark: #ffffff;
            --accent: #FF2D55; /* Розово-красный акцент для Башни */
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background-color: var(--bg-light);
            color: var(--text-light);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, sans-serif;
            touch-action: none; /* Отключаем зум и скролл */
            transition: background-color 0.3s;
        }

        /* Темная тема через атрибут (эмулируем логику основного аппа) */
        body.dark-mode {
            background-color: var(--bg-dark);
            color: var(--text-dark);
        }
        
        /* Градиент фона как в оригинальной игре, но мягкий */
        #game-background {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(0,0,0,0.05) 100%);
            pointer-events: none;
        }
        body.dark-mode #game-background {
            background: linear-gradient(180deg, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.2) 100%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* UI Элементы */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #score {
            font-size: 80px;
            font-weight: 200;
            margin-top: 15vh;
            opacity: 0.8;
            text-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: transform 0.1s;
        }
        #score.bump { transform: scale(1.2); }

        #start-msg {
            position: absolute;
            bottom: 15%;
            font-size: 18px;
            font-weight: 600;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            animation: pulse 1.5s infinite;
        }

        /* Модалка проигрыша */
        #game-over-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 100;
        }
        #game-over-modal.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .card {
            background: rgba(255,255,255,0.85);
            padding: 30px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 300px;
        }
        body.dark-mode .card {
            background: rgba(30,30,30,0.85);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 14px;
            font-size: 18px;
            font-weight: 600;
            margin-top: 20px;
            cursor: pointer;
            width: 100%;
        }
        .btn:active { opacity: 0.8; transform: scale(0.98); }

        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.5; transform: scale(0.95); }
        }
    </style>
</head>
<body>

    <div id="game-background"></div>

    <div class="ui-layer">
        <div id="score">0</div>
        <div id="start-msg">Нажми, чтобы начать</div>
    </div>

    <div id="game-over-modal">
        <div class="card">
            <h2 style="margin: 0 0 10px;">Игра окончена</h2>
            <div id="final-score" style="font-size: 48px; font-weight: 800; color: var(--accent);">0</div>
            <button class="btn" onclick="restartGame()">Играть снова</button>
        </div>
    </div>

    <canvas id="canvas"></canvas>

<script>
    // --- НАСТРОЙКИ ---
    const tg = window.Telegram.WebApp;
    tg.expand();
    
    // Определение темы
    const isDark = tg.colorScheme === 'dark';
    if(isDark) document.body.classList.add('dark-mode');

    // --- ПЕРЕМЕННЫЕ ИГРЫ ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const startMsg = document.getElementById('start-msg');
    const modal = document.getElementById('game-over-modal');
    const finalScoreEl = document.getElementById('final-score');

    let blocks = []; // Массив блоков башни
    let debris = []; // Массив обломков
    let score = 0;
    let state = 'start'; // start, playing, gameover
    let hue = 0; // Цвет (HSL)
    
    // Параметры "Камеры" и размеров
    let zoom = 1; 
    let cameraY = 0;
    
    // Текущий движущийся блок
    let currentBlock = null;
    let direction = 'x'; // 'x' или 'z' (в изометрии это две диагонали)
    let speed = 2.5;
    
    // Константы размеров
    const BLOCK_HEIGHT = 40; // Высота самого "кирпича"
    const BASE_SIZE = 140;   // Начальная ширина/глубина
    
    // Инициализация размеров экрана
    function resize() {
        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        // Центр экрана (база башни)
        cameraY = 0;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- ЛОГИКА ---

    function startGame() {
        blocks = [];
        debris = [];
        score = 0;
        speed = 2.5;
        direction = 'x';
        hue = Math.random() * 360;
        state = 'playing';
        cameraY = 0;
        
        scoreEl.innerText = score;
        startMsg.style.display = 'none';
        modal.classList.remove('visible');

        // Добавляем Базовый (Нижний) Блок
        // x, z - логические координаты. w, d - ширина и глубина.
        addBlock({
            x: 0,
            z: 0,
            w: BASE_SIZE,
            d: BASE_SIZE,
            color: getHSL(hue)
        });

        spawnNextBlock();
        loop();
    }

    function addBlock(block) {
        // Вычисляем изометрические координаты для отрисовки (screenX, screenY) один раз
        // Но для логики храним x, z
        blocks.push(block);
    }

    function spawnNextBlock() {
        const prev = blocks[blocks.length - 1];
        hue += 6; // Сдвиг цвета
        direction = direction === 'x' ? 'z' : 'x'; // Меняем ось
        
        // Начальная позиция спавна (далеко сбоку)
        let spawnPos = -300; 
        
        currentBlock = {
            x: direction === 'x' ? spawnPos : prev.x,
            z: direction === 'z' ? spawnPos : prev.z,
            w: prev.w,
            d: prev.d,
            color: getHSL(hue),
            moveDir: 1 // 1 = вперед, -1 = назад
        };
    }

    function update() {
        if (state !== 'playing' || !currentBlock) return;

        // Движение блока (Пинг-понг)
        const limit = 320; // Граница движения
        const moveAmount = speed;

        if (direction === 'x') {
            currentBlock.x += moveAmount * currentBlock.moveDir;
            if (currentBlock.x > limit) currentBlock.moveDir = -1;
            if (currentBlock.x < -limit) currentBlock.moveDir = 1;
        } else {
            currentBlock.z += moveAmount * currentBlock.moveDir;
            if (currentBlock.z > limit) currentBlock.moveDir = -1;
            if (currentBlock.z < -limit) currentBlock.moveDir = 1;
        }

        // Плавное движение камеры вверх
        // Мы хотим, чтобы верхушка башни была примерно в нижней трети экрана
        const targetY = (blocks.length * BLOCK_HEIGHT) - 100;
        cameraY += (targetY - cameraY) * 0.1;
    }

    // --- ОБРАБОТКА КЛИКА (ГЛАВНАЯ ЛОГИКА) ---
    function handleTap(e) {
        if (e) e.preventDefault();

        if (state === 'start' || state === 'gameover') {
            // Если игра не идет, клик ничего не делает тут (старт через функцию startGame)
            if(state === 'start') startGame();
            return;
        }

        placeBlock();
    }

    function placeBlock() {
        if (!currentBlock) return;

        const prev = blocks[blocks.length - 1];
        
        let diff, overlap;
        let cutSize, cutPos;
        let isGameOver = false;

        // Расчет обрезки
        if (direction === 'x') {
            // Двигались по X
            diff = currentBlock.x - prev.x;
            // Overlap = Ширина минус модуль смещения
            overlap = prev.w - Math.abs(diff);
            
            if (overlap > 0) {
                // Успех (частично или полностью)
                cutSize = Math.abs(diff); // Сколько отрезать
                
                // Обрезаем текущий блок
                currentBlock.w = overlap;
                
                // Сдвигаем текущий блок так, чтобы он лежал ровно на предыдущем
                if (diff > 0) { 
                    // Уехал вправо -> отрезаем справа
                    currentBlock.x = prev.x + (diff / 2); // Новый центр смещается
                    // Обломок (Debris)
                    addDebris(currentBlock.x + (overlap/2) + (cutSize/2), currentBlock.z, cutSize, currentBlock.d);
                } else {
                    // Уехал влево -> отрезаем слева
                    currentBlock.x = prev.x + (diff / 2);
                    addDebris(currentBlock.x - (overlap/2) - (cutSize/2), currentBlock.z, cutSize, currentBlock.d);
                }
            } else {
                isGameOver = true;
            }
        } else {
            // Двигались по Z
            diff = currentBlock.z - prev.z;
            overlap = prev.d - Math.abs(diff);
            
            if (overlap > 0) {
                cutSize = Math.abs(diff);
                currentBlock.d = overlap;

                if (diff > 0) {
                    currentBlock.z = prev.z + (diff / 2);
                    addDebris(currentBlock.x, currentBlock.z + (overlap/2) + (cutSize/2), currentBlock.w, cutSize);
                } else {
                    currentBlock.z = prev.z + (diff / 2);
                    addDebris(currentBlock.x, currentBlock.z - (overlap/2) - (cutSize/2), currentBlock.w, cutSize);
                }
            } else {
                isGameOver = true;
            }
        }

        if (isGameOver) {
            // Блок падает целиком
            addDebris(currentBlock.x, currentBlock.z, currentBlock.w, currentBlock.d);
            gameOver();
        } else {
            // Идеальное попадание? (с допуском)
            if (Math.abs(diff) < 3) {
                // Восстанавливаем размер (Бонус) или просто эффект
                scoreEl.classList.add('bump');
                setTimeout(() => scoreEl.classList.remove('bump'), 100);
                // Примагничиваем идеально
                currentBlock.x = prev.x;
                currentBlock.z = prev.z;
                currentBlock.w = prev.w;
                currentBlock.d = prev.d;
                tg.HapticFeedback.notificationOccurred('success');
            } else {
                tg.HapticFeedback.impactOccurred('light');
            }

            // Добавляем блок в башню
            addBlock(currentBlock);
            score++;
            scoreEl.innerText = score;
            speed += 0.05; // Ускоряем
            spawnNextBlock();
        }
    }

    function addDebris(x, z, w, d) {
        debris.push({
            x: x, z: z, w: w, d: d,
            color: currentBlock.color,
            vy: 0, // Вертикальная скорость (падение вниз экрана)
            yOffset: 0, // Смещение по Y (экранное)
            alpha: 1
        });
    }

    function gameOver() {
        state = 'gameover';
        tg.HapticFeedback.notificationOccurred('error');
        finalScoreEl.innerText = score;
        modal.classList.add('visible');
    }

    function restartGame() {
        startGame();
    }

    // --- ОТРИСОВКА ---

    function loop() {
        if(state === 'gameover' && debris.length === 0) return; // Останавливаем отрисовку если все упало
        requestAnimationFrame(loop);
        
        // Логика
        update();
        
        // Очистка
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // --- РИСОВАНИЕ ---
        
        const centerX = canvas.width / 2;
        const startY = canvas.height / 1.5; // Базовая точка на экране

        // Рисуем блоки (снизу вверх)
        // Чтобы камера двигалась, мы вычитаем cameraY из позиции Y
        
        // Рисуем башню
        blocks.forEach((b, i) => {
            // Высота в стопке
            const stackY = i * BLOCK_HEIGHT; 
            drawIsoRect(centerX, startY, b.x, b.z, b.w, b.d, stackY, b.color);
        });

        // Рисуем текущий блок
        if (currentBlock && state === 'playing') {
            const stackY = blocks.length * BLOCK_HEIGHT;
            drawIsoRect(centerX, startY, currentBlock.x, currentBlock.z, currentBlock.w, currentBlock.d, stackY, currentBlock.color);
        }

        // Рисуем обломки (падают)
        debris.forEach((d, i) => {
            d.vy += 1; // Гравитация
            d.yOffset -= d.vy; // В изометрии Y растет вверх, а падение вниз
            d.alpha -= 0.02;
            
            // Текущая высота обломка равна высоте блока, от которого он откололся
            // Для упрощения считаем, что он откололся от вершины
            const stackY = (blocks.length) * BLOCK_HEIGHT + d.yOffset;

            if (d.alpha <= 0) {
                debris.splice(i, 1);
            } else {
                ctx.globalAlpha = d.alpha;
                drawIsoRect(centerX, startY, d.x, d.z, d.w, d.d, stackY, d.color);
                ctx.globalAlpha = 1;
            }
        });
    }

    // Главная функция рисования изометрического параллелепипеда
    // cx, cy - центр экрана (нулевая точка)
    // x, z - логические координаты смещения центра блока
    // w, d - ширина и глубина
    // yLevel - высота блока над землей (stack height)
    function drawIsoRect(cx, cy, x, z, w, d, yLevel, color) {
        // Конвертация в изометрию
        // Формула изометрии: 
        // isoX = (x - z) * cos(30)
        // isoY = (x + z) * sin(30) - yLevel
        
        // Мы используем коэффициенты 1 и 0.5 для простоты (стандарт пиксель-арта 2:1)
        const isoX = (x - z);
        const isoY = (x + z) * 0.5;
        
        // Экранные координаты центра нижней грани блока
        // Вычитаем cameraY, чтобы опускать башню
        const screenX = cx + isoX;
        const screenY = cy + isoY - yLevel + cameraY;

        // Рисуем верхнюю грань (Ромб)
        // Смещение от центра к вершинам
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(screenX, screenY - BLOCK_HEIGHT); // Центр (условно) - НЕТ, это не центр.
        
        // Давайте вычислим 4 угла верхней грани относительно screenX, screenY (это центр)
        // Но screenY у нас уже с учетом высоты.
        
        // Упрощение:
        // p1 = Top, p2 = Right, p3 = Bottom, p4 = Left
        const hw = w; // half width visual? Нет, w и d это реальные размеры
        const hd = d;
        
        // В изометрии:
        // Вектор X идет вправо-вниз
        // Вектор Z идет влево-вниз
        
        // Проекция векторов базиса
        const vecX_x = 1;   const vecX_y = 0.5;
        const vecZ_x = -1;  const vecZ_y = 0.5;
        
        // Вершины верхней грани относительно центра (screenX, screenY)
        // screenY - это уже "поверхность" блока
        
        function getIsoPoint(lx, lz) {
            return {
                x: screenX + (lx * vecX_x + lz * vecZ_x),
                y: screenY + (lx * vecX_y + lz * vecZ_y) - BLOCK_HEIGHT // Поднимаем на высоту блока
            };
        }
        
        const p_far = getIsoPoint(w/2, d/2); // Дальняя точка (верх) ?
        // Нет, логика координат: x - вправо, z - влево.
        // Верхняя грань:
        const p_top = getIsoPoint(-w/2, -d/2); // Верхняя точка ромба
        const p_right = getIsoPoint(w/2, -d/2);
        const p_bottom = getIsoPoint(w/2, d/2);
        const p_left = getIsoPoint(-w/2, d/2);

        // ВЕРХНЯЯ ГРАНЬ
        ctx.fillStyle = lighten(color, 10); // Светлее
        ctx.beginPath();
        ctx.moveTo(p_top.x, p_top.y);
        ctx.lineTo(p_right.x, p_right.y);
        ctx.lineTo(p_bottom.x, p_bottom.y);
        ctx.lineTo(p_left.x, p_left.y);
        ctx.closePath();
        ctx.fill();

        // ПРАВАЯ ГРАНЬ (Видна если мы смотрим сверху? Всегда видна в такой изометрии)
        // Соединяет p_bottom, p_right и их проекции вниз
        ctx.fillStyle = darken(color, 10); // Темнее
        ctx.beginPath();
        ctx.moveTo(p_right.x, p_right.y);
        ctx.lineTo(p_bottom.x, p_bottom.y);
        ctx.lineTo(p_bottom.x, p_bottom.y + BLOCK_HEIGHT);
        ctx.lineTo(p_right.x, p_right.y + BLOCK_HEIGHT);
        ctx.closePath();
        ctx.fill();

        // ЛЕВАЯ ГРАНЬ
        ctx.fillStyle = darken(color, 20); // Еще темнее (тень)
        ctx.beginPath();
        ctx.moveTo(p_left.x, p_left.y);
        ctx.lineTo(p_bottom.x, p_bottom.y);
        ctx.lineTo(p_bottom.x, p_bottom.y + BLOCK_HEIGHT);
        ctx.lineTo(p_left.x, p_left.y + BLOCK_HEIGHT);
        ctx.closePath();
        ctx.fill();
        
        // Верхняя белая обводка для стиля (Glass)
        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p_top.x, p_top.y);
        ctx.lineTo(p_right.x, p_right.y);
        ctx.lineTo(p_bottom.x, p_bottom.y);
        ctx.lineTo(p_left.x, p_left.y);
        ctx.closePath();
        ctx.stroke();
    }

    // --- УТИЛИТЫ ---
    function getHSL(h) {
        return `hsl(${h % 360}, 60%, ${isDark ? 60 : 50}%)`;
    }
    
    // Простые функции затемнения/осветления для HSL строк (грубая обработка)
    function lighten(hsl, percent) {
        // hsl(100, 60%, 50%) -> достаем 50, делаем +percent
        let parts = hsl.match(/hsl\((\d+\.?\d*),\s*(\d+)%,\s*(\d+)%\)/);
        if(!parts) return hsl;
        let l = Math.min(100, parseInt(parts[3]) + percent);
        return `hsl(${parts[1]}, ${parts[2]}%, ${l}%)`;
    }
    function darken(hsl, percent) {
        let parts = hsl.match(/hsl\((\d+\.?\d*),\s*(\d+)%,\s*(\d+)%\)/);
        if(!parts) return hsl;
        let l = Math.max(0, parseInt(parts[3]) - percent);
        return `hsl(${parts[1]}, ${parts[2]}%, ${l}%)`;
    }

    // Запуск по клику на экран
    document.addEventListener('pointerdown', handleTap);
    document.addEventListener('keydown', (e) => { if(e.code === 'Space') handleTap(e); });

</script>
</body>
</html>
