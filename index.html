<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tower Stack</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root {
            --bg-light: #f2f2f7;
            --bg-dark: #000000;
            --text-light: #000000;
            --text-dark: #ffffff;
            --accent: #007aff;
            --glass-bg: rgba(255, 255, 255, 0.85);
            --glass-border: rgba(255, 255, 255, 0.5);
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: var(--bg-light);
            color: var(--text-light);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body.dark-mode {
            background-color: var(--bg-dark);
            color: var(--text-dark);
            --glass-bg: rgba(30, 30, 30, 0.85);
            --glass-border: rgba(255, 255, 255, 0.1);
        }
        
        #game-background {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(0,0,0,0.05) 100%);
            pointer-events: none;
            z-index: -1;
        }
        body.dark-mode #game-background {
            background: linear-gradient(180deg, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.3) 100%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1;
        }

        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* ИСПРАВЛЕНИЕ 1: Новый стиль счетчика (как в Block Blast) */
        #score {
            position: absolute;
            top: 10%;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 80px; 
            font-weight: 800; /* Жирный */
            color: var(--accent); /* Синий цвет */
            opacity: 1; /* Не прозрачный */
            font-feature-settings: "tnum";
            text-shadow: 0 4px 15px rgba(0, 122, 255, 0.25); /* Легкое свечение/тень */
            transition: transform 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
        }
        #score.bump { transform: scale(1.2); }

        #start-msg {
            position: absolute;
            bottom: 15%;
            width: 100%;
            text-align: center;
            font-size: 17px;
            font-weight: 600;
            color: var(--accent);
            opacity: 0.8;
            animation: pulse 2s infinite;
        }

        #game-over-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 100;
        }
        #game-over-modal.visible { opacity: 1; pointer-events: auto; }
        
        .card {
            background: var(--glass-bg);
            padding: 30px 20px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
            border: 1px solid var(--glass-border);
            width: 70%;
            max-width: 280px;
            transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #game-over-modal.visible .card { transform: scale(1); }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 14px;
            font-size: 17px;
            font-weight: 600;
            margin-top: 20px;
            cursor: pointer;
            width: 100%;
            transition: transform 0.1s, opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
        }
        .btn:active { opacity: 0.8; transform: scale(0.96); }
        
        .crown-icon {
            width: 40px; height: 40px; 
            fill: #ffffff; 
            margin: 0 auto 10px auto; 
            display: none;
        }

        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.5; transform: scale(0.98); }
        }
    </style>
</head>
<body>

    <div id="game-background"></div>

    <div class="ui-layer">
        <div id="score">0</div>
        <div id="start-msg">Нажми, чтобы начать</div>
    </div>

    <div id="game-over-modal">
        <div class="card">
            <svg id="crown" class="crown-icon" viewBox="0 0 24 24"><path d="M5 16L3 5l5.5 5L12 4l3.5 6L21 5l-2 11H5zm14 3c0 .6-.4 1-1 1H6c-.6 0-1-.4-1-1v-1h14v1z"/></svg>
            <h2 id="go-title" style="margin: 0 0 5px; font-weight: 800; font-size: 22px;">Игра окончена</h2>
            <div id="go-subtitle" style="font-size: 14px; color: #8e8e93; margin-bottom: 10px;">Ваш результат</div>
            <div id="final-score" style="font-size: 56px; font-weight: 200; color: var(--text-light); line-height: 1;">0</div>
            <button class="btn" onclick="restartGame()">Играть снова</button>
        </div>
    </div>

    <canvas id="canvas"></canvas>

<script>
    const tg = window.Telegram.WebApp;
    tg.expand();
    const isDark = tg.colorScheme === 'dark';
    if(isDark) document.body.classList.add('dark-mode');

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const startMsg = document.getElementById('start-msg');
    const modal = document.getElementById('game-over-modal');
    const finalScoreEl = document.getElementById('final-score');
    const goTitle = document.getElementById('go-title');
    const goSub = document.getElementById('go-subtitle');
    const crown = document.getElementById('crown');

    let blocks = [];
    let debris = []; 
    let score = 0;
    let state = 'start'; 
    let hue = 0; 
    let cameraY = 0; 
    let perfectMatchAlpha = 0;
    
    let currentBlock = null;
    let direction = 'x'; 
    let speed = 3.0;
    
    let bestScore = parseInt(localStorage.getItem('tower_best') || 0);

    const BLOCK_HEIGHT = 35; 
    const BASE_SIZE = 130; 
    
    function resize() {
        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }
    window.addEventListener('resize', resize);
    resize();

    function startGame() {
        speed = 3.0;
        blocks = [];
        debris = [];
        score = 0;
        direction = 'x';
        hue = Math.floor(Math.random() * 360);
        state = 'playing';
        cameraY = 0;
        perfectMatchAlpha = 0;
        
        scoreEl.innerText = score;
        startMsg.style.display = 'none';
        modal.classList.remove('visible');

        addBlock({
            x: 0, z: 0, w: BASE_SIZE, d: BASE_SIZE, color: getHSL(hue)
        });

        spawnNextBlock();
        loop();
    }

    function addBlock(block) { blocks.push(block); }

    function spawnNextBlock() {
        const prev = blocks[blocks.length - 1];
        hue += 6; 
        direction = direction === 'x' ? 'z' : 'x'; 
        const dist = 350;
        
        currentBlock = {
            x: direction === 'x' ? -dist : prev.x,
            z: direction === 'z' ? -dist : prev.z,
            w: prev.w, d: prev.d,
            color: getHSL(hue),
            moveDir: 1 
        };
    }

    function updatePhysics() {
        if (state !== 'playing' || !currentBlock) return;
        const limit = 360;
        
        if (direction === 'x') {
            currentBlock.x += speed * currentBlock.moveDir;
            if (currentBlock.x > limit) currentBlock.moveDir = -1;
            if (currentBlock.x < -limit) currentBlock.moveDir = 1;
        } else {
            currentBlock.z += speed * currentBlock.moveDir;
            if (currentBlock.z > limit) currentBlock.moveDir = -1;
            if (currentBlock.z < -limit) currentBlock.moveDir = 1;
        }

        const targetY = (blocks.length * BLOCK_HEIGHT) - 150;
        if(targetY > 0) cameraY += (targetY - cameraY) * 0.05;

        if(perfectMatchAlpha > 0) perfectMatchAlpha -= 0.05;
    }

    function handleAction(e) {
        if (e) e.preventDefault(); 
        if (state === 'start' || state === 'gameover') {
            if(state === 'start') startGame();
            return;
        }
        placeBlock();
    }

    function placeBlock() {
        if (!currentBlock) return;
        const prev = blocks[blocks.length - 1];
        let diff;
        if (direction === 'x') diff = currentBlock.x - prev.x;
        else diff = currentBlock.z - prev.z;

        if (Math.abs(diff) < 4) {
            currentBlock.x = prev.x;
            currentBlock.z = prev.z;
            currentBlock.w = prev.w;
            currentBlock.d = prev.d;
            
            scoreEl.classList.add('bump');
            setTimeout(() => scoreEl.classList.remove('bump'), 150);
            tg.HapticFeedback.notificationOccurred('success');
            
            perfectMatchAlpha = 1.0;
            commitBlock();
            return;
        }

        let overlap, cutSize, debrisX, debrisZ;
        let isGameOver = false;
        let impulseX = 0, impulseZ = 0;
        let debrisBehind = (diff < 0);

        // ИСПРАВЛЕНИЕ 2: Уменьшена сила импульса (было 4, стало 2.5) для плавности
        if (direction === 'x') {
            overlap = prev.w - Math.abs(diff);
            if (overlap > 0) {
                cutSize = Math.abs(diff);
                currentBlock.w = overlap; 
                if (diff > 0) { 
                    currentBlock.x = prev.x + (diff / 2);
                    debrisX = currentBlock.x + (overlap/2) + (cutSize/2);
                    impulseX = 2.5; 
                } else { 
                    currentBlock.x = prev.x + (diff / 2);
                    debrisX = currentBlock.x - (overlap/2) - (cutSize/2);
                    impulseX = -2.5;
                }
                addDebris(debrisX, currentBlock.z, cutSize, currentBlock.d, impulseX, 0, debrisBehind);
            } else isGameOver = true;
        } else { 
            overlap = prev.d - Math.abs(diff);
            if (overlap > 0) {
                cutSize = Math.abs(diff);
                currentBlock.d = overlap; 
                if (diff > 0) { 
                    currentBlock.z = prev.z + (diff / 2);
                    debrisZ = currentBlock.z + (overlap/2) + (cutSize/2);
                    impulseZ = 2.5;
                } else { 
                    currentBlock.z = prev.z + (diff / 2);
                    debrisZ = currentBlock.z - (overlap/2) - (cutSize/2);
                    impulseZ = -2.5;
                }
                addDebris(currentBlock.x, debrisZ, currentBlock.w, cutSize, 0, impulseZ, debrisBehind);
            } else isGameOver = true;
        }

        if (isGameOver) {
            let gameOverBehind = (diff < 0); 
            addDebris(currentBlock.x, currentBlock.z, currentBlock.w, currentBlock.d, direction==='x'?currentBlock.moveDir*2:0, direction==='z'?currentBlock.moveDir*2:0, gameOverBehind);
            gameOver();
        } else {
            tg.HapticFeedback.impactOccurred('light');
            commitBlock();
        }
    }

    function commitBlock() {
        addBlock(currentBlock);
        score++;
        scoreEl.innerText = score;
        speed += 0.02; 
        spawnNextBlock();
    }

    // ИСПРАВЛЕНИЕ 2: Плавная физика обломков
    function addDebris(x, z, w, d, vx, vz, isBehind) {
        // Уменьшена скорость вращения (было 0.1, стало 0.04)
        const rotSpeed = (Math.random() > 0.5 ? 1 : -1) * (0.02 + Math.random() * 0.04); 
        
        debris.push({
            x: x, z: z, w: w, d: d,
            color: currentBlock.color,
            vy: 0, 
            vx: vx, vz: vz,
            yOffset: 0,
            angle: 0, 
            vRot: rotSpeed, 
            alpha: 1,
            isBehind: isBehind
        });
    }

    function gameOver() {
        state = 'gameover';
        tg.HapticFeedback.notificationOccurred('error');
        finalScoreEl.innerText = score;
        
        let isRecord = false;
        if(score > bestScore) {
            bestScore = score;
            localStorage.setItem('tower_best', bestScore);
            isRecord = true;
        }

        if(isDark) finalScoreEl.style.color = '#ffffff';
        else finalScoreEl.style.color = '#000000';

        if(isRecord && score > 0) {
            goTitle.innerText = "Новый рекорд!";
            goSub.innerText = "Вы построили огромную башню!";
            crown.style.display = "block";
            finalScoreEl.style.color = "var(--accent)";
            confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 }, zIndex: 20000 });
        } else {
            goTitle.innerText = "Игра окончена";
            goSub.innerText = `Лучший: ${bestScore}`;
            crown.style.display = "none";
        }
        modal.classList.add('visible');
    }

    function restartGame() { startGame(); }

    function loop() {
        if(state === 'gameover' && debris.length === 0 && perfectMatchAlpha <= 0) return;
        requestAnimationFrame(loop);
        updatePhysics();
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        const cx = window.innerWidth / 2;
        const cy = window.innerHeight / 1.5; 

        debris.forEach(d => { if (d.isBehind) updateAndDrawDebris(d, cx, cy); });

        blocks.forEach((b, i) => {
            const stackY = i * BLOCK_HEIGHT; 
            let highlight = (i === blocks.length - 1 && perfectMatchAlpha > 0);
            drawIsoBlock(cx, cy, b.x, b.z, b.w, b.d, stackY, b.color, highlight);
        });

        if (currentBlock && state === 'playing') {
            const stackY = blocks.length * BLOCK_HEIGHT;
            drawIsoBlock(cx, cy, currentBlock.x, currentBlock.z, currentBlock.w, currentBlock.d, stackY, currentBlock.color, false);
        }

        debris.forEach(d => { if (!d.isBehind) updateAndDrawDebris(d, cx, cy); });
        
        debris = debris.filter(d => d.alpha > 0);
    }
    
    function updateAndDrawDebris(d, cx, cy) {
        // Уменьшена гравитация с 0.8 до 0.5 (для плавности)
        d.vy += 0.5; 
        d.yOffset -= d.vy;
        d.x += d.vx; d.z += d.vz;
        d.angle += d.vRot; 
        // Медленное затухание (чтобы успеть увидеть падение)
        d.alpha -= 0.015; 
        
        const stackY = (blocks.length) * BLOCK_HEIGHT + d.yOffset;

        if (d.alpha > 0) {
            ctx.globalAlpha = d.alpha;
            ctx.save();
            const isoX = (d.x - d.z);
            const isoY = (d.x + d.z) * 0.5;
            const screenX = cx + isoX;
            const screenY = cy + isoY - stackY + cameraY - (BLOCK_HEIGHT/2);
            ctx.translate(screenX, screenY);
            ctx.rotate(d.angle);
            drawRotatedIsoBlock(d.w, d.d, d.color);
            ctx.restore();
            ctx.globalAlpha = 1;
        }
    }
    
    function drawRotatedIsoBlock(w, d, color) {
        const vecX_x = 1;   const vecX_y = 0.5;
        const vecZ_x = -1;  const vecZ_y = 0.5;
        
        function getLocIso(lx, lz) {
            return {
                x: (lx * vecX_x + lz * vecZ_x),
                y: (lx * vecX_y + lz * vecZ_y) - (BLOCK_HEIGHT/2)
            };
        }
        
        const p_top = getLocIso(-w/2, -d/2);
        const p_right = getLocIso(w/2, -d/2);
        const p_bottom = getLocIso(w/2, d/2);
        const p_left = getLocIso(-w/2, d/2);

        ctx.fillStyle = lighten(color, 15); ctx.beginPath(); ctx.moveTo(p_top.x, p_top.y); ctx.lineTo(p_right.x, p_right.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_left.x, p_left.y); ctx.closePath(); ctx.fill();
        ctx.fillStyle = darken(color, 10); ctx.beginPath(); ctx.moveTo(p_right.x, p_right.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_bottom.x, p_bottom.y + BLOCK_HEIGHT); ctx.lineTo(p_right.x, p_right.y + BLOCK_HEIGHT); ctx.closePath(); ctx.fill();
        ctx.fillStyle = darken(color, 25); ctx.beginPath(); ctx.moveTo(p_left.x, p_left.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_bottom.x, p_bottom.y + BLOCK_HEIGHT); ctx.lineTo(p_left.x, p_left.y + BLOCK_HEIGHT); ctx.closePath(); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(p_top.x, p_top.y); ctx.lineTo(p_right.x, p_right.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_left.x, p_left.y); ctx.closePath(); ctx.stroke();
    }

    function drawIsoBlock(cx, cy, x, z, w, d, yLevel, color, highlight) {
        const isoX = (x - z);
        const isoY = (x + z) * 0.5;
        const screenX = cx + isoX;
        const screenY = cy + isoY - yLevel + cameraY;

        const p_top = getIsoPoint(screenX, screenY, -w/2, -d/2);
        const p_right = getIsoPoint(screenX, screenY, w/2, -d/2);
        const p_bottom = getIsoPoint(screenX, screenY, w/2, d/2);
        const p_left = getIsoPoint(screenX, screenY, -w/2, d/2);

        ctx.fillStyle = lighten(color, 15); ctx.beginPath(); ctx.moveTo(p_top.x, p_top.y); ctx.lineTo(p_right.x, p_right.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_left.x, p_left.y); ctx.closePath(); ctx.fill();
        ctx.fillStyle = darken(color, 10); ctx.beginPath(); ctx.moveTo(p_right.x, p_right.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_bottom.x, p_bottom.y + BLOCK_HEIGHT); ctx.lineTo(p_right.x, p_right.y + BLOCK_HEIGHT); ctx.closePath(); ctx.fill();
        ctx.fillStyle = darken(color, 25); ctx.beginPath(); ctx.moveTo(p_left.x, p_left.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_bottom.x, p_bottom.y + BLOCK_HEIGHT); ctx.lineTo(p_left.x, p_left.y + BLOCK_HEIGHT); ctx.closePath(); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(p_top.x, p_top.y); ctx.lineTo(p_right.x, p_right.y); ctx.lineTo(p_bottom.x, p_bottom.y); ctx.lineTo(p_left.x, p_left.y); ctx.closePath(); ctx.stroke();

        if(highlight) {
            ctx.save();
            ctx.globalAlpha = perfectMatchAlpha;
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 3;
            ctx.shadowColor = "#ffffff";
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(p_left.x, p_left.y + BLOCK_HEIGHT);
            ctx.lineTo(p_bottom.x, p_bottom.y + BLOCK_HEIGHT);
            ctx.lineTo(p_right.x, p_right.y + BLOCK_HEIGHT);
            ctx.stroke();
            ctx.restore();
        }
    }
    
    function getIsoPoint(cx, cy, dx, dz) {
        return { x: cx + (dx - dz), y: cy + (dx + dz) * 0.5 - BLOCK_HEIGHT };
    }

    function getHSL(h) { return `hsl(${Math.floor(h % 360)}, 75%, ${isDark ? 60 : 55}%)`; }
    function lighten(hsl, amt) { return adjustLight(hsl, amt); }
    function darken(hsl, amt) { return adjustLight(hsl, -amt); }
    function adjustLight(hsl, amt) {
        const parts = hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
        if(!parts) return hsl;
        let l = Math.max(0, Math.min(100, parseInt(parts[3]) + amt));
        return `hsl(${parts[1]}, ${parts[2]}%, ${l}%)`;
    }

    document.addEventListener('pointerdown', handleAction);
    document.addEventListener('keydown', (e) => { if(e.code === 'Space') handleAction(e); });

</script>
</body>
</html>
